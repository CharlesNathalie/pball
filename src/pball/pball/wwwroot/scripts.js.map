{"version":3,"file":"scripts.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sBAAsB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,SAAS;AAC3D,yBAAyB,IAAI,IAAI,IAAI,IAAI,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,SAAS;AACnD,qBAAqB,EAAE,IAAI,EAAE,KAAK,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,UAAU;AACV,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA,UAAU;AACV,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA,UAAU;AACV,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD,UAAU,aAAa;AACvB,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,UAAU;AACV,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAyC;AACtE;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C,0BAA0B,yCAAyC;AACnE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6CAA6C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,kCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,gCAAgC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,GAAG,cAAc,GAAG,wBAAwB;AAC1E;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC,yDAAyD;AACzD,aAAa,qCAAqC;AAClD;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA,eAAe,gCAAgC;AAC/C,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,gCAAgC;AAC/C;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,UAAU;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,uBAAuB;AACvB,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA,kBAAkB;AAClB;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,oDAAoD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,eAAe,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAmD;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB,8BAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,UAAU;AACV,kBAAkB;AAClB;AACA;AACA;AACA,eAAe,eAAe,gBAAgB,4BAA4B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0CAA0C,sCAAsC;AAChF;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6CAA6C,kCAAkC;AAC/E,aAAa,iGAAiG;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAwD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAwD;AACrE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,6BAA6B,UAAU;AACvC;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAA4C;AACzD,aAAa,oBAAoB;AACjC;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,aAAa,4CAA4C;AACzD;AACA,aAAa,6BAA6B;AAC1C,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4CAA4C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA,yBAAyB,mDAAmD;AAC5E;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA,uDAAuD,kCAAkC;AACzF;AACA,yBAAyB,+DAA+D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAA6C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mDAAmD;AAC9G;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4DAA4D;AAC5D,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,6BAA6B,YAAY,cAAc,WAAW;AAClE;AACA;AACA,0BAA0B,YAAY,eAAe,WAAW;AAChE,6BAA6B,WAAW;AACxC;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY,GAAG,YAAY;AACxD;AACA,wBAAwB,YAAY,YAAY,YAAY;AAC5D,wBAAwB,YAAY;AACpC,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,UAAU,GAAG;AAC/C;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA,+BAA+B;AAC/B,uCAAuC;AACvC,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU,iCAAiC,+BAA+B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU;AAClE,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;AACA,wDAAwD,UAAU;AAClE,kDAAkD,gBAAgB;AAClE;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,2BAA2B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA,yEAAyE,kBAAkB;AAC3F;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,gCAAgC;AAC/C;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,mEAAmE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0EAA0E;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAA4C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB,4BAA4B,qBAAqB;AACjF,eAAe,+DAA+D;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAsD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,aAAa,oDAAoD;AACjE,aAAa,sCAAsC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,0BAA0B;AACvC;AACA,WAAW,sBAAsB;AACjC;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA,+CAA+C,8BAA8B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8BAA8B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,kBAAkB;AACnF;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU,QAAQ;AAC/B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,uBAAuB,aAAa;AACpC,UAAU;AACV,uBAAuB,cAAc;AACrC,uBAAuB,aAAa;AACpC;AACA,OAAO;AACP;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE,sBAAsB,qBAAqB;AAC3C;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sCAAsC;AACnD;AACA,kBAAkB,sCAAsC;AACxD,eAAe,QAAQ,yBAAyB,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,2DAA2D,8BAA8B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA;AACA;AACA;AACA,oBAAoB,4CAA4C;AAChE;AACA;AACA;AACA;AACA,kBAAkB,4CAA4C;AAC9D;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA,qBAAqB,8CAA8C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2CAA2C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB,SAAS,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,0BAA0B,SAAS,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAiD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;AACT;AACA,0BAA0B,iDAAiD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC,gBAAgB,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+BAA+B;AACjF;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS,8CAA8C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,+BAA+B,cAAc;AAC1D;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,aAAa,uCAAuC;AACpD,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sCAAsC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,yBAAyB;AACxC,eAAe,gBAAgB;AAC/B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,4DAA4D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,MAAM;AACrB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sEAAsE;AACnF;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,GAAG,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa,eAAe;AAC5B,oBAAoB,6DAA6D;AACjF;AACA;AACA;AACA;AACA,UAAU;AACV,sBAAsB,WAAW;AACjC;AACA,QAAQ;AACR,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,wBAAwB;AACvC,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,aAAa,eAAe,cAAc;AAC1C,mCAAmC,QAAQ;AAC3C;AACA;AACA,eAAe,2CAA2C;AAC1D,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,QAAQ;AACR;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD,eAAe,oCAAoC;AACnD,eAAe,qCAAqC;AACpD,aAAa,uCAAuC;AACpD,YAAY,wCAAwC;AACpD,aAAa,yCAAyC;AACtD,cAAc,uCAAuC;AACrD,gBAAgB,uCAAuC;AACvD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,aAAa,kBAAkB;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,I","sources":["src\\assets\\chart\\chart.js"],"sourcesContent":["/*!\r\n * Chart.js v3.2.1\r\n * https://www.chartjs.org\r\n * (c) 2021 Chart.js Contributors\r\n * Released under the MIT License\r\n */\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n    typeof define === 'function' && define.amd ? define(factory) :\r\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());\r\n    }(this, (function () { 'use strict';\r\n    \r\n    function fontString(pixelSize, fontStyle, fontFamily) {\r\n      return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n    }\r\n    const requestAnimFrame = (function() {\r\n      if (typeof window === 'undefined') {\r\n        return function(callback) {\r\n          return callback();\r\n        };\r\n      }\r\n      return window.requestAnimationFrame;\r\n    }());\r\n    function throttled(fn, thisArg, updateFn) {\r\n      const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\r\n      let ticking = false;\r\n      let args = [];\r\n      return function(...rest) {\r\n        args = updateArgs(rest);\r\n        if (!ticking) {\r\n          ticking = true;\r\n          requestAnimFrame.call(window, () => {\r\n            ticking = false;\r\n            fn.apply(thisArg, args);\r\n          });\r\n        }\r\n      };\r\n    }\r\n    function debounce(fn, delay) {\r\n      let timeout;\r\n      return function() {\r\n        if (delay) {\r\n          clearTimeout(timeout);\r\n          timeout = setTimeout(fn, delay);\r\n        } else {\r\n          fn();\r\n        }\r\n        return delay;\r\n      };\r\n    }\r\n    const _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\r\n    const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\r\n    const _textX = (align, left, right) => align === 'right' ? right : align === 'center' ? (left + right) / 2 : left;\r\n    \r\n    class Animator {\r\n      constructor() {\r\n        this._request = null;\r\n        this._charts = new Map();\r\n        this._running = false;\r\n        this._lastDate = undefined;\r\n      }\r\n      _notify(chart, anims, date, type) {\r\n        const callbacks = anims.listeners[type];\r\n        const numSteps = anims.duration;\r\n        callbacks.forEach(fn => fn({\r\n          chart,\r\n          initial: anims.initial,\r\n          numSteps,\r\n          currentStep: Math.min(date - anims.start, numSteps)\r\n        }));\r\n      }\r\n      _refresh() {\r\n        const me = this;\r\n        if (me._request) {\r\n          return;\r\n        }\r\n        me._running = true;\r\n        me._request = requestAnimFrame.call(window, () => {\r\n          me._update();\r\n          me._request = null;\r\n          if (me._running) {\r\n            me._refresh();\r\n          }\r\n        });\r\n      }\r\n      _update(date = Date.now()) {\r\n        const me = this;\r\n        let remaining = 0;\r\n        me._charts.forEach((anims, chart) => {\r\n          if (!anims.running || !anims.items.length) {\r\n            return;\r\n          }\r\n          const items = anims.items;\r\n          let i = items.length - 1;\r\n          let draw = false;\r\n          let item;\r\n          for (; i >= 0; --i) {\r\n            item = items[i];\r\n            if (item._active) {\r\n              if (item._total > anims.duration) {\r\n                anims.duration = item._total;\r\n              }\r\n              item.tick(date);\r\n              draw = true;\r\n            } else {\r\n              items[i] = items[items.length - 1];\r\n              items.pop();\r\n            }\r\n          }\r\n          if (draw) {\r\n            chart.draw();\r\n            me._notify(chart, anims, date, 'progress');\r\n          }\r\n          if (!items.length) {\r\n            anims.running = false;\r\n            me._notify(chart, anims, date, 'complete');\r\n            anims.initial = false;\r\n          }\r\n          remaining += items.length;\r\n        });\r\n        me._lastDate = date;\r\n        if (remaining === 0) {\r\n          me._running = false;\r\n        }\r\n      }\r\n      _getAnims(chart) {\r\n        const charts = this._charts;\r\n        let anims = charts.get(chart);\r\n        if (!anims) {\r\n          anims = {\r\n            running: false,\r\n            initial: true,\r\n            items: [],\r\n            listeners: {\r\n              complete: [],\r\n              progress: []\r\n            }\r\n          };\r\n          charts.set(chart, anims);\r\n        }\r\n        return anims;\r\n      }\r\n      listen(chart, event, cb) {\r\n        this._getAnims(chart).listeners[event].push(cb);\r\n      }\r\n      add(chart, items) {\r\n        if (!items || !items.length) {\r\n          return;\r\n        }\r\n        this._getAnims(chart).items.push(...items);\r\n      }\r\n      has(chart) {\r\n        return this._getAnims(chart).items.length > 0;\r\n      }\r\n      start(chart) {\r\n        const anims = this._charts.get(chart);\r\n        if (!anims) {\r\n          return;\r\n        }\r\n        anims.running = true;\r\n        anims.start = Date.now();\r\n        anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\r\n        this._refresh();\r\n      }\r\n      running(chart) {\r\n        if (!this._running) {\r\n          return false;\r\n        }\r\n        const anims = this._charts.get(chart);\r\n        if (!anims || !anims.running || !anims.items.length) {\r\n          return false;\r\n        }\r\n        return true;\r\n      }\r\n      stop(chart) {\r\n        const anims = this._charts.get(chart);\r\n        if (!anims || !anims.items.length) {\r\n          return;\r\n        }\r\n        const items = anims.items;\r\n        let i = items.length - 1;\r\n        for (; i >= 0; --i) {\r\n          items[i].cancel();\r\n        }\r\n        anims.items = [];\r\n        this._notify(chart, anims, Date.now(), 'complete');\r\n      }\r\n      remove(chart) {\r\n        return this._charts.delete(chart);\r\n      }\r\n    }\r\n    var animator = new Animator();\r\n    \r\n    /*!\r\n     * @kurkle/color v0.1.9\r\n     * https://github.com/kurkle/color#readme\r\n     * (c) 2020 Jukka Kurkela\r\n     * Released under the MIT License\r\n     */\r\n    const map = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\r\n    const hex = '0123456789ABCDEF';\r\n    const h1 = (b) => hex[b & 0xF];\r\n    const h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\r\n    const eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));\r\n    function isShort(v) {\r\n        return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\r\n    }\r\n    function hexParse(str) {\r\n        var len = str.length;\r\n        var ret;\r\n        if (str[0] === '#') {\r\n            if (len === 4 || len === 5) {\r\n                ret = {\r\n                    r: 255 & map[str[1]] * 17,\r\n                    g: 255 & map[str[2]] * 17,\r\n                    b: 255 & map[str[3]] * 17,\r\n                    a: len === 5 ? map[str[4]] * 17 : 255\r\n                };\r\n            } else if (len === 7 || len === 9) {\r\n                ret = {\r\n                    r: map[str[1]] << 4 | map[str[2]],\r\n                    g: map[str[3]] << 4 | map[str[4]],\r\n                    b: map[str[5]] << 4 | map[str[6]],\r\n                    a: len === 9 ? (map[str[7]] << 4 | map[str[8]]) : 255\r\n                };\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    function hexString(v) {\r\n        var f = isShort(v) ? h1 : h2;\r\n        return v\r\n            ? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')\r\n            : v;\r\n    }\r\n    function round(v) {\r\n        return v + 0.5 | 0;\r\n    }\r\n    const lim = (v, l, h) => Math.max(Math.min(v, h), l);\r\n    function p2b(v) {\r\n        return lim(round(v * 2.55), 0, 255);\r\n    }\r\n    function n2b(v) {\r\n        return lim(round(v * 255), 0, 255);\r\n    }\r\n    function b2n(v) {\r\n        return lim(round(v / 2.55) / 100, 0, 1);\r\n    }\r\n    function n2p(v) {\r\n        return lim(round(v * 100), 0, 100);\r\n    }\r\n    const RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\n    function rgbParse(str) {\r\n        const m = RGB_RE.exec(str);\r\n        let a = 255;\r\n        let r, g, b;\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (m[7] !== r) {\r\n            const v = +m[7];\r\n            a = 255 & (m[8] ? p2b(v) : v * 255);\r\n        }\r\n        r = +m[1];\r\n        g = +m[3];\r\n        b = +m[5];\r\n        r = 255 & (m[2] ? p2b(r) : r);\r\n        g = 255 & (m[4] ? p2b(g) : g);\r\n        b = 255 & (m[6] ? p2b(b) : b);\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n            a: a\r\n        };\r\n    }\r\n    function rgbString(v) {\r\n        return v && (\r\n            v.a < 255\r\n                ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\r\n                : `rgb(${v.r}, ${v.g}, ${v.b})`\r\n        );\r\n    }\r\n    const HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\n    function hsl2rgbn(h, s, l) {\r\n        const a = s * Math.min(l, 1 - l);\r\n        const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\r\n        return [f(0), f(8), f(4)];\r\n    }\r\n    function hsv2rgbn(h, s, v) {\r\n        const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\r\n        return [f(5), f(3), f(1)];\r\n    }\r\n    function hwb2rgbn(h, w, b) {\r\n        const rgb = hsl2rgbn(h, 1, 0.5);\r\n        let i;\r\n        if (w + b > 1) {\r\n            i = 1 / (w + b);\r\n            w *= i;\r\n            b *= i;\r\n        }\r\n        for (i = 0; i < 3; i++) {\r\n            rgb[i] *= 1 - w - b;\r\n            rgb[i] += w;\r\n        }\r\n        return rgb;\r\n    }\r\n    function rgb2hsl(v) {\r\n        const range = 255;\r\n        const r = v.r / range;\r\n        const g = v.g / range;\r\n        const b = v.b / range;\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        const l = (max + min) / 2;\r\n        let h, s, d;\r\n        if (max !== min) {\r\n            d = max - min;\r\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n            h = max === r\r\n                ? ((g - b) / d) + (g < b ? 6 : 0)\r\n                : max === g\r\n                    ? (b - r) / d + 2\r\n                    : (r - g) / d + 4;\r\n            h = h * 60 + 0.5;\r\n        }\r\n        return [h | 0, s || 0, l];\r\n    }\r\n    function calln(f, a, b, c) {\r\n        return (\r\n            Array.isArray(a)\r\n                ? f(a[0], a[1], a[2])\r\n                : f(a, b, c)\r\n        ).map(n2b);\r\n    }\r\n    function hsl2rgb(h, s, l) {\r\n        return calln(hsl2rgbn, h, s, l);\r\n    }\r\n    function hwb2rgb(h, w, b) {\r\n        return calln(hwb2rgbn, h, w, b);\r\n    }\r\n    function hsv2rgb(h, s, v) {\r\n        return calln(hsv2rgbn, h, s, v);\r\n    }\r\n    function hue(h) {\r\n        return (h % 360 + 360) % 360;\r\n    }\r\n    function hueParse(str) {\r\n        const m = HUE_RE.exec(str);\r\n        let a = 255;\r\n        let v;\r\n        if (!m) {\r\n            return;\r\n        }\r\n        if (m[5] !== v) {\r\n            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\r\n        }\r\n        const h = hue(+m[2]);\r\n        const p1 = +m[3] / 100;\r\n        const p2 = +m[4] / 100;\r\n        if (m[1] === 'hwb') {\r\n            v = hwb2rgb(h, p1, p2);\r\n        } else if (m[1] === 'hsv') {\r\n            v = hsv2rgb(h, p1, p2);\r\n        } else {\r\n            v = hsl2rgb(h, p1, p2);\r\n        }\r\n        return {\r\n            r: v[0],\r\n            g: v[1],\r\n            b: v[2],\r\n            a: a\r\n        };\r\n    }\r\n    function rotate(v, deg) {\r\n        var h = rgb2hsl(v);\r\n        h[0] = hue(h[0] + deg);\r\n        h = hsl2rgb(h);\r\n        v.r = h[0];\r\n        v.g = h[1];\r\n        v.b = h[2];\r\n    }\r\n    function hslString(v) {\r\n        if (!v) {\r\n            return;\r\n        }\r\n        const a = rgb2hsl(v);\r\n        const h = a[0];\r\n        const s = n2p(a[1]);\r\n        const l = n2p(a[2]);\r\n        return v.a < 255\r\n            ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\r\n            : `hsl(${h}, ${s}%, ${l}%)`;\r\n    }\r\n    const map$1 = {\r\n        x: 'dark',\r\n        Z: 'light',\r\n        Y: 're',\r\n        X: 'blu',\r\n        W: 'gr',\r\n        V: 'medium',\r\n        U: 'slate',\r\n        A: 'ee',\r\n        T: 'ol',\r\n        S: 'or',\r\n        B: 'ra',\r\n        C: 'lateg',\r\n        D: 'ights',\r\n        R: 'in',\r\n        Q: 'turquois',\r\n        E: 'hi',\r\n        P: 'ro',\r\n        O: 'al',\r\n        N: 'le',\r\n        M: 'de',\r\n        L: 'yello',\r\n        F: 'en',\r\n        K: 'ch',\r\n        G: 'arks',\r\n        H: 'ea',\r\n        I: 'ightg',\r\n        J: 'wh'\r\n    };\r\n    const names = {\r\n        OiceXe: 'f0f8ff',\r\n        antiquewEte: 'faebd7',\r\n        aqua: 'ffff',\r\n        aquamarRe: '7fffd4',\r\n        azuY: 'f0ffff',\r\n        beige: 'f5f5dc',\r\n        bisque: 'ffe4c4',\r\n        black: '0',\r\n        blanKedOmond: 'ffebcd',\r\n        Xe: 'ff',\r\n        XeviTet: '8a2be2',\r\n        bPwn: 'a52a2a',\r\n        burlywood: 'deb887',\r\n        caMtXe: '5f9ea0',\r\n        KartYuse: '7fff00',\r\n        KocTate: 'd2691e',\r\n        cSO: 'ff7f50',\r\n        cSnflowerXe: '6495ed',\r\n        cSnsilk: 'fff8dc',\r\n        crimson: 'dc143c',\r\n        cyan: 'ffff',\r\n        xXe: '8b',\r\n        xcyan: '8b8b',\r\n        xgTMnPd: 'b8860b',\r\n        xWay: 'a9a9a9',\r\n        xgYF: '6400',\r\n        xgYy: 'a9a9a9',\r\n        xkhaki: 'bdb76b',\r\n        xmagFta: '8b008b',\r\n        xTivegYF: '556b2f',\r\n        xSange: 'ff8c00',\r\n        xScEd: '9932cc',\r\n        xYd: '8b0000',\r\n        xsOmon: 'e9967a',\r\n        xsHgYF: '8fbc8f',\r\n        xUXe: '483d8b',\r\n        xUWay: '2f4f4f',\r\n        xUgYy: '2f4f4f',\r\n        xQe: 'ced1',\r\n        xviTet: '9400d3',\r\n        dAppRk: 'ff1493',\r\n        dApskyXe: 'bfff',\r\n        dimWay: '696969',\r\n        dimgYy: '696969',\r\n        dodgerXe: '1e90ff',\r\n        fiYbrick: 'b22222',\r\n        flSOwEte: 'fffaf0',\r\n        foYstWAn: '228b22',\r\n        fuKsia: 'ff00ff',\r\n        gaRsbSo: 'dcdcdc',\r\n        ghostwEte: 'f8f8ff',\r\n        gTd: 'ffd700',\r\n        gTMnPd: 'daa520',\r\n        Way: '808080',\r\n        gYF: '8000',\r\n        gYFLw: 'adff2f',\r\n        gYy: '808080',\r\n        honeyMw: 'f0fff0',\r\n        hotpRk: 'ff69b4',\r\n        RdianYd: 'cd5c5c',\r\n        Rdigo: '4b0082',\r\n        ivSy: 'fffff0',\r\n        khaki: 'f0e68c',\r\n        lavFMr: 'e6e6fa',\r\n        lavFMrXsh: 'fff0f5',\r\n        lawngYF: '7cfc00',\r\n        NmoncEffon: 'fffacd',\r\n        ZXe: 'add8e6',\r\n        ZcSO: 'f08080',\r\n        Zcyan: 'e0ffff',\r\n        ZgTMnPdLw: 'fafad2',\r\n        ZWay: 'd3d3d3',\r\n        ZgYF: '90ee90',\r\n        ZgYy: 'd3d3d3',\r\n        ZpRk: 'ffb6c1',\r\n        ZsOmon: 'ffa07a',\r\n        ZsHgYF: '20b2aa',\r\n        ZskyXe: '87cefa',\r\n        ZUWay: '778899',\r\n        ZUgYy: '778899',\r\n        ZstAlXe: 'b0c4de',\r\n        ZLw: 'ffffe0',\r\n        lime: 'ff00',\r\n        limegYF: '32cd32',\r\n        lRF: 'faf0e6',\r\n        magFta: 'ff00ff',\r\n        maPon: '800000',\r\n        VaquamarRe: '66cdaa',\r\n        VXe: 'cd',\r\n        VScEd: 'ba55d3',\r\n        VpurpN: '9370db',\r\n        VsHgYF: '3cb371',\r\n        VUXe: '7b68ee',\r\n        VsprRggYF: 'fa9a',\r\n        VQe: '48d1cc',\r\n        VviTetYd: 'c71585',\r\n        midnightXe: '191970',\r\n        mRtcYam: 'f5fffa',\r\n        mistyPse: 'ffe4e1',\r\n        moccasR: 'ffe4b5',\r\n        navajowEte: 'ffdead',\r\n        navy: '80',\r\n        Tdlace: 'fdf5e6',\r\n        Tive: '808000',\r\n        TivedBb: '6b8e23',\r\n        Sange: 'ffa500',\r\n        SangeYd: 'ff4500',\r\n        ScEd: 'da70d6',\r\n        pOegTMnPd: 'eee8aa',\r\n        pOegYF: '98fb98',\r\n        pOeQe: 'afeeee',\r\n        pOeviTetYd: 'db7093',\r\n        papayawEp: 'ffefd5',\r\n        pHKpuff: 'ffdab9',\r\n        peru: 'cd853f',\r\n        pRk: 'ffc0cb',\r\n        plum: 'dda0dd',\r\n        powMrXe: 'b0e0e6',\r\n        purpN: '800080',\r\n        YbeccapurpN: '663399',\r\n        Yd: 'ff0000',\r\n        Psybrown: 'bc8f8f',\r\n        PyOXe: '4169e1',\r\n        saddNbPwn: '8b4513',\r\n        sOmon: 'fa8072',\r\n        sandybPwn: 'f4a460',\r\n        sHgYF: '2e8b57',\r\n        sHshell: 'fff5ee',\r\n        siFna: 'a0522d',\r\n        silver: 'c0c0c0',\r\n        skyXe: '87ceeb',\r\n        UXe: '6a5acd',\r\n        UWay: '708090',\r\n        UgYy: '708090',\r\n        snow: 'fffafa',\r\n        sprRggYF: 'ff7f',\r\n        stAlXe: '4682b4',\r\n        tan: 'd2b48c',\r\n        teO: '8080',\r\n        tEstN: 'd8bfd8',\r\n        tomato: 'ff6347',\r\n        Qe: '40e0d0',\r\n        viTet: 'ee82ee',\r\n        JHt: 'f5deb3',\r\n        wEte: 'ffffff',\r\n        wEtesmoke: 'f5f5f5',\r\n        Lw: 'ffff00',\r\n        LwgYF: '9acd32'\r\n    };\r\n    function unpack() {\r\n        const unpacked = {};\r\n        const keys = Object.keys(names);\r\n        const tkeys = Object.keys(map$1);\r\n        let i, j, k, ok, nk;\r\n        for (i = 0; i < keys.length; i++) {\r\n            ok = nk = keys[i];\r\n            for (j = 0; j < tkeys.length; j++) {\r\n                k = tkeys[j];\r\n                nk = nk.replace(k, map$1[k]);\r\n            }\r\n            k = parseInt(names[ok], 16);\r\n            unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\r\n        }\r\n        return unpacked;\r\n    }\r\n    let names$1;\r\n    function nameParse(str) {\r\n        if (!names$1) {\r\n            names$1 = unpack();\r\n            names$1.transparent = [0, 0, 0, 0];\r\n        }\r\n        const a = names$1[str.toLowerCase()];\r\n        return a && {\r\n            r: a[0],\r\n            g: a[1],\r\n            b: a[2],\r\n            a: a.length === 4 ? a[3] : 255\r\n        };\r\n    }\r\n    function modHSL(v, i, ratio) {\r\n        if (v) {\r\n            let tmp = rgb2hsl(v);\r\n            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\r\n            tmp = hsl2rgb(tmp);\r\n            v.r = tmp[0];\r\n            v.g = tmp[1];\r\n            v.b = tmp[2];\r\n        }\r\n    }\r\n    function clone$1(v, proto) {\r\n        return v ? Object.assign(proto || {}, v) : v;\r\n    }\r\n    function fromObject(input) {\r\n        var v = {r: 0, g: 0, b: 0, a: 255};\r\n        if (Array.isArray(input)) {\r\n            if (input.length >= 3) {\r\n                v = {r: input[0], g: input[1], b: input[2], a: 255};\r\n                if (input.length > 3) {\r\n                    v.a = n2b(input[3]);\r\n                }\r\n            }\r\n        } else {\r\n            v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});\r\n            v.a = n2b(v.a);\r\n        }\r\n        return v;\r\n    }\r\n    function functionParse(str) {\r\n        if (str.charAt(0) === 'r') {\r\n            return rgbParse(str);\r\n        }\r\n        return hueParse(str);\r\n    }\r\n    class Color {\r\n        constructor(input) {\r\n            if (input instanceof Color) {\r\n                return input;\r\n            }\r\n            const type = typeof input;\r\n            let v;\r\n            if (type === 'object') {\r\n                v = fromObject(input);\r\n            } else if (type === 'string') {\r\n                v = hexParse(input) || nameParse(input) || functionParse(input);\r\n            }\r\n            this._rgb = v;\r\n            this._valid = !!v;\r\n        }\r\n        get valid() {\r\n            return this._valid;\r\n        }\r\n        get rgb() {\r\n            var v = clone$1(this._rgb);\r\n            if (v) {\r\n                v.a = b2n(v.a);\r\n            }\r\n            return v;\r\n        }\r\n        set rgb(obj) {\r\n            this._rgb = fromObject(obj);\r\n        }\r\n        rgbString() {\r\n            return this._valid ? rgbString(this._rgb) : this._rgb;\r\n        }\r\n        hexString() {\r\n            return this._valid ? hexString(this._rgb) : this._rgb;\r\n        }\r\n        hslString() {\r\n            return this._valid ? hslString(this._rgb) : this._rgb;\r\n        }\r\n        mix(color, weight) {\r\n            const me = this;\r\n            if (color) {\r\n                const c1 = me.rgb;\r\n                const c2 = color.rgb;\r\n                let w2;\r\n                const p = weight === w2 ? 0.5 : weight;\r\n                const w = 2 * p - 1;\r\n                const a = c1.a - c2.a;\r\n                const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n                w2 = 1 - w1;\r\n                c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\r\n                c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\r\n                c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\r\n                c1.a = p * c1.a + (1 - p) * c2.a;\r\n                me.rgb = c1;\r\n            }\r\n            return me;\r\n        }\r\n        clone() {\r\n            return new Color(this.rgb);\r\n        }\r\n        alpha(a) {\r\n            this._rgb.a = n2b(a);\r\n            return this;\r\n        }\r\n        clearer(ratio) {\r\n            const rgb = this._rgb;\r\n            rgb.a *= 1 - ratio;\r\n            return this;\r\n        }\r\n        greyscale() {\r\n            const rgb = this._rgb;\r\n            const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\r\n            rgb.r = rgb.g = rgb.b = val;\r\n            return this;\r\n        }\r\n        opaquer(ratio) {\r\n            const rgb = this._rgb;\r\n            rgb.a *= 1 + ratio;\r\n            return this;\r\n        }\r\n        negate() {\r\n            const v = this._rgb;\r\n            v.r = 255 - v.r;\r\n            v.g = 255 - v.g;\r\n            v.b = 255 - v.b;\r\n            return this;\r\n        }\r\n        lighten(ratio) {\r\n            modHSL(this._rgb, 2, ratio);\r\n            return this;\r\n        }\r\n        darken(ratio) {\r\n            modHSL(this._rgb, 2, -ratio);\r\n            return this;\r\n        }\r\n        saturate(ratio) {\r\n            modHSL(this._rgb, 1, ratio);\r\n            return this;\r\n        }\r\n        desaturate(ratio) {\r\n            modHSL(this._rgb, 1, -ratio);\r\n            return this;\r\n        }\r\n        rotate(deg) {\r\n            rotate(this._rgb, deg);\r\n            return this;\r\n        }\r\n    }\r\n    function index_esm(input) {\r\n        return new Color(input);\r\n    }\r\n    \r\n    const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;\r\n    function color(value) {\r\n      return isPatternOrGradient(value) ? value : index_esm(value);\r\n    }\r\n    function getHoverColor(value) {\r\n      return isPatternOrGradient(value)\r\n        ? value\r\n        : index_esm(value).saturate(0.5).darken(0.1).hexString();\r\n    }\r\n    \r\n    function noop() {}\r\n    const uid = (function() {\r\n      let id = 0;\r\n      return function() {\r\n        return id++;\r\n      };\r\n    }());\r\n    function isNullOrUndef(value) {\r\n      return value === null || typeof value === 'undefined';\r\n    }\r\n    function isArray(value) {\r\n      if (Array.isArray && Array.isArray(value)) {\r\n        return true;\r\n      }\r\n      const type = Object.prototype.toString.call(value);\r\n      if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    function isObject(value) {\r\n      return value !== null && Object.prototype.toString.call(value) === '[object Object]';\r\n    }\r\n    const isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\r\n    function finiteOrDefault(value, defaultValue) {\r\n      return isNumberFinite(value) ? value : defaultValue;\r\n    }\r\n    function valueOrDefault(value, defaultValue) {\r\n      return typeof value === 'undefined' ? defaultValue : value;\r\n    }\r\n    const toPercentage = (value, dimension) =>\r\n      typeof value === 'string' && value.endsWith('%') ?\r\n        parseFloat(value) / 100\r\n        : value / dimension;\r\n    const toDimension = (value, dimension) =>\r\n      typeof value === 'string' && value.endsWith('%') ?\r\n        parseFloat(value) / 100 * dimension\r\n        : +value;\r\n    function callback(fn, args, thisArg) {\r\n      if (fn && typeof fn.call === 'function') {\r\n        return fn.apply(thisArg, args);\r\n      }\r\n    }\r\n    function each(loopable, fn, thisArg, reverse) {\r\n      let i, len, keys;\r\n      if (isArray(loopable)) {\r\n        len = loopable.length;\r\n        if (reverse) {\r\n          for (i = len - 1; i >= 0; i--) {\r\n            fn.call(thisArg, loopable[i], i);\r\n          }\r\n        } else {\r\n          for (i = 0; i < len; i++) {\r\n            fn.call(thisArg, loopable[i], i);\r\n          }\r\n        }\r\n      } else if (isObject(loopable)) {\r\n        keys = Object.keys(loopable);\r\n        len = keys.length;\r\n        for (i = 0; i < len; i++) {\r\n          fn.call(thisArg, loopable[keys[i]], keys[i]);\r\n        }\r\n      }\r\n    }\r\n    function _elementsEqual(a0, a1) {\r\n      let i, ilen, v0, v1;\r\n      if (!a0 || !a1 || a0.length !== a1.length) {\r\n        return false;\r\n      }\r\n      for (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n        v0 = a0[i];\r\n        v1 = a1[i];\r\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    function clone(source) {\r\n      if (isArray(source)) {\r\n        return source.map(clone);\r\n      }\r\n      if (isObject(source)) {\r\n        const target = Object.create(null);\r\n        const keys = Object.keys(source);\r\n        const klen = keys.length;\r\n        let k = 0;\r\n        for (; k < klen; ++k) {\r\n          target[keys[k]] = clone(source[keys[k]]);\r\n        }\r\n        return target;\r\n      }\r\n      return source;\r\n    }\r\n    function isValidKey(key) {\r\n      return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\r\n    }\r\n    function _merger(key, target, source, options) {\r\n      if (!isValidKey(key)) {\r\n        return;\r\n      }\r\n      const tval = target[key];\r\n      const sval = source[key];\r\n      if (isObject(tval) && isObject(sval)) {\r\n        merge(tval, sval, options);\r\n      } else {\r\n        target[key] = clone(sval);\r\n      }\r\n    }\r\n    function merge(target, source, options) {\r\n      const sources = isArray(source) ? source : [source];\r\n      const ilen = sources.length;\r\n      if (!isObject(target)) {\r\n        return target;\r\n      }\r\n      options = options || {};\r\n      const merger = options.merger || _merger;\r\n      for (let i = 0; i < ilen; ++i) {\r\n        source = sources[i];\r\n        if (!isObject(source)) {\r\n          continue;\r\n        }\r\n        const keys = Object.keys(source);\r\n        for (let k = 0, klen = keys.length; k < klen; ++k) {\r\n          merger(keys[k], target, source, options);\r\n        }\r\n      }\r\n      return target;\r\n    }\r\n    function mergeIf(target, source) {\r\n      return merge(target, source, {merger: _mergerIf});\r\n    }\r\n    function _mergerIf(key, target, source) {\r\n      if (!isValidKey(key)) {\r\n        return;\r\n      }\r\n      const tval = target[key];\r\n      const sval = source[key];\r\n      if (isObject(tval) && isObject(sval)) {\r\n        mergeIf(tval, sval);\r\n      } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\r\n        target[key] = clone(sval);\r\n      }\r\n    }\r\n    function _deprecated(scope, value, previous, current) {\r\n      if (value !== undefined) {\r\n        console.warn(scope + ': \"' + previous +\r\n                '\" is deprecated. Please use \"' + current + '\" instead');\r\n      }\r\n    }\r\n    const emptyString = '';\r\n    const dot = '.';\r\n    function indexOfDotOrLength(key, start) {\r\n      const idx = key.indexOf(dot, start);\r\n      return idx === -1 ? key.length : idx;\r\n    }\r\n    function resolveObjectKey(obj, key) {\r\n      if (key === emptyString) {\r\n        return obj;\r\n      }\r\n      let pos = 0;\r\n      let idx = indexOfDotOrLength(key, pos);\r\n      while (obj && idx > pos) {\r\n        obj = obj[key.substr(pos, idx - pos)];\r\n        pos = idx + 1;\r\n        idx = indexOfDotOrLength(key, pos);\r\n      }\r\n      return obj;\r\n    }\r\n    function _capitalize(str) {\r\n      return str.charAt(0).toUpperCase() + str.slice(1);\r\n    }\r\n    const defined = (value) => typeof value !== 'undefined';\r\n    const isFunction = (value) => typeof value === 'function';\r\n    const setsEqual = (a, b) => {\r\n      if (a.size !== b.size) {\r\n        return false;\r\n      }\r\n      for (const item of a) {\r\n        if (!b.has(item)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    \r\n    const overrides = Object.create(null);\r\n    const descriptors = Object.create(null);\r\n    function getScope$1(node, key) {\r\n      if (!key) {\r\n        return node;\r\n      }\r\n      const keys = key.split('.');\r\n      for (let i = 0, n = keys.length; i < n; ++i) {\r\n        const k = keys[i];\r\n        node = node[k] || (node[k] = Object.create(null));\r\n      }\r\n      return node;\r\n    }\r\n    function set(root, scope, values) {\r\n      if (typeof scope === 'string') {\r\n        return merge(getScope$1(root, scope), values);\r\n      }\r\n      return merge(getScope$1(root, ''), scope);\r\n    }\r\n    class Defaults {\r\n      constructor(_descriptors) {\r\n        this.animation = undefined;\r\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\r\n        this.borderColor = 'rgba(0,0,0,0.1)';\r\n        this.color = '#666';\r\n        this.datasets = {};\r\n        this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\r\n        this.elements = {};\r\n        this.events = [\r\n          'mousemove',\r\n          'mouseout',\r\n          'click',\r\n          'touchstart',\r\n          'touchmove'\r\n        ];\r\n        this.font = {\r\n          family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n          size: 12,\r\n          style: 'normal',\r\n          lineHeight: 1.2,\r\n          weight: null\r\n        };\r\n        this.hover = {};\r\n        this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\r\n        this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\r\n        this.hoverColor = (ctx, options) => getHoverColor(options.color);\r\n        this.indexAxis = 'x';\r\n        this.interaction = {\r\n          mode: 'nearest',\r\n          intersect: true\r\n        };\r\n        this.maintainAspectRatio = true;\r\n        this.onHover = null;\r\n        this.onClick = null;\r\n        this.parsing = true;\r\n        this.plugins = {};\r\n        this.responsive = true;\r\n        this.scale = undefined;\r\n        this.scales = {};\r\n        this.showLine = true;\r\n        this.describe(_descriptors);\r\n      }\r\n      set(scope, values) {\r\n        return set(this, scope, values);\r\n      }\r\n      get(scope) {\r\n        return getScope$1(this, scope);\r\n      }\r\n      describe(scope, values) {\r\n        return set(descriptors, scope, values);\r\n      }\r\n      override(scope, values) {\r\n        return set(overrides, scope, values);\r\n      }\r\n      route(scope, name, targetScope, targetName) {\r\n        const scopeObject = getScope$1(this, scope);\r\n        const targetScopeObject = getScope$1(this, targetScope);\r\n        const privateName = '_' + name;\r\n        Object.defineProperties(scopeObject, {\r\n          [privateName]: {\r\n            value: scopeObject[name],\r\n            writable: true\r\n          },\r\n          [name]: {\r\n            enumerable: true,\r\n            get() {\r\n              const local = this[privateName];\r\n              const target = targetScopeObject[targetName];\r\n              if (isObject(local)) {\r\n                return Object.assign({}, target, local);\r\n              }\r\n              return valueOrDefault(local, target);\r\n            },\r\n            set(value) {\r\n              this[privateName] = value;\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    var defaults = new Defaults({\r\n      _scriptable: (name) => !name.startsWith('on'),\r\n      _indexable: (name) => name !== 'events',\r\n      hover: {\r\n        _fallback: 'interaction'\r\n      },\r\n      interaction: {\r\n        _scriptable: false,\r\n        _indexable: false,\r\n      }\r\n    });\r\n    \r\n    const PI = Math.PI;\r\n    const TAU = 2 * PI;\r\n    const PITAU = TAU + PI;\r\n    const INFINITY = Number.POSITIVE_INFINITY;\r\n    const RAD_PER_DEG = PI / 180;\r\n    const HALF_PI = PI / 2;\r\n    const QUARTER_PI = PI / 4;\r\n    const TWO_THIRDS_PI = PI * 2 / 3;\r\n    const log10 = Math.log10;\r\n    const sign = Math.sign;\r\n    function niceNum(range) {\r\n      const niceRange = Math.pow(10, Math.floor(log10(range)));\r\n      const fraction = range / niceRange;\r\n      const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\r\n      return niceFraction * niceRange;\r\n    }\r\n    function _factorize(value) {\r\n      const result = [];\r\n      const sqrt = Math.sqrt(value);\r\n      let i;\r\n      for (i = 1; i < sqrt; i++) {\r\n        if (value % i === 0) {\r\n          result.push(i);\r\n          result.push(value / i);\r\n        }\r\n      }\r\n      if (sqrt === (sqrt | 0)) {\r\n        result.push(sqrt);\r\n      }\r\n      result.sort((a, b) => a - b).pop();\r\n      return result;\r\n    }\r\n    function isNumber(n) {\r\n      return !isNaN(parseFloat(n)) && isFinite(n);\r\n    }\r\n    function almostEquals(x, y, epsilon) {\r\n      return Math.abs(x - y) < epsilon;\r\n    }\r\n    function almostWhole(x, epsilon) {\r\n      const rounded = Math.round(x);\r\n      return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\r\n    }\r\n    function _setMinAndMaxByKey(array, target, property) {\r\n      let i, ilen, value;\r\n      for (i = 0, ilen = array.length; i < ilen; i++) {\r\n        value = array[i][property];\r\n        if (!isNaN(value)) {\r\n          target.min = Math.min(target.min, value);\r\n          target.max = Math.max(target.max, value);\r\n        }\r\n      }\r\n    }\r\n    function toRadians(degrees) {\r\n      return degrees * (PI / 180);\r\n    }\r\n    function toDegrees(radians) {\r\n      return radians * (180 / PI);\r\n    }\r\n    function _decimalPlaces(x) {\r\n      if (!isNumberFinite(x)) {\r\n        return;\r\n      }\r\n      let e = 1;\r\n      let p = 0;\r\n      while (Math.round(x * e) / e !== x) {\r\n        e *= 10;\r\n        p++;\r\n      }\r\n      return p;\r\n    }\r\n    function getAngleFromPoint(centrePoint, anglePoint) {\r\n      const distanceFromXCenter = anglePoint.x - centrePoint.x;\r\n      const distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n      const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\r\n      let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\r\n      if (angle < (-0.5 * PI)) {\r\n        angle += TAU;\r\n      }\r\n      return {\r\n        angle,\r\n        distance: radialDistanceFromCenter\r\n      };\r\n    }\r\n    function distanceBetweenPoints(pt1, pt2) {\r\n      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\r\n    }\r\n    function _angleDiff(a, b) {\r\n      return (a - b + PITAU) % TAU - PI;\r\n    }\r\n    function _normalizeAngle(a) {\r\n      return (a % TAU + TAU) % TAU;\r\n    }\r\n    function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\r\n      const a = _normalizeAngle(angle);\r\n      const s = _normalizeAngle(start);\r\n      const e = _normalizeAngle(end);\r\n      const angleToStart = _normalizeAngle(s - a);\r\n      const angleToEnd = _normalizeAngle(e - a);\r\n      const startToAngle = _normalizeAngle(a - s);\r\n      const endToAngle = _normalizeAngle(a - e);\r\n      return a === s || a === e || (sameAngleIsFullCircle && s === e)\r\n        || (angleToStart > angleToEnd && startToAngle < endToAngle);\r\n    }\r\n    function _limitValue(value, min, max) {\r\n      return Math.max(min, Math.min(max, value));\r\n    }\r\n    function _int16Range(value) {\r\n      return _limitValue(value, -32768, 32767);\r\n    }\r\n    \r\n    function toFontString(font) {\r\n      if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\r\n        return null;\r\n      }\r\n      return (font.style ? font.style + ' ' : '')\r\n            + (font.weight ? font.weight + ' ' : '')\r\n            + font.size + 'px '\r\n            + font.family;\r\n    }\r\n    function _measureText(ctx, data, gc, longest, string) {\r\n      let textWidth = data[string];\r\n      if (!textWidth) {\r\n        textWidth = data[string] = ctx.measureText(string).width;\r\n        gc.push(string);\r\n      }\r\n      if (textWidth > longest) {\r\n        longest = textWidth;\r\n      }\r\n      return longest;\r\n    }\r\n    function _longestText(ctx, font, arrayOfThings, cache) {\r\n      cache = cache || {};\r\n      let data = cache.data = cache.data || {};\r\n      let gc = cache.garbageCollect = cache.garbageCollect || [];\r\n      if (cache.font !== font) {\r\n        data = cache.data = {};\r\n        gc = cache.garbageCollect = [];\r\n        cache.font = font;\r\n      }\r\n      ctx.save();\r\n      ctx.font = font;\r\n      let longest = 0;\r\n      const ilen = arrayOfThings.length;\r\n      let i, j, jlen, thing, nestedThing;\r\n      for (i = 0; i < ilen; i++) {\r\n        thing = arrayOfThings[i];\r\n        if (thing !== undefined && thing !== null && isArray(thing) !== true) {\r\n          longest = _measureText(ctx, data, gc, longest, thing);\r\n        } else if (isArray(thing)) {\r\n          for (j = 0, jlen = thing.length; j < jlen; j++) {\r\n            nestedThing = thing[j];\r\n            if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\r\n              longest = _measureText(ctx, data, gc, longest, nestedThing);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      ctx.restore();\r\n      const gcLen = gc.length / 2;\r\n      if (gcLen > arrayOfThings.length) {\r\n        for (i = 0; i < gcLen; i++) {\r\n          delete data[gc[i]];\r\n        }\r\n        gc.splice(0, gcLen);\r\n      }\r\n      return longest;\r\n    }\r\n    function _alignPixel(chart, pixel, width) {\r\n      const devicePixelRatio = chart.currentDevicePixelRatio;\r\n      const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\r\n      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\r\n    }\r\n    function clearCanvas(canvas, ctx) {\r\n      ctx = ctx || canvas.getContext('2d');\r\n      ctx.save();\r\n      ctx.resetTransform();\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n      ctx.restore();\r\n    }\r\n    function drawPoint(ctx, options, x, y) {\r\n      let type, xOffset, yOffset, size, cornerRadius;\r\n      const style = options.pointStyle;\r\n      const rotation = options.rotation;\r\n      const radius = options.radius;\r\n      let rad = (rotation || 0) * RAD_PER_DEG;\r\n      if (style && typeof style === 'object') {\r\n        type = style.toString();\r\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n          ctx.save();\r\n          ctx.translate(x, y);\r\n          ctx.rotate(rad);\r\n          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n          ctx.restore();\r\n          return;\r\n        }\r\n      }\r\n      if (isNaN(radius) || radius <= 0) {\r\n        return;\r\n      }\r\n      ctx.beginPath();\r\n      switch (style) {\r\n      default:\r\n        ctx.arc(x, y, radius, 0, TAU);\r\n        ctx.closePath();\r\n        break;\r\n      case 'triangle':\r\n        ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n        rad += TWO_THIRDS_PI;\r\n        ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n        rad += TWO_THIRDS_PI;\r\n        ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n        ctx.closePath();\r\n        break;\r\n      case 'rectRounded':\r\n        cornerRadius = radius * 0.516;\r\n        size = radius - cornerRadius;\r\n        xOffset = Math.cos(rad + QUARTER_PI) * size;\r\n        yOffset = Math.sin(rad + QUARTER_PI) * size;\r\n        ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n        ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n        ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n        ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n        ctx.closePath();\r\n        break;\r\n      case 'rect':\r\n        if (!rotation) {\r\n          size = Math.SQRT1_2 * radius;\r\n          ctx.rect(x - size, y - size, 2 * size, 2 * size);\r\n          break;\r\n        }\r\n        rad += QUARTER_PI;\r\n      case 'rectRot':\r\n        xOffset = Math.cos(rad) * radius;\r\n        yOffset = Math.sin(rad) * radius;\r\n        ctx.moveTo(x - xOffset, y - yOffset);\r\n        ctx.lineTo(x + yOffset, y - xOffset);\r\n        ctx.lineTo(x + xOffset, y + yOffset);\r\n        ctx.lineTo(x - yOffset, y + xOffset);\r\n        ctx.closePath();\r\n        break;\r\n      case 'crossRot':\r\n        rad += QUARTER_PI;\r\n      case 'cross':\r\n        xOffset = Math.cos(rad) * radius;\r\n        yOffset = Math.sin(rad) * radius;\r\n        ctx.moveTo(x - xOffset, y - yOffset);\r\n        ctx.lineTo(x + xOffset, y + yOffset);\r\n        ctx.moveTo(x + yOffset, y - xOffset);\r\n        ctx.lineTo(x - yOffset, y + xOffset);\r\n        break;\r\n      case 'star':\r\n        xOffset = Math.cos(rad) * radius;\r\n        yOffset = Math.sin(rad) * radius;\r\n        ctx.moveTo(x - xOffset, y - yOffset);\r\n        ctx.lineTo(x + xOffset, y + yOffset);\r\n        ctx.moveTo(x + yOffset, y - xOffset);\r\n        ctx.lineTo(x - yOffset, y + xOffset);\r\n        rad += QUARTER_PI;\r\n        xOffset = Math.cos(rad) * radius;\r\n        yOffset = Math.sin(rad) * radius;\r\n        ctx.moveTo(x - xOffset, y - yOffset);\r\n        ctx.lineTo(x + xOffset, y + yOffset);\r\n        ctx.moveTo(x + yOffset, y - xOffset);\r\n        ctx.lineTo(x - yOffset, y + xOffset);\r\n        break;\r\n      case 'line':\r\n        xOffset = Math.cos(rad) * radius;\r\n        yOffset = Math.sin(rad) * radius;\r\n        ctx.moveTo(x - xOffset, y - yOffset);\r\n        ctx.lineTo(x + xOffset, y + yOffset);\r\n        break;\r\n      case 'dash':\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\r\n        break;\r\n      }\r\n      ctx.fill();\r\n      if (options.borderWidth > 0) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n    function _isPointInArea(point, area, margin) {\r\n      margin = margin || 0.5;\r\n      return point && point.x > area.left - margin && point.x < area.right + margin &&\r\n            point.y > area.top - margin && point.y < area.bottom + margin;\r\n    }\r\n    function clipArea(ctx, area) {\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\r\n      ctx.clip();\r\n    }\r\n    function unclipArea(ctx) {\r\n      ctx.restore();\r\n    }\r\n    function _steppedLineTo(ctx, previous, target, flip, mode) {\r\n      if (!previous) {\r\n        return ctx.lineTo(target.x, target.y);\r\n      }\r\n      if (mode === 'middle') {\r\n        const midpoint = (previous.x + target.x) / 2.0;\r\n        ctx.lineTo(midpoint, previous.y);\r\n        ctx.lineTo(midpoint, target.y);\r\n      } else if (mode === 'after' !== !!flip) {\r\n        ctx.lineTo(previous.x, target.y);\r\n      } else {\r\n        ctx.lineTo(target.x, previous.y);\r\n      }\r\n      ctx.lineTo(target.x, target.y);\r\n    }\r\n    function _bezierCurveTo(ctx, previous, target, flip) {\r\n      if (!previous) {\r\n        return ctx.lineTo(target.x, target.y);\r\n      }\r\n      ctx.bezierCurveTo(\r\n        flip ? previous.cp1x : previous.cp2x,\r\n        flip ? previous.cp1y : previous.cp2y,\r\n        flip ? target.cp2x : target.cp1x,\r\n        flip ? target.cp2y : target.cp1y,\r\n        target.x,\r\n        target.y);\r\n    }\r\n    function renderText(ctx, text, x, y, font, opts = {}) {\r\n      const lines = isArray(text) ? text : [text];\r\n      const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\r\n      let i, line;\r\n      ctx.save();\r\n      if (opts.translation) {\r\n        ctx.translate(opts.translation[0], opts.translation[1]);\r\n      }\r\n      if (!isNullOrUndef(opts.rotation)) {\r\n        ctx.rotate(opts.rotation);\r\n      }\r\n      ctx.font = font.string;\r\n      if (opts.color) {\r\n        ctx.fillStyle = opts.color;\r\n      }\r\n      if (opts.textAlign) {\r\n        ctx.textAlign = opts.textAlign;\r\n      }\r\n      if (opts.textBaseline) {\r\n        ctx.textBaseline = opts.textBaseline;\r\n      }\r\n      for (i = 0; i < lines.length; ++i) {\r\n        line = lines[i];\r\n        if (stroke) {\r\n          if (opts.strokeColor) {\r\n            ctx.strokeStyle = opts.strokeColor;\r\n          }\r\n          if (!isNullOrUndef(opts.strokeWidth)) {\r\n            ctx.lineWidth = opts.strokeWidth;\r\n          }\r\n          ctx.strokeText(line, x, y, opts.maxWidth);\r\n        }\r\n        ctx.fillText(line, x, y, opts.maxWidth);\r\n        if (opts.strikethrough || opts.underline) {\r\n          const metrics = ctx.measureText(line);\r\n          const left = x - metrics.actualBoundingBoxLeft;\r\n          const right = x + metrics.actualBoundingBoxRight;\r\n          const top = y - metrics.actualBoundingBoxAscent;\r\n          const bottom = y + metrics.actualBoundingBoxDescent;\r\n          const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\r\n          ctx.strokeStyle = ctx.fillStyle;\r\n          ctx.beginPath();\r\n          ctx.lineWidth = opts.decorationWidth || 2;\r\n          ctx.moveTo(left, yDecoration);\r\n          ctx.lineTo(right, yDecoration);\r\n          ctx.stroke();\r\n        }\r\n        y += font.lineHeight;\r\n      }\r\n      ctx.restore();\r\n    }\r\n    function addRoundedRectPath(ctx, rect) {\r\n      const {x, y, w, h, radius} = rect;\r\n      ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\r\n      ctx.lineTo(x, y + h - radius.bottomLeft);\r\n      ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\r\n      ctx.lineTo(x + w - radius.bottomRight, y + h);\r\n      ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\r\n      ctx.lineTo(x + w, y + radius.topRight);\r\n      ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\r\n      ctx.lineTo(x + radius.topLeft, y);\r\n    }\r\n    \r\n    function _lookup(table, value, cmp) {\r\n      cmp = cmp || ((index) => table[index] < value);\r\n      let hi = table.length - 1;\r\n      let lo = 0;\r\n      let mid;\r\n      while (hi - lo > 1) {\r\n        mid = (lo + hi) >> 1;\r\n        if (cmp(mid)) {\r\n          lo = mid;\r\n        } else {\r\n          hi = mid;\r\n        }\r\n      }\r\n      return {lo, hi};\r\n    }\r\n    const _lookupByKey = (table, key, value) =>\r\n      _lookup(table, value, index => table[index][key] < value);\r\n    const _rlookupByKey = (table, key, value) =>\r\n      _lookup(table, value, index => table[index][key] >= value);\r\n    function _filterBetween(values, min, max) {\r\n      let start = 0;\r\n      let end = values.length;\r\n      while (start < end && values[start] < min) {\r\n        start++;\r\n      }\r\n      while (end > start && values[end - 1] > max) {\r\n        end--;\r\n      }\r\n      return start > 0 || end < values.length\r\n        ? values.slice(start, end)\r\n        : values;\r\n    }\r\n    const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\r\n    function listenArrayEvents(array, listener) {\r\n      if (array._chartjs) {\r\n        array._chartjs.listeners.push(listener);\r\n        return;\r\n      }\r\n      Object.defineProperty(array, '_chartjs', {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value: {\r\n          listeners: [listener]\r\n        }\r\n      });\r\n      arrayEvents.forEach((key) => {\r\n        const method = '_onData' + _capitalize(key);\r\n        const base = array[key];\r\n        Object.defineProperty(array, key, {\r\n          configurable: true,\r\n          enumerable: false,\r\n          value(...args) {\r\n            const res = base.apply(this, args);\r\n            array._chartjs.listeners.forEach((object) => {\r\n              if (typeof object[method] === 'function') {\r\n                object[method](...args);\r\n              }\r\n            });\r\n            return res;\r\n          }\r\n        });\r\n      });\r\n    }\r\n    function unlistenArrayEvents(array, listener) {\r\n      const stub = array._chartjs;\r\n      if (!stub) {\r\n        return;\r\n      }\r\n      const listeners = stub.listeners;\r\n      const index = listeners.indexOf(listener);\r\n      if (index !== -1) {\r\n        listeners.splice(index, 1);\r\n      }\r\n      if (listeners.length > 0) {\r\n        return;\r\n      }\r\n      arrayEvents.forEach((key) => {\r\n        delete array[key];\r\n      });\r\n      delete array._chartjs;\r\n    }\r\n    function _arrayUnique(items) {\r\n      const set = new Set();\r\n      let i, ilen;\r\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n        set.add(items[i]);\r\n      }\r\n      if (set.size === ilen) {\r\n        return items;\r\n      }\r\n      const result = [];\r\n      set.forEach(item => {\r\n        result.push(item);\r\n      });\r\n      return result;\r\n    }\r\n    \r\n    function _getParentNode(domNode) {\r\n      let parent = domNode.parentNode;\r\n      if (parent && parent.toString() === '[object ShadowRoot]') {\r\n        parent = parent.host;\r\n      }\r\n      return parent;\r\n    }\r\n    function parseMaxStyle(styleValue, node, parentProperty) {\r\n      let valueInPixels;\r\n      if (typeof styleValue === 'string') {\r\n        valueInPixels = parseInt(styleValue, 10);\r\n        if (styleValue.indexOf('%') !== -1) {\r\n          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\r\n        }\r\n      } else {\r\n        valueInPixels = styleValue;\r\n      }\r\n      return valueInPixels;\r\n    }\r\n    const getComputedStyle = (element) => window.getComputedStyle(element, null);\r\n    function getStyle(el, property) {\r\n      return getComputedStyle(el).getPropertyValue(property);\r\n    }\r\n    const positions = ['top', 'right', 'bottom', 'left'];\r\n    function getPositionedStyle(styles, style, suffix) {\r\n      const result = {};\r\n      suffix = suffix ? '-' + suffix : '';\r\n      for (let i = 0; i < 4; i++) {\r\n        const pos = positions[i];\r\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\r\n      }\r\n      result.width = result.left + result.right;\r\n      result.height = result.top + result.bottom;\r\n      return result;\r\n    }\r\n    const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\r\n    function getCanvasPosition(evt, canvas) {\r\n      const e = evt.native || evt;\r\n      const touches = e.touches;\r\n      const source = touches && touches.length ? touches[0] : e;\r\n      const {offsetX, offsetY} = source;\r\n      let box = false;\r\n      let x, y;\r\n      if (useOffsetPos(offsetX, offsetY, e.target)) {\r\n        x = offsetX;\r\n        y = offsetY;\r\n      } else {\r\n        const rect = canvas.getBoundingClientRect();\r\n        x = source.clientX - rect.left;\r\n        y = source.clientY - rect.top;\r\n        box = true;\r\n      }\r\n      return {x, y, box};\r\n    }\r\n    function getRelativePosition$1(evt, chart) {\r\n      const {canvas, currentDevicePixelRatio} = chart;\r\n      const style = getComputedStyle(canvas);\r\n      const borderBox = style.boxSizing === 'border-box';\r\n      const paddings = getPositionedStyle(style, 'padding');\r\n      const borders = getPositionedStyle(style, 'border', 'width');\r\n      const {x, y, box} = getCanvasPosition(evt, canvas);\r\n      const xOffset = paddings.left + (box && borders.left);\r\n      const yOffset = paddings.top + (box && borders.top);\r\n      let {width, height} = chart;\r\n      if (borderBox) {\r\n        width -= paddings.width + borders.width;\r\n        height -= paddings.height + borders.height;\r\n      }\r\n      return {\r\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\r\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\r\n      };\r\n    }\r\n    function getContainerSize(canvas, width, height) {\r\n      let maxWidth, maxHeight;\r\n      if (width === undefined || height === undefined) {\r\n        const container = _getParentNode(canvas);\r\n        if (!container) {\r\n          width = canvas.clientWidth;\r\n          height = canvas.clientHeight;\r\n        } else {\r\n          const rect = container.getBoundingClientRect();\r\n          const containerStyle = getComputedStyle(container);\r\n          const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\r\n          const containerPadding = getPositionedStyle(containerStyle, 'padding');\r\n          width = rect.width - containerPadding.width - containerBorder.width;\r\n          height = rect.height - containerPadding.height - containerBorder.height;\r\n          maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\r\n          maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\r\n        }\r\n      }\r\n      return {\r\n        width,\r\n        height,\r\n        maxWidth: maxWidth || INFINITY,\r\n        maxHeight: maxHeight || INFINITY\r\n      };\r\n    }\r\n    const round1 = v => Math.round(v * 10) / 10;\r\n    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\r\n      const style = getComputedStyle(canvas);\r\n      const margins = getPositionedStyle(style, 'margin');\r\n      const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\r\n      const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\r\n      const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\r\n      let {width, height} = containerSize;\r\n      if (style.boxSizing === 'content-box') {\r\n        const borders = getPositionedStyle(style, 'border', 'width');\r\n        const paddings = getPositionedStyle(style, 'padding');\r\n        width -= paddings.width + borders.width;\r\n        height -= paddings.height + borders.height;\r\n      }\r\n      width = Math.max(0, width - margins.width);\r\n      height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\r\n      width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\r\n      height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\r\n      if (width && !height) {\r\n        height = round1(width / 2);\r\n      }\r\n      return {\r\n        width,\r\n        height\r\n      };\r\n    }\r\n    function retinaScale(chart, forceRatio, forceStyle) {\r\n      const pixelRatio = forceRatio || 1;\r\n      const deviceHeight = Math.floor(chart.height * pixelRatio);\r\n      const deviceWidth = Math.floor(chart.width * pixelRatio);\r\n      chart.height = deviceHeight / pixelRatio;\r\n      chart.width = deviceWidth / pixelRatio;\r\n      const canvas = chart.canvas;\r\n      if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\r\n        canvas.style.height = `${chart.height}px`;\r\n        canvas.style.width = `${chart.width}px`;\r\n      }\r\n      if (chart.currentDevicePixelRatio !== pixelRatio\r\n          || canvas.height !== deviceHeight\r\n          || canvas.width !== deviceWidth) {\r\n        chart.currentDevicePixelRatio = pixelRatio;\r\n        canvas.height = deviceHeight;\r\n        canvas.width = deviceWidth;\r\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    const supportsEventListenerOptions = (function() {\r\n      let passiveSupported = false;\r\n      try {\r\n        const options = {\r\n          get passive() {\r\n            passiveSupported = true;\r\n            return false;\r\n          }\r\n        };\r\n        window.addEventListener('test', null, options);\r\n        window.removeEventListener('test', null, options);\r\n      } catch (e) {\r\n      }\r\n      return passiveSupported;\r\n    }());\r\n    function readUsedSize(element, property) {\r\n      const value = getStyle(element, property);\r\n      const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n      return matches ? +matches[1] : undefined;\r\n    }\r\n    \r\n    function getRelativePosition(e, chart) {\r\n      if ('native' in e) {\r\n        return {\r\n          x: e.x,\r\n          y: e.y\r\n        };\r\n      }\r\n      return getRelativePosition$1(e, chart);\r\n    }\r\n    function evaluateAllVisibleItems(chart, handler) {\r\n      const metasets = chart.getSortedVisibleDatasetMetas();\r\n      let index, data, element;\r\n      for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n        ({index, data} = metasets[i]);\r\n        for (let j = 0, jlen = data.length; j < jlen; ++j) {\r\n          element = data[j];\r\n          if (!element.skip) {\r\n            handler(element, index, j);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    function binarySearch(metaset, axis, value, intersect) {\r\n      const {controller, data, _sorted} = metaset;\r\n      const iScale = controller._cachedMeta.iScale;\r\n      if (iScale && axis === iScale.axis && _sorted && data.length) {\r\n        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\r\n        if (!intersect) {\r\n          return lookupMethod(data, axis, value);\r\n        } else if (controller._sharedOptions) {\r\n          const el = data[0];\r\n          const range = typeof el.getRange === 'function' && el.getRange(axis);\r\n          if (range) {\r\n            const start = lookupMethod(data, axis, value - range);\r\n            const end = lookupMethod(data, axis, value + range);\r\n            return {lo: start.lo, hi: end.hi};\r\n          }\r\n        }\r\n      }\r\n      return {lo: 0, hi: data.length - 1};\r\n    }\r\n    function optimizedEvaluateItems(chart, axis, position, handler, intersect) {\r\n      const metasets = chart.getSortedVisibleDatasetMetas();\r\n      const value = position[axis];\r\n      for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n        const {index, data} = metasets[i];\r\n        const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\r\n        for (let j = lo; j <= hi; ++j) {\r\n          const element = data[j];\r\n          if (!element.skip) {\r\n            handler(element, index, j);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    function getDistanceMetricForAxis(axis) {\r\n      const useX = axis.indexOf('x') !== -1;\r\n      const useY = axis.indexOf('y') !== -1;\r\n      return function(pt1, pt2) {\r\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n      };\r\n    }\r\n    function getIntersectItems(chart, position, axis, useFinalPosition) {\r\n      const items = [];\r\n      if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\r\n        return items;\r\n      }\r\n      const evaluationFunc = function(element, datasetIndex, index) {\r\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n          items.push({element, datasetIndex, index});\r\n        }\r\n      };\r\n      optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\r\n      return items;\r\n    }\r\n    function getNearestItems(chart, position, axis, intersect, useFinalPosition) {\r\n      const distanceMetric = getDistanceMetricForAxis(axis);\r\n      let minDistance = Number.POSITIVE_INFINITY;\r\n      let items = [];\r\n      if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {\r\n        return items;\r\n      }\r\n      const evaluationFunc = function(element, datasetIndex, index) {\r\n        if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {\r\n          return;\r\n        }\r\n        const center = element.getCenterPoint(useFinalPosition);\r\n        const distance = distanceMetric(position, center);\r\n        if (distance < minDistance) {\r\n          items = [{element, datasetIndex, index}];\r\n          minDistance = distance;\r\n        } else if (distance === minDistance) {\r\n          items.push({element, datasetIndex, index});\r\n        }\r\n      };\r\n      optimizedEvaluateItems(chart, axis, position, evaluationFunc);\r\n      return items;\r\n    }\r\n    function getAxisItems(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const items = [];\r\n      const axis = options.axis;\r\n      const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\r\n      let intersectsItem = false;\r\n      evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\r\n        if (element[rangeMethod](position[axis], useFinalPosition)) {\r\n          items.push({element, datasetIndex, index});\r\n        }\r\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n          intersectsItem = true;\r\n        }\r\n      });\r\n      if (options.intersect && !intersectsItem) {\r\n        return [];\r\n      }\r\n      return items;\r\n    }\r\n    var Interaction = {\r\n      modes: {\r\n        index(chart, e, options, useFinalPosition) {\r\n          const position = getRelativePosition(e, chart);\r\n          const axis = options.axis || 'x';\r\n          const items = options.intersect\r\n            ? getIntersectItems(chart, position, axis, useFinalPosition)\r\n            : getNearestItems(chart, position, axis, false, useFinalPosition);\r\n          const elements = [];\r\n          if (!items.length) {\r\n            return [];\r\n          }\r\n          chart.getSortedVisibleDatasetMetas().forEach((meta) => {\r\n            const index = items[0].index;\r\n            const element = meta.data[index];\r\n            if (element && !element.skip) {\r\n              elements.push({element, datasetIndex: meta.index, index});\r\n            }\r\n          });\r\n          return elements;\r\n        },\r\n        dataset(chart, e, options, useFinalPosition) {\r\n          const position = getRelativePosition(e, chart);\r\n          const axis = options.axis || 'xy';\r\n          let items = options.intersect\r\n            ? getIntersectItems(chart, position, axis, useFinalPosition) :\r\n            getNearestItems(chart, position, axis, false, useFinalPosition);\r\n          if (items.length > 0) {\r\n            const datasetIndex = items[0].datasetIndex;\r\n            const data = chart.getDatasetMeta(datasetIndex).data;\r\n            items = [];\r\n            for (let i = 0; i < data.length; ++i) {\r\n              items.push({element: data[i], datasetIndex, index: i});\r\n            }\r\n          }\r\n          return items;\r\n        },\r\n        point(chart, e, options, useFinalPosition) {\r\n          const position = getRelativePosition(e, chart);\r\n          const axis = options.axis || 'xy';\r\n          return getIntersectItems(chart, position, axis, useFinalPosition);\r\n        },\r\n        nearest(chart, e, options, useFinalPosition) {\r\n          const position = getRelativePosition(e, chart);\r\n          const axis = options.axis || 'xy';\r\n          return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\r\n        },\r\n        x(chart, e, options, useFinalPosition) {\r\n          options.axis = 'x';\r\n          return getAxisItems(chart, e, options, useFinalPosition);\r\n        },\r\n        y(chart, e, options, useFinalPosition) {\r\n          options.axis = 'y';\r\n          return getAxisItems(chart, e, options, useFinalPosition);\r\n        }\r\n      }\r\n    };\r\n    \r\n    const LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\r\n    const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\r\n    function toLineHeight(value, size) {\r\n      const matches = ('' + value).match(LINE_HEIGHT);\r\n      if (!matches || matches[1] === 'normal') {\r\n        return size * 1.2;\r\n      }\r\n      value = +matches[2];\r\n      switch (matches[3]) {\r\n      case 'px':\r\n        return value;\r\n      case '%':\r\n        value /= 100;\r\n        break;\r\n      }\r\n      return size * value;\r\n    }\r\n    const numberOrZero$1 = v => +v || 0;\r\n    function _readValueToProps(value, props) {\r\n      const ret = {};\r\n      const objProps = isObject(props);\r\n      const keys = objProps ? Object.keys(props) : props;\r\n      const read = isObject(value)\r\n        ? objProps\r\n          ? prop => valueOrDefault(value[prop], value[props[prop]])\r\n          : prop => value[prop]\r\n        : () => value;\r\n      for (const prop of keys) {\r\n        ret[prop] = numberOrZero$1(read(prop));\r\n      }\r\n      return ret;\r\n    }\r\n    function toTRBL(value) {\r\n      return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\r\n    }\r\n    function toTRBLCorners(value) {\r\n      return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\r\n    }\r\n    function toPadding(value) {\r\n      const obj = toTRBL(value);\r\n      obj.width = obj.left + obj.right;\r\n      obj.height = obj.top + obj.bottom;\r\n      return obj;\r\n    }\r\n    function toFont(options, fallback) {\r\n      options = options || {};\r\n      fallback = fallback || defaults.font;\r\n      let size = valueOrDefault(options.size, fallback.size);\r\n      if (typeof size === 'string') {\r\n        size = parseInt(size, 10);\r\n      }\r\n      let style = valueOrDefault(options.style, fallback.style);\r\n      if (style && !('' + style).match(FONT_STYLE)) {\r\n        console.warn('Invalid font style specified: \"' + style + '\"');\r\n        style = '';\r\n      }\r\n      const font = {\r\n        family: valueOrDefault(options.family, fallback.family),\r\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\r\n        size,\r\n        style,\r\n        weight: valueOrDefault(options.weight, fallback.weight),\r\n        string: ''\r\n      };\r\n      font.string = toFontString(font);\r\n      return font;\r\n    }\r\n    function resolve(inputs, context, index, info) {\r\n      let cacheable = true;\r\n      let i, ilen, value;\r\n      for (i = 0, ilen = inputs.length; i < ilen; ++i) {\r\n        value = inputs[i];\r\n        if (value === undefined) {\r\n          continue;\r\n        }\r\n        if (context !== undefined && typeof value === 'function') {\r\n          value = value(context);\r\n          cacheable = false;\r\n        }\r\n        if (index !== undefined && isArray(value)) {\r\n          value = value[index % value.length];\r\n          cacheable = false;\r\n        }\r\n        if (value !== undefined) {\r\n          if (info && !cacheable) {\r\n            info.cacheable = false;\r\n          }\r\n          return value;\r\n        }\r\n      }\r\n    }\r\n    function _addGrace(minmax, grace) {\r\n      const {min, max} = minmax;\r\n      return {\r\n        min: min - Math.abs(toDimension(grace, min)),\r\n        max: max + toDimension(grace, max)\r\n      };\r\n    }\r\n    \r\n    const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\r\n    function filterByPosition(array, position) {\r\n      return array.filter(v => v.pos === position);\r\n    }\r\n    function filterDynamicPositionByAxis(array, axis) {\r\n      return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\r\n    }\r\n    function sortByWeight(array, reverse) {\r\n      return array.sort((a, b) => {\r\n        const v0 = reverse ? b : a;\r\n        const v1 = reverse ? a : b;\r\n        return v0.weight === v1.weight ?\r\n          v0.index - v1.index :\r\n          v0.weight - v1.weight;\r\n      });\r\n    }\r\n    function wrapBoxes(boxes) {\r\n      const layoutBoxes = [];\r\n      let i, ilen, box;\r\n      for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n        box = boxes[i];\r\n        layoutBoxes.push({\r\n          index: i,\r\n          box,\r\n          pos: box.position,\r\n          horizontal: box.isHorizontal(),\r\n          weight: box.weight\r\n        });\r\n      }\r\n      return layoutBoxes;\r\n    }\r\n    function setLayoutDims(layouts, params) {\r\n      let i, ilen, layout;\r\n      for (i = 0, ilen = layouts.length; i < ilen; ++i) {\r\n        layout = layouts[i];\r\n        if (layout.horizontal) {\r\n          layout.width = layout.box.fullSize && params.availableWidth;\r\n          layout.height = params.hBoxMaxHeight;\r\n        } else {\r\n          layout.width = params.vBoxMaxWidth;\r\n          layout.height = layout.box.fullSize && params.availableHeight;\r\n        }\r\n      }\r\n    }\r\n    function buildLayoutBoxes(boxes) {\r\n      const layoutBoxes = wrapBoxes(boxes);\r\n      const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\r\n      const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\r\n      const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n      const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n      const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n      const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\r\n      const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\r\n      return {\r\n        fullSize,\r\n        leftAndTop: left.concat(top),\r\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\r\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\r\n        vertical: left.concat(right).concat(centerVertical),\r\n        horizontal: top.concat(bottom).concat(centerHorizontal)\r\n      };\r\n    }\r\n    function getCombinedMax(maxPadding, chartArea, a, b) {\r\n      return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\r\n    }\r\n    function updateMaxPadding(maxPadding, boxPadding) {\r\n      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\r\n      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\r\n      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\r\n    }\r\n    function updateDims(chartArea, params, layout) {\r\n      const box = layout.box;\r\n      const maxPadding = chartArea.maxPadding;\r\n      if (!isObject(layout.pos)) {\r\n        if (layout.size) {\r\n          chartArea[layout.pos] -= layout.size;\r\n        }\r\n        layout.size = layout.horizontal ? box.height : box.width;\r\n        chartArea[layout.pos] += layout.size;\r\n      }\r\n      if (box.getPadding) {\r\n        updateMaxPadding(maxPadding, box.getPadding());\r\n      }\r\n      const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\r\n      const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\r\n      const widthChanged = newWidth !== chartArea.w;\r\n      const heightChanged = newHeight !== chartArea.h;\r\n      chartArea.w = newWidth;\r\n      chartArea.h = newHeight;\r\n      return layout.horizontal\r\n        ? {same: widthChanged, other: heightChanged}\r\n        : {same: heightChanged, other: widthChanged};\r\n    }\r\n    function handleMaxPadding(chartArea) {\r\n      const maxPadding = chartArea.maxPadding;\r\n      function updatePos(pos) {\r\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\r\n        chartArea[pos] += change;\r\n        return change;\r\n      }\r\n      chartArea.y += updatePos('top');\r\n      chartArea.x += updatePos('left');\r\n      updatePos('right');\r\n      updatePos('bottom');\r\n    }\r\n    function getMargins(horizontal, chartArea) {\r\n      const maxPadding = chartArea.maxPadding;\r\n      function marginForPositions(positions) {\r\n        const margin = {left: 0, top: 0, right: 0, bottom: 0};\r\n        positions.forEach((pos) => {\r\n          margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\r\n        });\r\n        return margin;\r\n      }\r\n      return horizontal\r\n        ? marginForPositions(['left', 'right'])\r\n        : marginForPositions(['top', 'bottom']);\r\n    }\r\n    function fitBoxes(boxes, chartArea, params) {\r\n      const refitBoxes = [];\r\n      let i, ilen, layout, box, refit, changed;\r\n      for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\r\n        layout = boxes[i];\r\n        box = layout.box;\r\n        box.update(\r\n          layout.width || chartArea.w,\r\n          layout.height || chartArea.h,\r\n          getMargins(layout.horizontal, chartArea)\r\n        );\r\n        const {same, other} = updateDims(chartArea, params, layout);\r\n        refit |= same && refitBoxes.length;\r\n        changed = changed || other;\r\n        if (!box.fullSize) {\r\n          refitBoxes.push(layout);\r\n        }\r\n      }\r\n      return refit && fitBoxes(refitBoxes, chartArea, params) || changed;\r\n    }\r\n    function placeBoxes(boxes, chartArea, params) {\r\n      const userPadding = params.padding;\r\n      let x = chartArea.x;\r\n      let y = chartArea.y;\r\n      let i, ilen, layout, box;\r\n      for (i = 0, ilen = boxes.length; i < ilen; ++i) {\r\n        layout = boxes[i];\r\n        box = layout.box;\r\n        if (layout.horizontal) {\r\n          box.left = box.fullSize ? userPadding.left : chartArea.left;\r\n          box.right = box.fullSize ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;\r\n          box.top = y;\r\n          box.bottom = y + box.height;\r\n          box.width = box.right - box.left;\r\n          y = box.bottom;\r\n        } else {\r\n          box.left = x;\r\n          box.right = x + box.width;\r\n          box.top = box.fullSize ? userPadding.top : chartArea.top;\r\n          box.bottom = box.fullSize ? params.outerHeight - userPadding.right : chartArea.top + chartArea.h;\r\n          box.height = box.bottom - box.top;\r\n          x = box.right;\r\n        }\r\n      }\r\n      chartArea.x = x;\r\n      chartArea.y = y;\r\n    }\r\n    defaults.set('layout', {\r\n      padding: {\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0\r\n      }\r\n    });\r\n    var layouts = {\r\n      addBox(chart, item) {\r\n        if (!chart.boxes) {\r\n          chart.boxes = [];\r\n        }\r\n        item.fullSize = item.fullSize || false;\r\n        item.position = item.position || 'top';\r\n        item.weight = item.weight || 0;\r\n        item._layers = item._layers || function() {\r\n          return [{\r\n            z: 0,\r\n            draw(chartArea) {\r\n              item.draw(chartArea);\r\n            }\r\n          }];\r\n        };\r\n        chart.boxes.push(item);\r\n      },\r\n      removeBox(chart, layoutItem) {\r\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n        if (index !== -1) {\r\n          chart.boxes.splice(index, 1);\r\n        }\r\n      },\r\n      configure(chart, item, options) {\r\n        item.fullSize = options.fullSize;\r\n        item.position = options.position;\r\n        item.weight = options.weight;\r\n      },\r\n      update(chart, width, height, minPadding) {\r\n        if (!chart) {\r\n          return;\r\n        }\r\n        const padding = toPadding(chart.options.layout.padding);\r\n        const availableWidth = Math.max(width - padding.width, 0);\r\n        const availableHeight = Math.max(height - padding.height, 0);\r\n        const boxes = buildLayoutBoxes(chart.boxes);\r\n        const verticalBoxes = boxes.vertical;\r\n        const horizontalBoxes = boxes.horizontal;\r\n        each(chart.boxes, box => {\r\n          if (typeof box.beforeLayout === 'function') {\r\n            box.beforeLayout();\r\n          }\r\n        });\r\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\r\n          wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\r\n        const params = Object.freeze({\r\n          outerWidth: width,\r\n          outerHeight: height,\r\n          padding,\r\n          availableWidth,\r\n          availableHeight,\r\n          vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\r\n          hBoxMaxHeight: availableHeight / 2\r\n        });\r\n        const maxPadding = Object.assign({}, padding);\r\n        updateMaxPadding(maxPadding, toPadding(minPadding));\r\n        const chartArea = Object.assign({\r\n          maxPadding,\r\n          w: availableWidth,\r\n          h: availableHeight,\r\n          x: padding.left,\r\n          y: padding.top\r\n        }, padding);\r\n        setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\r\n        fitBoxes(boxes.fullSize, chartArea, params);\r\n        fitBoxes(verticalBoxes, chartArea, params);\r\n        if (fitBoxes(horizontalBoxes, chartArea, params)) {\r\n          fitBoxes(verticalBoxes, chartArea, params);\r\n        }\r\n        handleMaxPadding(chartArea);\r\n        placeBoxes(boxes.leftAndTop, chartArea, params);\r\n        chartArea.x += chartArea.w;\r\n        chartArea.y += chartArea.h;\r\n        placeBoxes(boxes.rightAndBottom, chartArea, params);\r\n        chart.chartArea = {\r\n          left: chartArea.left,\r\n          top: chartArea.top,\r\n          right: chartArea.left + chartArea.w,\r\n          bottom: chartArea.top + chartArea.h,\r\n          height: chartArea.h,\r\n          width: chartArea.w,\r\n        };\r\n        each(boxes.chartArea, (layout) => {\r\n          const box = layout.box;\r\n          Object.assign(box, chart.chartArea);\r\n          box.update(chartArea.w, chartArea.h);\r\n        });\r\n      }\r\n    };\r\n    \r\n    class BasePlatform {\r\n      acquireContext(canvas, aspectRatio) {}\r\n      releaseContext(context) {\r\n        return false;\r\n      }\r\n      addEventListener(chart, type, listener) {}\r\n      removeEventListener(chart, type, listener) {}\r\n      getDevicePixelRatio() {\r\n        return 1;\r\n      }\r\n      getMaximumSize(element, width, height, aspectRatio) {\r\n        width = Math.max(0, width || element.width);\r\n        height = height || element.height;\r\n        return {\r\n          width,\r\n          height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\r\n        };\r\n      }\r\n      isAttached(canvas) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    class BasicPlatform extends BasePlatform {\r\n      acquireContext(item) {\r\n        return item && item.getContext && item.getContext('2d') || null;\r\n      }\r\n    }\r\n    \r\n    const EXPANDO_KEY = '$chartjs';\r\n    const EVENT_TYPES = {\r\n      touchstart: 'mousedown',\r\n      touchmove: 'mousemove',\r\n      touchend: 'mouseup',\r\n      pointerenter: 'mouseenter',\r\n      pointerdown: 'mousedown',\r\n      pointermove: 'mousemove',\r\n      pointerup: 'mouseup',\r\n      pointerleave: 'mouseout',\r\n      pointerout: 'mouseout'\r\n    };\r\n    const isNullOrEmpty = value => value === null || value === '';\r\n    function initCanvas(canvas, aspectRatio) {\r\n      const style = canvas.style;\r\n      const renderHeight = canvas.getAttribute('height');\r\n      const renderWidth = canvas.getAttribute('width');\r\n      canvas[EXPANDO_KEY] = {\r\n        initial: {\r\n          height: renderHeight,\r\n          width: renderWidth,\r\n          style: {\r\n            display: style.display,\r\n            height: style.height,\r\n            width: style.width\r\n          }\r\n        }\r\n      };\r\n      style.display = style.display || 'block';\r\n      style.boxSizing = style.boxSizing || 'border-box';\r\n      if (isNullOrEmpty(renderWidth)) {\r\n        const displayWidth = readUsedSize(canvas, 'width');\r\n        if (displayWidth !== undefined) {\r\n          canvas.width = displayWidth;\r\n        }\r\n      }\r\n      if (isNullOrEmpty(renderHeight)) {\r\n        if (canvas.style.height === '') {\r\n          canvas.height = canvas.width / (aspectRatio || 2);\r\n        } else {\r\n          const displayHeight = readUsedSize(canvas, 'height');\r\n          if (displayHeight !== undefined) {\r\n            canvas.height = displayHeight;\r\n          }\r\n        }\r\n      }\r\n      return canvas;\r\n    }\r\n    const eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\n    function addListener(node, type, listener) {\r\n      node.addEventListener(type, listener, eventListenerOptions);\r\n    }\r\n    function removeListener(chart, type, listener) {\r\n      chart.canvas.removeEventListener(type, listener, eventListenerOptions);\r\n    }\r\n    function fromNativeEvent(event, chart) {\r\n      const type = EVENT_TYPES[event.type] || event.type;\r\n      const {x, y} = getRelativePosition$1(event, chart);\r\n      return {\r\n        type,\r\n        chart,\r\n        native: event,\r\n        x: x !== undefined ? x : null,\r\n        y: y !== undefined ? y : null,\r\n      };\r\n    }\r\n    function createAttachObserver(chart, type, listener) {\r\n      const canvas = chart.canvas;\r\n      const container = canvas && _getParentNode(canvas);\r\n      const element = container || canvas;\r\n      const observer = new MutationObserver(entries => {\r\n        const parent = _getParentNode(element);\r\n        entries.forEach(entry => {\r\n          for (let i = 0; i < entry.addedNodes.length; i++) {\r\n            const added = entry.addedNodes[i];\r\n            if (added === element || added === parent) {\r\n              listener(entry.target);\r\n            }\r\n          }\r\n        });\r\n      });\r\n      observer.observe(document, {childList: true, subtree: true});\r\n      return observer;\r\n    }\r\n    function createDetachObserver(chart, type, listener) {\r\n      const canvas = chart.canvas;\r\n      const container = canvas && _getParentNode(canvas);\r\n      if (!container) {\r\n        return;\r\n      }\r\n      const observer = new MutationObserver(entries => {\r\n        entries.forEach(entry => {\r\n          for (let i = 0; i < entry.removedNodes.length; i++) {\r\n            if (entry.removedNodes[i] === canvas) {\r\n              listener();\r\n              break;\r\n            }\r\n          }\r\n        });\r\n      });\r\n      observer.observe(container, {childList: true});\r\n      return observer;\r\n    }\r\n    const drpListeningCharts = new Map();\r\n    let oldDevicePixelRatio = 0;\r\n    function onWindowResize() {\r\n      const dpr = window.devicePixelRatio;\r\n      if (dpr === oldDevicePixelRatio) {\r\n        return;\r\n      }\r\n      oldDevicePixelRatio = dpr;\r\n      drpListeningCharts.forEach((resize, chart) => {\r\n        if (chart.currentDevicePixelRatio !== dpr) {\r\n          resize();\r\n        }\r\n      });\r\n    }\r\n    function listenDevicePixelRatioChanges(chart, resize) {\r\n      if (!drpListeningCharts.size) {\r\n        window.addEventListener('resize', onWindowResize);\r\n      }\r\n      drpListeningCharts.set(chart, resize);\r\n    }\r\n    function unlistenDevicePixelRatioChanges(chart) {\r\n      drpListeningCharts.delete(chart);\r\n      if (!drpListeningCharts.size) {\r\n        window.removeEventListener('resize', onWindowResize);\r\n      }\r\n    }\r\n    function createResizeObserver(chart, type, listener) {\r\n      const canvas = chart.canvas;\r\n      const container = canvas && _getParentNode(canvas);\r\n      if (!container) {\r\n        return;\r\n      }\r\n      const resize = throttled((width, height) => {\r\n        const w = container.clientWidth;\r\n        listener(width, height);\r\n        if (w < container.clientWidth) {\r\n          listener();\r\n        }\r\n      }, window);\r\n      const observer = new ResizeObserver(entries => {\r\n        const entry = entries[0];\r\n        const width = entry.contentRect.width;\r\n        const height = entry.contentRect.height;\r\n        if (width === 0 && height === 0) {\r\n          return;\r\n        }\r\n        resize(width, height);\r\n      });\r\n      observer.observe(container);\r\n      listenDevicePixelRatioChanges(chart, resize);\r\n      return observer;\r\n    }\r\n    function releaseObserver(chart, type, observer) {\r\n      if (observer) {\r\n        observer.disconnect();\r\n      }\r\n      if (type === 'resize') {\r\n        unlistenDevicePixelRatioChanges(chart);\r\n      }\r\n    }\r\n    function createProxyAndListen(chart, type, listener) {\r\n      const canvas = chart.canvas;\r\n      const proxy = throttled((event) => {\r\n        if (chart.ctx !== null) {\r\n          listener(fromNativeEvent(event, chart));\r\n        }\r\n      }, chart, (args) => {\r\n        const event = args[0];\r\n        return [event, event.offsetX, event.offsetY];\r\n      });\r\n      addListener(canvas, type, proxy);\r\n      return proxy;\r\n    }\r\n    class DomPlatform extends BasePlatform {\r\n      acquireContext(canvas, aspectRatio) {\r\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\r\n        if (context && context.canvas === canvas) {\r\n          initCanvas(canvas, aspectRatio);\r\n          return context;\r\n        }\r\n        return null;\r\n      }\r\n      releaseContext(context) {\r\n        const canvas = context.canvas;\r\n        if (!canvas[EXPANDO_KEY]) {\r\n          return false;\r\n        }\r\n        const initial = canvas[EXPANDO_KEY].initial;\r\n        ['height', 'width'].forEach((prop) => {\r\n          const value = initial[prop];\r\n          if (isNullOrUndef(value)) {\r\n            canvas.removeAttribute(prop);\r\n          } else {\r\n            canvas.setAttribute(prop, value);\r\n          }\r\n        });\r\n        const style = initial.style || {};\r\n        Object.keys(style).forEach((key) => {\r\n          canvas.style[key] = style[key];\r\n        });\r\n        canvas.width = canvas.width;\r\n        delete canvas[EXPANDO_KEY];\r\n        return true;\r\n      }\r\n      addEventListener(chart, type, listener) {\r\n        this.removeEventListener(chart, type);\r\n        const proxies = chart.$proxies || (chart.$proxies = {});\r\n        const handlers = {\r\n          attach: createAttachObserver,\r\n          detach: createDetachObserver,\r\n          resize: createResizeObserver\r\n        };\r\n        const handler = handlers[type] || createProxyAndListen;\r\n        proxies[type] = handler(chart, type, listener);\r\n      }\r\n      removeEventListener(chart, type) {\r\n        const proxies = chart.$proxies || (chart.$proxies = {});\r\n        const proxy = proxies[type];\r\n        if (!proxy) {\r\n          return;\r\n        }\r\n        const handlers = {\r\n          attach: releaseObserver,\r\n          detach: releaseObserver,\r\n          resize: releaseObserver\r\n        };\r\n        const handler = handlers[type] || removeListener;\r\n        handler(chart, type, proxy);\r\n        proxies[type] = undefined;\r\n      }\r\n      getDevicePixelRatio() {\r\n        return window.devicePixelRatio;\r\n      }\r\n      getMaximumSize(canvas, width, height, aspectRatio) {\r\n        return getMaximumSize(canvas, width, height, aspectRatio);\r\n      }\r\n      isAttached(canvas) {\r\n        const container = _getParentNode(canvas);\r\n        return !!(container && _getParentNode(container));\r\n      }\r\n    }\r\n    \r\n    var platforms = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    BasePlatform: BasePlatform,\r\n    BasicPlatform: BasicPlatform,\r\n    DomPlatform: DomPlatform\r\n    });\r\n    \r\n    const atEdge = (t) => t === 0 || t === 1;\r\n    const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\r\n    const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\r\n    const effects = {\r\n      linear: t => t,\r\n      easeInQuad: t => t * t,\r\n      easeOutQuad: t => -t * (t - 2),\r\n      easeInOutQuad: t => ((t /= 0.5) < 1)\r\n        ? 0.5 * t * t\r\n        : -0.5 * ((--t) * (t - 2) - 1),\r\n      easeInCubic: t => t * t * t,\r\n      easeOutCubic: t => (t -= 1) * t * t + 1,\r\n      easeInOutCubic: t => ((t /= 0.5) < 1)\r\n        ? 0.5 * t * t * t\r\n        : 0.5 * ((t -= 2) * t * t + 2),\r\n      easeInQuart: t => t * t * t * t,\r\n      easeOutQuart: t => -((t -= 1) * t * t * t - 1),\r\n      easeInOutQuart: t => ((t /= 0.5) < 1)\r\n        ? 0.5 * t * t * t * t\r\n        : -0.5 * ((t -= 2) * t * t * t - 2),\r\n      easeInQuint: t => t * t * t * t * t,\r\n      easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\r\n      easeInOutQuint: t => ((t /= 0.5) < 1)\r\n        ? 0.5 * t * t * t * t * t\r\n        : 0.5 * ((t -= 2) * t * t * t * t + 2),\r\n      easeInSine: t => -Math.cos(t * HALF_PI) + 1,\r\n      easeOutSine: t => Math.sin(t * HALF_PI),\r\n      easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\r\n      easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\r\n      easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\r\n      easeInOutExpo: t => atEdge(t) ? t : t < 0.5\r\n        ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\r\n        : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\r\n      easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\r\n      easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\r\n      easeInOutCirc: t => ((t /= 0.5) < 1)\r\n        ? -0.5 * (Math.sqrt(1 - t * t) - 1)\r\n        : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\r\n      easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\r\n      easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\r\n      easeInOutElastic(t) {\r\n        const s = 0.1125;\r\n        const p = 0.45;\r\n        return atEdge(t) ? t :\r\n          t < 0.5\r\n            ? 0.5 * elasticIn(t * 2, s, p)\r\n            : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\r\n      },\r\n      easeInBack(t) {\r\n        const s = 1.70158;\r\n        return t * t * ((s + 1) * t - s);\r\n      },\r\n      easeOutBack(t) {\r\n        const s = 1.70158;\r\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\r\n      },\r\n      easeInOutBack(t) {\r\n        let s = 1.70158;\r\n        if ((t /= 0.5) < 1) {\r\n          return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n        }\r\n        return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n      },\r\n      easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\r\n      easeOutBounce(t) {\r\n        const m = 7.5625;\r\n        const d = 2.75;\r\n        if (t < (1 / d)) {\r\n          return m * t * t;\r\n        }\r\n        if (t < (2 / d)) {\r\n          return m * (t -= (1.5 / d)) * t + 0.75;\r\n        }\r\n        if (t < (2.5 / d)) {\r\n          return m * (t -= (2.25 / d)) * t + 0.9375;\r\n        }\r\n        return m * (t -= (2.625 / d)) * t + 0.984375;\r\n      },\r\n      easeInOutBounce: t => (t < 0.5)\r\n        ? effects.easeInBounce(t * 2) * 0.5\r\n        : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\r\n    };\r\n    \r\n    const transparent = 'transparent';\r\n    const interpolators = {\r\n      boolean(from, to, factor) {\r\n        return factor > 0.5 ? to : from;\r\n      },\r\n      color(from, to, factor) {\r\n        const c0 = color(from || transparent);\r\n        const c1 = c0.valid && color(to || transparent);\r\n        return c1 && c1.valid\r\n          ? c1.mix(c0, factor).hexString()\r\n          : to;\r\n      },\r\n      number(from, to, factor) {\r\n        return from + (to - from) * factor;\r\n      }\r\n    };\r\n    class Animation {\r\n      constructor(cfg, target, prop, to) {\r\n        const currentValue = target[prop];\r\n        to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n        const from = resolve([cfg.from, currentValue, to]);\r\n        this._active = true;\r\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\r\n        this._easing = effects[cfg.easing] || effects.linear;\r\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\r\n        this._duration = this._total = Math.floor(cfg.duration);\r\n        this._loop = !!cfg.loop;\r\n        this._target = target;\r\n        this._prop = prop;\r\n        this._from = from;\r\n        this._to = to;\r\n        this._promises = undefined;\r\n      }\r\n      active() {\r\n        return this._active;\r\n      }\r\n      update(cfg, to, date) {\r\n        const me = this;\r\n        if (me._active) {\r\n          me._notify(false);\r\n          const currentValue = me._target[me._prop];\r\n          const elapsed = date - me._start;\r\n          const remain = me._duration - elapsed;\r\n          me._start = date;\r\n          me._duration = Math.floor(Math.max(remain, cfg.duration));\r\n          me._total += elapsed;\r\n          me._loop = !!cfg.loop;\r\n          me._to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n          me._from = resolve([cfg.from, currentValue, to]);\r\n        }\r\n      }\r\n      cancel() {\r\n        const me = this;\r\n        if (me._active) {\r\n          me.tick(Date.now());\r\n          me._active = false;\r\n          me._notify(false);\r\n        }\r\n      }\r\n      tick(date) {\r\n        const me = this;\r\n        const elapsed = date - me._start;\r\n        const duration = me._duration;\r\n        const prop = me._prop;\r\n        const from = me._from;\r\n        const loop = me._loop;\r\n        const to = me._to;\r\n        let factor;\r\n        me._active = from !== to && (loop || (elapsed < duration));\r\n        if (!me._active) {\r\n          me._target[prop] = to;\r\n          me._notify(true);\r\n          return;\r\n        }\r\n        if (elapsed < 0) {\r\n          me._target[prop] = from;\r\n          return;\r\n        }\r\n        factor = (elapsed / duration) % 2;\r\n        factor = loop && factor > 1 ? 2 - factor : factor;\r\n        factor = me._easing(Math.min(1, Math.max(0, factor)));\r\n        me._target[prop] = me._fn(from, to, factor);\r\n      }\r\n      wait() {\r\n        const promises = this._promises || (this._promises = []);\r\n        return new Promise((res, rej) => {\r\n          promises.push({res, rej});\r\n        });\r\n      }\r\n      _notify(resolved) {\r\n        const method = resolved ? 'res' : 'rej';\r\n        const promises = this._promises || [];\r\n        for (let i = 0; i < promises.length; i++) {\r\n          promises[i][method]();\r\n        }\r\n      }\r\n    }\r\n    \r\n    const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\r\n    const colors = ['color', 'borderColor', 'backgroundColor'];\r\n    defaults.set('animation', {\r\n      delay: undefined,\r\n      duration: 1000,\r\n      easing: 'easeOutQuart',\r\n      fn: undefined,\r\n      from: undefined,\r\n      loop: undefined,\r\n      to: undefined,\r\n      type: undefined,\r\n    });\r\n    const animationOptions = Object.keys(defaults.animation);\r\n    defaults.describe('animation', {\r\n      _fallback: false,\r\n      _indexable: false,\r\n      _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\r\n    });\r\n    defaults.set('animations', {\r\n      colors: {\r\n        type: 'color',\r\n        properties: colors\r\n      },\r\n      numbers: {\r\n        type: 'number',\r\n        properties: numbers\r\n      },\r\n    });\r\n    defaults.describe('animations', {\r\n      _fallback: 'animation',\r\n    });\r\n    defaults.set('transitions', {\r\n      active: {\r\n        animation: {\r\n          duration: 400\r\n        }\r\n      },\r\n      resize: {\r\n        animation: {\r\n          duration: 0\r\n        }\r\n      },\r\n      show: {\r\n        animations: {\r\n          colors: {\r\n            from: 'transparent'\r\n          },\r\n          visible: {\r\n            type: 'boolean',\r\n            duration: 0\r\n          },\r\n        }\r\n      },\r\n      hide: {\r\n        animations: {\r\n          colors: {\r\n            to: 'transparent'\r\n          },\r\n          visible: {\r\n            type: 'boolean',\r\n            easing: 'linear',\r\n            fn: v => v | 0\r\n          },\r\n        }\r\n      }\r\n    });\r\n    class Animations {\r\n      constructor(chart, config) {\r\n        this._chart = chart;\r\n        this._properties = new Map();\r\n        this.configure(config);\r\n      }\r\n      configure(config) {\r\n        if (!isObject(config)) {\r\n          return;\r\n        }\r\n        const animatedProps = this._properties;\r\n        Object.getOwnPropertyNames(config).forEach(key => {\r\n          const cfg = config[key];\r\n          if (!isObject(cfg)) {\r\n            return;\r\n          }\r\n          const resolved = {};\r\n          for (const option of animationOptions) {\r\n            resolved[option] = cfg[option];\r\n          }\r\n          (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\r\n            if (prop === key || !animatedProps.has(prop)) {\r\n              animatedProps.set(prop, resolved);\r\n            }\r\n          });\r\n        });\r\n      }\r\n      _animateOptions(target, values) {\r\n        const newOptions = values.options;\r\n        const options = resolveTargetOptions(target, newOptions);\r\n        if (!options) {\r\n          return [];\r\n        }\r\n        const animations = this._createAnimations(options, newOptions);\r\n        if (newOptions.$shared) {\r\n          awaitAll(target.options.$animations, newOptions).then(() => {\r\n            target.options = newOptions;\r\n          }, () => {\r\n          });\r\n        }\r\n        return animations;\r\n      }\r\n      _createAnimations(target, values) {\r\n        const animatedProps = this._properties;\r\n        const animations = [];\r\n        const running = target.$animations || (target.$animations = {});\r\n        const props = Object.keys(values);\r\n        const date = Date.now();\r\n        let i;\r\n        for (i = props.length - 1; i >= 0; --i) {\r\n          const prop = props[i];\r\n          if (prop.charAt(0) === '$') {\r\n            continue;\r\n          }\r\n          if (prop === 'options') {\r\n            animations.push(...this._animateOptions(target, values));\r\n            continue;\r\n          }\r\n          const value = values[prop];\r\n          let animation = running[prop];\r\n          const cfg = animatedProps.get(prop);\r\n          if (animation) {\r\n            if (cfg && animation.active()) {\r\n              animation.update(cfg, value, date);\r\n              continue;\r\n            } else {\r\n              animation.cancel();\r\n            }\r\n          }\r\n          if (!cfg || !cfg.duration) {\r\n            target[prop] = value;\r\n            continue;\r\n          }\r\n          running[prop] = animation = new Animation(cfg, target, prop, value);\r\n          animations.push(animation);\r\n        }\r\n        return animations;\r\n      }\r\n      update(target, values) {\r\n        if (this._properties.size === 0) {\r\n          Object.assign(target, values);\r\n          return;\r\n        }\r\n        const animations = this._createAnimations(target, values);\r\n        if (animations.length) {\r\n          animator.add(this._chart, animations);\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    function awaitAll(animations, properties) {\r\n      const running = [];\r\n      const keys = Object.keys(properties);\r\n      for (let i = 0; i < keys.length; i++) {\r\n        const anim = animations[keys[i]];\r\n        if (anim && anim.active()) {\r\n          running.push(anim.wait());\r\n        }\r\n      }\r\n      return Promise.all(running);\r\n    }\r\n    function resolveTargetOptions(target, newOptions) {\r\n      if (!newOptions) {\r\n        return;\r\n      }\r\n      let options = target.options;\r\n      if (!options) {\r\n        target.options = newOptions;\r\n        return;\r\n      }\r\n      if (options.$shared) {\r\n        target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\r\n      }\r\n      return options;\r\n    }\r\n    \r\n    function scaleClip(scale, allowedOverflow) {\r\n      const opts = scale && scale.options || {};\r\n      const reverse = opts.reverse;\r\n      const min = opts.min === undefined ? allowedOverflow : 0;\r\n      const max = opts.max === undefined ? allowedOverflow : 0;\r\n      return {\r\n        start: reverse ? max : min,\r\n        end: reverse ? min : max\r\n      };\r\n    }\r\n    function defaultClip(xScale, yScale, allowedOverflow) {\r\n      if (allowedOverflow === false) {\r\n        return false;\r\n      }\r\n      const x = scaleClip(xScale, allowedOverflow);\r\n      const y = scaleClip(yScale, allowedOverflow);\r\n      return {\r\n        top: y.end,\r\n        right: x.end,\r\n        bottom: y.start,\r\n        left: x.start\r\n      };\r\n    }\r\n    function toClip(value) {\r\n      let t, r, b, l;\r\n      if (isObject(value)) {\r\n        t = value.top;\r\n        r = value.right;\r\n        b = value.bottom;\r\n        l = value.left;\r\n      } else {\r\n        t = r = b = l = value;\r\n      }\r\n      return {\r\n        top: t,\r\n        right: r,\r\n        bottom: b,\r\n        left: l\r\n      };\r\n    }\r\n    function getSortedDatasetIndices(chart, filterVisible) {\r\n      const keys = [];\r\n      const metasets = chart._getSortedDatasetMetas(filterVisible);\r\n      let i, ilen;\r\n      for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n        keys.push(metasets[i].index);\r\n      }\r\n      return keys;\r\n    }\r\n    function applyStack(stack, value, dsIndex, options) {\r\n      const keys = stack.keys;\r\n      const singleMode = options.mode === 'single';\r\n      let i, ilen, datasetIndex, otherValue;\r\n      if (value === null) {\r\n        return;\r\n      }\r\n      for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n        datasetIndex = +keys[i];\r\n        if (datasetIndex === dsIndex) {\r\n          if (options.all) {\r\n            continue;\r\n          }\r\n          break;\r\n        }\r\n        otherValue = stack.values[datasetIndex];\r\n        if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\r\n          value += otherValue;\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n    function convertObjectDataToArray(data) {\r\n      const keys = Object.keys(data);\r\n      const adata = new Array(keys.length);\r\n      let i, ilen, key;\r\n      for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n        key = keys[i];\r\n        adata[i] = {\r\n          x: key,\r\n          y: data[key]\r\n        };\r\n      }\r\n      return adata;\r\n    }\r\n    function isStacked(scale, meta) {\r\n      const stacked = scale && scale.options.stacked;\r\n      return stacked || (stacked === undefined && meta.stack !== undefined);\r\n    }\r\n    function getStackKey(indexScale, valueScale, meta) {\r\n      return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\r\n    }\r\n    function getUserBounds(scale) {\r\n      const {min, max, minDefined, maxDefined} = scale.getUserBounds();\r\n      return {\r\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\r\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\r\n      };\r\n    }\r\n    function getOrCreateStack(stacks, stackKey, indexValue) {\r\n      const subStack = stacks[stackKey] || (stacks[stackKey] = {});\r\n      return subStack[indexValue] || (subStack[indexValue] = {});\r\n    }\r\n    function getLastIndexInStack(stack, vScale, positive) {\r\n      for (const meta of vScale.getMatchingVisibleMetas('bar').reverse()) {\r\n        const value = stack[meta.index];\r\n        if ((positive && value > 0) || (!positive && value < 0)) {\r\n          return meta.index;\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n    function updateStacks(controller, parsed) {\r\n      const {chart, _cachedMeta: meta} = controller;\r\n      const stacks = chart._stacks || (chart._stacks = {});\r\n      const {iScale, vScale, index: datasetIndex} = meta;\r\n      const iAxis = iScale.axis;\r\n      const vAxis = vScale.axis;\r\n      const key = getStackKey(iScale, vScale, meta);\r\n      const ilen = parsed.length;\r\n      let stack;\r\n      for (let i = 0; i < ilen; ++i) {\r\n        const item = parsed[i];\r\n        const {[iAxis]: index, [vAxis]: value} = item;\r\n        const itemStacks = item._stacks || (item._stacks = {});\r\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\r\n        stack[datasetIndex] = value;\r\n        stack._top = getLastIndexInStack(stack, vScale, true);\r\n        stack._bottom = getLastIndexInStack(stack, vScale, false);\r\n      }\r\n    }\r\n    function getFirstScaleId(chart, axis) {\r\n      const scales = chart.scales;\r\n      return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\r\n    }\r\n    function createDatasetContext(parent, index) {\r\n      return Object.assign(Object.create(parent),\r\n        {\r\n          active: false,\r\n          dataset: undefined,\r\n          datasetIndex: index,\r\n          index,\r\n          mode: 'default',\r\n          type: 'dataset'\r\n        }\r\n      );\r\n    }\r\n    function createDataContext(parent, index, element) {\r\n      return Object.assign(Object.create(parent), {\r\n        active: false,\r\n        dataIndex: index,\r\n        parsed: undefined,\r\n        raw: undefined,\r\n        element,\r\n        index,\r\n        mode: 'default',\r\n        type: 'data'\r\n      });\r\n    }\r\n    function clearStacks(meta, items) {\r\n      items = items || meta._parsed;\r\n      for (const parsed of items) {\r\n        const stacks = parsed._stacks;\r\n        if (!stacks || stacks[meta.vScale.id] === undefined || stacks[meta.vScale.id][meta.index] === undefined) {\r\n          return;\r\n        }\r\n        delete stacks[meta.vScale.id][meta.index];\r\n      }\r\n    }\r\n    const isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\r\n    const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\r\n    class DatasetController {\r\n      constructor(chart, datasetIndex) {\r\n        this.chart = chart;\r\n        this._ctx = chart.ctx;\r\n        this.index = datasetIndex;\r\n        this._cachedDataOpts = {};\r\n        this._cachedMeta = this.getMeta();\r\n        this._type = this._cachedMeta.type;\r\n        this.options = undefined;\r\n        this._parsing = false;\r\n        this._data = undefined;\r\n        this._objectData = undefined;\r\n        this._sharedOptions = undefined;\r\n        this._drawStart = undefined;\r\n        this._drawCount = undefined;\r\n        this.enableOptionSharing = false;\r\n        this.$context = undefined;\r\n        this._syncList = [];\r\n        this.initialize();\r\n      }\r\n      initialize() {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        me.configure();\r\n        me.linkScales();\r\n        meta._stacked = isStacked(meta.vScale, meta);\r\n        me.addElements();\r\n      }\r\n      updateIndex(datasetIndex) {\r\n        if (this.index !== datasetIndex) {\r\n          clearStacks(this._cachedMeta);\r\n        }\r\n        this.index = datasetIndex;\r\n      }\r\n      linkScales() {\r\n        const me = this;\r\n        const chart = me.chart;\r\n        const meta = me._cachedMeta;\r\n        const dataset = me.getDataset();\r\n        const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\r\n        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\r\n        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\r\n        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\r\n        const indexAxis = meta.indexAxis;\r\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\r\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\r\n        meta.xScale = me.getScaleForId(xid);\r\n        meta.yScale = me.getScaleForId(yid);\r\n        meta.rScale = me.getScaleForId(rid);\r\n        meta.iScale = me.getScaleForId(iid);\r\n        meta.vScale = me.getScaleForId(vid);\r\n      }\r\n      getDataset() {\r\n        return this.chart.data.datasets[this.index];\r\n      }\r\n      getMeta() {\r\n        return this.chart.getDatasetMeta(this.index);\r\n      }\r\n      getScaleForId(scaleID) {\r\n        return this.chart.scales[scaleID];\r\n      }\r\n      _getOtherScale(scale) {\r\n        const meta = this._cachedMeta;\r\n        return scale === meta.iScale\r\n          ? meta.vScale\r\n          : meta.iScale;\r\n      }\r\n      reset() {\r\n        this._update('reset');\r\n      }\r\n      _destroy() {\r\n        const meta = this._cachedMeta;\r\n        if (this._data) {\r\n          unlistenArrayEvents(this._data, this);\r\n        }\r\n        if (meta._stacked) {\r\n          clearStacks(meta);\r\n        }\r\n      }\r\n      _dataCheck() {\r\n        const me = this;\r\n        const dataset = me.getDataset();\r\n        const data = dataset.data || (dataset.data = []);\r\n        const _data = me._data;\r\n        if (isObject(data)) {\r\n          me._data = convertObjectDataToArray(data);\r\n        } else if (_data !== data) {\r\n          if (_data) {\r\n            unlistenArrayEvents(_data, me);\r\n            const meta = me._cachedMeta;\r\n            clearStacks(meta);\r\n            meta._parsed = [];\r\n          }\r\n          if (data && Object.isExtensible(data)) {\r\n            listenArrayEvents(data, me);\r\n          }\r\n          me._syncList = [];\r\n          me._data = data;\r\n        }\r\n      }\r\n      addElements() {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        me._dataCheck();\r\n        if (me.datasetElementType) {\r\n          meta.dataset = new me.datasetElementType();\r\n        }\r\n      }\r\n      buildOrUpdateElements(resetNewElements) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const dataset = me.getDataset();\r\n        let stackChanged = false;\r\n        me._dataCheck();\r\n        const oldStacked = meta._stacked;\r\n        meta._stacked = isStacked(meta.vScale, meta);\r\n        if (meta.stack !== dataset.stack) {\r\n          stackChanged = true;\r\n          clearStacks(meta);\r\n          meta.stack = dataset.stack;\r\n        }\r\n        me._resyncElements(resetNewElements);\r\n        if (stackChanged || oldStacked !== meta._stacked) {\r\n          updateStacks(me, meta._parsed);\r\n        }\r\n      }\r\n      configure() {\r\n        const me = this;\r\n        const config = me.chart.config;\r\n        const scopeKeys = config.datasetScopeKeys(me._type);\r\n        const scopes = config.getOptionScopes(me.getDataset(), scopeKeys, true);\r\n        me.options = config.createResolver(scopes, me.getContext());\r\n        me._parsing = me.options.parsing;\r\n      }\r\n      parse(start, count) {\r\n        const me = this;\r\n        const {_cachedMeta: meta, _data: data} = me;\r\n        const {iScale, _stacked} = meta;\r\n        const iAxis = iScale.axis;\r\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\r\n        let prev = start > 0 && meta._parsed[start - 1];\r\n        let i, cur, parsed;\r\n        if (me._parsing === false) {\r\n          meta._parsed = data;\r\n          meta._sorted = true;\r\n          parsed = data;\r\n        } else {\r\n          if (isArray(data[start])) {\r\n            parsed = me.parseArrayData(meta, data, start, count);\r\n          } else if (isObject(data[start])) {\r\n            parsed = me.parseObjectData(meta, data, start, count);\r\n          } else {\r\n            parsed = me.parsePrimitiveData(meta, data, start, count);\r\n          }\r\n          const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\r\n          for (i = 0; i < count; ++i) {\r\n            meta._parsed[i + start] = cur = parsed[i];\r\n            if (sorted) {\r\n              if (isNotInOrderComparedToPrev()) {\r\n                sorted = false;\r\n              }\r\n              prev = cur;\r\n            }\r\n          }\r\n          meta._sorted = sorted;\r\n        }\r\n        if (_stacked) {\r\n          updateStacks(me, parsed);\r\n        }\r\n      }\r\n      parsePrimitiveData(meta, data, start, count) {\r\n        const {iScale, vScale} = meta;\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        const labels = iScale.getLabels();\r\n        const singleScale = iScale === vScale;\r\n        const parsed = new Array(count);\r\n        let i, ilen, index;\r\n        for (i = 0, ilen = count; i < ilen; ++i) {\r\n          index = i + start;\r\n          parsed[i] = {\r\n            [iAxis]: singleScale || iScale.parse(labels[index], index),\r\n            [vAxis]: vScale.parse(data[index], index)\r\n          };\r\n        }\r\n        return parsed;\r\n      }\r\n      parseArrayData(meta, data, start, count) {\r\n        const {xScale, yScale} = meta;\r\n        const parsed = new Array(count);\r\n        let i, ilen, index, item;\r\n        for (i = 0, ilen = count; i < ilen; ++i) {\r\n          index = i + start;\r\n          item = data[index];\r\n          parsed[i] = {\r\n            x: xScale.parse(item[0], index),\r\n            y: yScale.parse(item[1], index)\r\n          };\r\n        }\r\n        return parsed;\r\n      }\r\n      parseObjectData(meta, data, start, count) {\r\n        const {xScale, yScale} = meta;\r\n        const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n        const parsed = new Array(count);\r\n        let i, ilen, index, item;\r\n        for (i = 0, ilen = count; i < ilen; ++i) {\r\n          index = i + start;\r\n          item = data[index];\r\n          parsed[i] = {\r\n            x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\r\n            y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\r\n          };\r\n        }\r\n        return parsed;\r\n      }\r\n      getParsed(index) {\r\n        return this._cachedMeta._parsed[index];\r\n      }\r\n      getDataElement(index) {\r\n        return this._cachedMeta.data[index];\r\n      }\r\n      applyStack(scale, parsed, mode) {\r\n        const chart = this.chart;\r\n        const meta = this._cachedMeta;\r\n        const value = parsed[scale.axis];\r\n        const stack = {\r\n          keys: getSortedDatasetIndices(chart, true),\r\n          values: parsed._stacks[scale.axis]\r\n        };\r\n        return applyStack(stack, value, meta.index, {mode});\r\n      }\r\n      updateRangeFromParsed(range, scale, parsed, stack) {\r\n        const parsedValue = parsed[scale.axis];\r\n        let value = parsedValue === null ? NaN : parsedValue;\r\n        const values = stack && parsed._stacks[scale.axis];\r\n        if (stack && values) {\r\n          stack.values = values;\r\n          range.min = Math.min(range.min, value);\r\n          range.max = Math.max(range.max, value);\r\n          value = applyStack(stack, parsedValue, this._cachedMeta.index, {all: true});\r\n        }\r\n        range.min = Math.min(range.min, value);\r\n        range.max = Math.max(range.max, value);\r\n      }\r\n      getMinMax(scale, canStack) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const _parsed = meta._parsed;\r\n        const sorted = meta._sorted && scale === meta.iScale;\r\n        const ilen = _parsed.length;\r\n        const otherScale = me._getOtherScale(scale);\r\n        const stack = canStack && meta._stacked && {keys: getSortedDatasetIndices(me.chart, true), values: null};\r\n        const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n        const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\r\n        let i, value, parsed, otherValue;\r\n        function _skip() {\r\n          parsed = _parsed[i];\r\n          value = parsed[scale.axis];\r\n          otherValue = parsed[otherScale.axis];\r\n          return !isNumberFinite(value) || otherMin > otherValue || otherMax < otherValue;\r\n        }\r\n        for (i = 0; i < ilen; ++i) {\r\n          if (_skip()) {\r\n            continue;\r\n          }\r\n          me.updateRangeFromParsed(range, scale, parsed, stack);\r\n          if (sorted) {\r\n            break;\r\n          }\r\n        }\r\n        if (sorted) {\r\n          for (i = ilen - 1; i >= 0; --i) {\r\n            if (_skip()) {\r\n              continue;\r\n            }\r\n            me.updateRangeFromParsed(range, scale, parsed, stack);\r\n            break;\r\n          }\r\n        }\r\n        return range;\r\n      }\r\n      getAllParsedValues(scale) {\r\n        const parsed = this._cachedMeta._parsed;\r\n        const values = [];\r\n        let i, ilen, value;\r\n        for (i = 0, ilen = parsed.length; i < ilen; ++i) {\r\n          value = parsed[i][scale.axis];\r\n          if (isNumberFinite(value)) {\r\n            values.push(value);\r\n          }\r\n        }\r\n        return values;\r\n      }\r\n      getMaxOverflow() {\r\n        return false;\r\n      }\r\n      getLabelAndValue(index) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const iScale = meta.iScale;\r\n        const vScale = meta.vScale;\r\n        const parsed = me.getParsed(index);\r\n        return {\r\n          label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\r\n          value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\r\n        };\r\n      }\r\n      _update(mode) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        me.configure();\r\n        me._cachedDataOpts = {};\r\n        me.update(mode || 'default');\r\n        meta._clip = toClip(valueOrDefault(me.options.clip, defaultClip(meta.xScale, meta.yScale, me.getMaxOverflow())));\r\n      }\r\n      update(mode) {}\r\n      draw() {\r\n        const me = this;\r\n        const ctx = me._ctx;\r\n        const chart = me.chart;\r\n        const meta = me._cachedMeta;\r\n        const elements = meta.data || [];\r\n        const area = chart.chartArea;\r\n        const active = [];\r\n        const start = me._drawStart || 0;\r\n        const count = me._drawCount || (elements.length - start);\r\n        let i;\r\n        if (meta.dataset) {\r\n          meta.dataset.draw(ctx, area, start, count);\r\n        }\r\n        for (i = start; i < start + count; ++i) {\r\n          const element = elements[i];\r\n          if (element.active) {\r\n            active.push(element);\r\n          } else {\r\n            element.draw(ctx, area);\r\n          }\r\n        }\r\n        for (i = 0; i < active.length; ++i) {\r\n          active[i].draw(ctx, area);\r\n        }\r\n      }\r\n      getStyle(index, active) {\r\n        const mode = active ? 'active' : 'default';\r\n        return index === undefined && this._cachedMeta.dataset\r\n          ? this.resolveDatasetElementOptions(mode)\r\n          : this.resolveDataElementOptions(index || 0, mode);\r\n      }\r\n      getContext(index, active, mode) {\r\n        const me = this;\r\n        const dataset = me.getDataset();\r\n        let context;\r\n        if (index >= 0 && index < me._cachedMeta.data.length) {\r\n          const element = me._cachedMeta.data[index];\r\n          context = element.$context ||\r\n            (element.$context = createDataContext(me.getContext(), index, element));\r\n          context.parsed = me.getParsed(index);\r\n          context.raw = dataset.data[index];\r\n          context.index = context.dataIndex = index;\r\n        } else {\r\n          context = me.$context ||\r\n            (me.$context = createDatasetContext(me.chart.getContext(), me.index));\r\n          context.dataset = dataset;\r\n          context.index = context.datasetIndex = me.index;\r\n        }\r\n        context.active = !!active;\r\n        context.mode = mode;\r\n        return context;\r\n      }\r\n      resolveDatasetElementOptions(mode) {\r\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\r\n      }\r\n      resolveDataElementOptions(index, mode) {\r\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\r\n      }\r\n      _resolveElementOptions(elementType, mode = 'default', index) {\r\n        const me = this;\r\n        const active = mode === 'active';\r\n        const cache = me._cachedDataOpts;\r\n        const cacheKey = elementType + '-' + mode;\r\n        const cached = cache[cacheKey];\r\n        const sharing = me.enableOptionSharing && defined(index);\r\n        if (cached) {\r\n          return cloneIfNotShared(cached, sharing);\r\n        }\r\n        const config = me.chart.config;\r\n        const scopeKeys = config.datasetElementScopeKeys(me._type, elementType);\r\n        const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\r\n        const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\r\n        const names = Object.keys(defaults.elements[elementType]);\r\n        const context = () => me.getContext(index, active);\r\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\r\n        if (values.$shared) {\r\n          values.$shared = sharing;\r\n          cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\r\n        }\r\n        return values;\r\n      }\r\n      _resolveAnimations(index, transition, active) {\r\n        const me = this;\r\n        const chart = me.chart;\r\n        const cache = me._cachedDataOpts;\r\n        const cacheKey = `animation-${transition}`;\r\n        const cached = cache[cacheKey];\r\n        if (cached) {\r\n          return cached;\r\n        }\r\n        let options;\r\n        if (chart.options.animation !== false) {\r\n          const config = me.chart.config;\r\n          const scopeKeys = config.datasetAnimationScopeKeys(me._type, transition);\r\n          const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);\r\n          options = config.createResolver(scopes, me.getContext(index, active, transition));\r\n        }\r\n        const animations = new Animations(chart, options && options.animations);\r\n        if (options && options._cacheable) {\r\n          cache[cacheKey] = Object.freeze(animations);\r\n        }\r\n        return animations;\r\n      }\r\n      getSharedOptions(options) {\r\n        if (!options.$shared) {\r\n          return;\r\n        }\r\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\r\n      }\r\n      includeOptions(mode, sharedOptions) {\r\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\r\n      }\r\n      updateElement(element, index, properties, mode) {\r\n        if (isDirectUpdateMode(mode)) {\r\n          Object.assign(element, properties);\r\n        } else {\r\n          this._resolveAnimations(index, mode).update(element, properties);\r\n        }\r\n      }\r\n      updateSharedOptions(sharedOptions, mode, newOptions) {\r\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\r\n          this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\r\n        }\r\n      }\r\n      _setStyle(element, index, mode, active) {\r\n        element.active = active;\r\n        const options = this.getStyle(index, active);\r\n        this._resolveAnimations(index, mode, active).update(element, {\r\n          options: (!active && this.getSharedOptions(options)) || options\r\n        });\r\n      }\r\n      removeHoverStyle(element, datasetIndex, index) {\r\n        this._setStyle(element, index, 'active', false);\r\n      }\r\n      setHoverStyle(element, datasetIndex, index) {\r\n        this._setStyle(element, index, 'active', true);\r\n      }\r\n      _removeDatasetHoverStyle() {\r\n        const element = this._cachedMeta.dataset;\r\n        if (element) {\r\n          this._setStyle(element, undefined, 'active', false);\r\n        }\r\n      }\r\n      _setDatasetHoverStyle() {\r\n        const element = this._cachedMeta.dataset;\r\n        if (element) {\r\n          this._setStyle(element, undefined, 'active', true);\r\n        }\r\n      }\r\n      _resyncElements(resetNewElements) {\r\n        const me = this;\r\n        const data = me._data;\r\n        const elements = me._cachedMeta.data;\r\n        for (const [method, arg1, arg2] of me._syncList) {\r\n          me[method](arg1, arg2);\r\n        }\r\n        me._syncList = [];\r\n        const numMeta = elements.length;\r\n        const numData = data.length;\r\n        const count = Math.min(numData, numMeta);\r\n        if (numData > numMeta) {\r\n          me._insertElements(numMeta, numData - numMeta, resetNewElements);\r\n        } else if (numData < numMeta) {\r\n          me._removeElements(numData, numMeta - numData);\r\n        }\r\n        if (count) {\r\n          me.parse(0, count);\r\n        }\r\n      }\r\n      _insertElements(start, count, resetNewElements = true) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const data = meta.data;\r\n        const end = start + count;\r\n        let i;\r\n        const move = (arr) => {\r\n          arr.length += count;\r\n          for (i = arr.length - 1; i >= end; i--) {\r\n            arr[i] = arr[i - count];\r\n          }\r\n        };\r\n        move(data);\r\n        for (i = start; i < end; ++i) {\r\n          data[i] = new me.dataElementType();\r\n        }\r\n        if (me._parsing) {\r\n          move(meta._parsed);\r\n        }\r\n        me.parse(start, count);\r\n        if (resetNewElements) {\r\n          me.updateElements(data, start, count, 'reset');\r\n        }\r\n      }\r\n      updateElements(element, start, count, mode) {}\r\n      _removeElements(start, count) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        if (me._parsing) {\r\n          const removed = meta._parsed.splice(start, count);\r\n          if (meta._stacked) {\r\n            clearStacks(meta, removed);\r\n          }\r\n        }\r\n        meta.data.splice(start, count);\r\n      }\r\n      _onDataPush() {\r\n        const count = arguments.length;\r\n        this._syncList.push(['_insertElements', this.getDataset().data.length - count, count]);\r\n      }\r\n      _onDataPop() {\r\n        this._syncList.push(['_removeElements', this._cachedMeta.data.length - 1, 1]);\r\n      }\r\n      _onDataShift() {\r\n        this._syncList.push(['_removeElements', 0, 1]);\r\n      }\r\n      _onDataSplice(start, count) {\r\n        this._syncList.push(['_removeElements', start, count]);\r\n        this._syncList.push(['_insertElements', start, arguments.length - 2]);\r\n      }\r\n      _onDataUnshift() {\r\n        this._syncList.push(['_insertElements', 0, arguments.length]);\r\n      }\r\n    }\r\n    DatasetController.defaults = {};\r\n    DatasetController.prototype.datasetElementType = null;\r\n    DatasetController.prototype.dataElementType = null;\r\n    \r\n    class Element {\r\n      constructor() {\r\n        this.x = undefined;\r\n        this.y = undefined;\r\n        this.active = false;\r\n        this.options = undefined;\r\n        this.$animations = undefined;\r\n      }\r\n      tooltipPosition(useFinalPosition) {\r\n        const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n        return {x, y};\r\n      }\r\n      hasValue() {\r\n        return isNumber(this.x) && isNumber(this.y);\r\n      }\r\n      getProps(props, final) {\r\n        const me = this;\r\n        const anims = this.$animations;\r\n        if (!final || !anims) {\r\n          return me;\r\n        }\r\n        const ret = {};\r\n        props.forEach(prop => {\r\n          ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : me[prop];\r\n        });\r\n        return ret;\r\n      }\r\n    }\r\n    Element.defaults = {};\r\n    Element.defaultRoutes = undefined;\r\n    \r\n    const intlCache = new Map();\r\n    function getNumberFormat(locale, options) {\r\n      options = options || {};\r\n      const cacheKey = locale + JSON.stringify(options);\r\n      let formatter = intlCache.get(cacheKey);\r\n      if (!formatter) {\r\n        formatter = new Intl.NumberFormat(locale, options);\r\n        intlCache.set(cacheKey, formatter);\r\n      }\r\n      return formatter;\r\n    }\r\n    function formatNumber(num, locale, options) {\r\n      return getNumberFormat(locale, options).format(num);\r\n    }\r\n    \r\n    const formatters = {\r\n      values(value) {\r\n        return isArray(value) ? value : '' + value;\r\n      },\r\n      numeric(tickValue, index, ticks) {\r\n        if (tickValue === 0) {\r\n          return '0';\r\n        }\r\n        const locale = this.chart.options.locale;\r\n        let notation;\r\n        let delta = tickValue;\r\n        if (ticks.length > 1) {\r\n          const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\r\n          if (maxTick < 1e-4 || maxTick > 1e+15) {\r\n            notation = 'scientific';\r\n          }\r\n          delta = calculateDelta(tickValue, ticks);\r\n        }\r\n        const logDelta = log10(Math.abs(delta));\r\n        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\r\n        const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\r\n        Object.assign(options, this.options.ticks.format);\r\n        return formatNumber(tickValue, locale, options);\r\n      },\r\n      logarithmic(tickValue, index, ticks) {\r\n        if (tickValue === 0) {\r\n          return '0';\r\n        }\r\n        const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\r\n        if (remain === 1 || remain === 2 || remain === 5) {\r\n          return formatters.numeric.call(this, tickValue, index, ticks);\r\n        }\r\n        return '';\r\n      }\r\n    };\r\n    function calculateDelta(tickValue, ticks) {\r\n      let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\r\n      if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\r\n        delta = tickValue - Math.floor(tickValue);\r\n      }\r\n      return delta;\r\n    }\r\n    var Ticks = {formatters};\r\n    \r\n    defaults.set('scale', {\r\n      display: true,\r\n      offset: false,\r\n      reverse: false,\r\n      beginAtZero: false,\r\n      bounds: 'ticks',\r\n      grace: 0,\r\n      grid: {\r\n        display: true,\r\n        lineWidth: 1,\r\n        drawBorder: true,\r\n        drawOnChartArea: true,\r\n        drawTicks: true,\r\n        tickLength: 8,\r\n        tickWidth: (_ctx, options) => options.lineWidth,\r\n        tickColor: (_ctx, options) => options.color,\r\n        offset: false,\r\n        borderDash: [],\r\n        borderDashOffset: 0.0,\r\n        borderWidth: 1\r\n      },\r\n      title: {\r\n        display: false,\r\n        text: '',\r\n        padding: {\r\n          top: 4,\r\n          bottom: 4\r\n        }\r\n      },\r\n      ticks: {\r\n        minRotation: 0,\r\n        maxRotation: 50,\r\n        mirror: false,\r\n        textStrokeWidth: 0,\r\n        textStrokeColor: '',\r\n        padding: 3,\r\n        display: true,\r\n        autoSkip: true,\r\n        autoSkipPadding: 3,\r\n        labelOffset: 0,\r\n        callback: Ticks.formatters.values,\r\n        minor: {},\r\n        major: {},\r\n        align: 'center',\r\n        crossAlign: 'near',\r\n        showLabelBackdrop: false,\r\n        backdropColor: 'rgba(255, 255, 255, 0.75)',\r\n        backdropPadding: 2,\r\n      }\r\n    });\r\n    defaults.route('scale.ticks', 'color', '', 'color');\r\n    defaults.route('scale.grid', 'color', '', 'borderColor');\r\n    defaults.route('scale.grid', 'borderColor', '', 'borderColor');\r\n    defaults.route('scale.title', 'color', '', 'color');\r\n    defaults.describe('scale', {\r\n      _fallback: false,\r\n      _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\r\n      _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\r\n    });\r\n    defaults.describe('scales', {\r\n      _fallback: 'scale',\r\n    });\r\n    \r\n    function autoSkip(scale, ticks) {\r\n      const tickOpts = scale.options.ticks;\r\n      const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\r\n      const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\r\n      const numMajorIndices = majorIndices.length;\r\n      const first = majorIndices[0];\r\n      const last = majorIndices[numMajorIndices - 1];\r\n      const newTicks = [];\r\n      if (numMajorIndices > ticksLimit) {\r\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\r\n        return newTicks;\r\n      }\r\n      const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\r\n      if (numMajorIndices > 0) {\r\n        let i, ilen;\r\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\r\n        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n          skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\r\n        }\r\n        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\r\n        return newTicks;\r\n      }\r\n      skip(ticks, newTicks, spacing);\r\n      return newTicks;\r\n    }\r\n    function determineMaxTicks(scale) {\r\n      const offset = scale.options.offset;\r\n      const tickLength = scale._tickSize();\r\n      const maxScale = scale._length / tickLength + (offset ? 0 : 1);\r\n      const maxChart = scale._maxLength / tickLength;\r\n      return Math.floor(Math.min(maxScale, maxChart));\r\n    }\r\n    function calculateSpacing(majorIndices, ticks, ticksLimit) {\r\n      const evenMajorSpacing = getEvenSpacing(majorIndices);\r\n      const spacing = ticks.length / ticksLimit;\r\n      if (!evenMajorSpacing) {\r\n        return Math.max(spacing, 1);\r\n      }\r\n      const factors = _factorize(evenMajorSpacing);\r\n      for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n        const factor = factors[i];\r\n        if (factor > spacing) {\r\n          return factor;\r\n        }\r\n      }\r\n      return Math.max(spacing, 1);\r\n    }\r\n    function getMajorIndices(ticks) {\r\n      const result = [];\r\n      let i, ilen;\r\n      for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n        if (ticks[i].major) {\r\n          result.push(i);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n    function skipMajors(ticks, newTicks, majorIndices, spacing) {\r\n      let count = 0;\r\n      let next = majorIndices[0];\r\n      let i;\r\n      spacing = Math.ceil(spacing);\r\n      for (i = 0; i < ticks.length; i++) {\r\n        if (i === next) {\r\n          newTicks.push(ticks[i]);\r\n          count++;\r\n          next = majorIndices[count * spacing];\r\n        }\r\n      }\r\n    }\r\n    function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\r\n      const start = valueOrDefault(majorStart, 0);\r\n      const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\r\n      let count = 0;\r\n      let length, i, next;\r\n      spacing = Math.ceil(spacing);\r\n      if (majorEnd) {\r\n        length = majorEnd - majorStart;\r\n        spacing = length / Math.floor(length / spacing);\r\n      }\r\n      next = start;\r\n      while (next < 0) {\r\n        count++;\r\n        next = Math.round(start + count * spacing);\r\n      }\r\n      for (i = Math.max(start, 0); i < end; i++) {\r\n        if (i === next) {\r\n          newTicks.push(ticks[i]);\r\n          count++;\r\n          next = Math.round(start + count * spacing);\r\n        }\r\n      }\r\n    }\r\n    function getEvenSpacing(arr) {\r\n      const len = arr.length;\r\n      let i, diff;\r\n      if (len < 2) {\r\n        return false;\r\n      }\r\n      for (diff = arr[0], i = 1; i < len; ++i) {\r\n        if (arr[i] - arr[i - 1] !== diff) {\r\n          return false;\r\n        }\r\n      }\r\n      return diff;\r\n    }\r\n    \r\n    const reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\r\n    const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\r\n    function sample(arr, numItems) {\r\n      const result = [];\r\n      const increment = arr.length / numItems;\r\n      const len = arr.length;\r\n      let i = 0;\r\n      for (; i < len; i += increment) {\r\n        result.push(arr[Math.floor(i)]);\r\n      }\r\n      return result;\r\n    }\r\n    function getPixelForGridLine(scale, index, offsetGridLines) {\r\n      const length = scale.ticks.length;\r\n      const validIndex = Math.min(index, length - 1);\r\n      const start = scale._startPixel;\r\n      const end = scale._endPixel;\r\n      const epsilon = 1e-6;\r\n      let lineValue = scale.getPixelForTick(validIndex);\r\n      let offset;\r\n      if (offsetGridLines) {\r\n        if (length === 1) {\r\n          offset = Math.max(lineValue - start, end - lineValue);\r\n        } else if (index === 0) {\r\n          offset = (scale.getPixelForTick(1) - lineValue) / 2;\r\n        } else {\r\n          offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n        }\r\n        lineValue += validIndex < index ? offset : -offset;\r\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\r\n          return;\r\n        }\r\n      }\r\n      return lineValue;\r\n    }\r\n    function garbageCollect(caches, length) {\r\n      each(caches, (cache) => {\r\n        const gc = cache.gc;\r\n        const gcLen = gc.length / 2;\r\n        let i;\r\n        if (gcLen > length) {\r\n          for (i = 0; i < gcLen; ++i) {\r\n            delete cache.data[gc[i]];\r\n          }\r\n          gc.splice(0, gcLen);\r\n        }\r\n      });\r\n    }\r\n    function getTickMarkLength(options) {\r\n      return options.drawTicks ? options.tickLength : 0;\r\n    }\r\n    function getTitleHeight(options, fallback) {\r\n      if (!options.display) {\r\n        return 0;\r\n      }\r\n      const font = toFont(options.font, fallback);\r\n      const padding = toPadding(options.padding);\r\n      const lines = isArray(options.text) ? options.text.length : 1;\r\n      return (lines * font.lineHeight) + padding.height;\r\n    }\r\n    function createScaleContext(parent, scale) {\r\n      return Object.assign(Object.create(parent), {\r\n        scale,\r\n        type: 'scale'\r\n      });\r\n    }\r\n    function createTickContext(parent, index, tick) {\r\n      return Object.assign(Object.create(parent), {\r\n        tick,\r\n        index,\r\n        type: 'tick'\r\n      });\r\n    }\r\n    function titleAlign(align, position, reverse) {\r\n      let ret = _toLeftRightCenter(align);\r\n      if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\r\n        ret = reverseAlign(ret);\r\n      }\r\n      return ret;\r\n    }\r\n    function titleArgs(scale, offset, position, align) {\r\n      const {top, left, bottom, right} = scale;\r\n      let rotation = 0;\r\n      let maxWidth, titleX, titleY;\r\n      if (scale.isHorizontal()) {\r\n        titleX = _alignStartEnd(align, left, right);\r\n        titleY = offsetFromEdge(scale, position, offset);\r\n        maxWidth = right - left;\r\n      } else {\r\n        titleX = offsetFromEdge(scale, position, offset);\r\n        titleY = _alignStartEnd(align, bottom, top);\r\n        rotation = position === 'left' ? -HALF_PI : HALF_PI;\r\n      }\r\n      return {titleX, titleY, maxWidth, rotation};\r\n    }\r\n    class Scale extends Element {\r\n      constructor(cfg) {\r\n        super();\r\n        this.id = cfg.id;\r\n        this.type = cfg.type;\r\n        this.options = undefined;\r\n        this.ctx = cfg.ctx;\r\n        this.chart = cfg.chart;\r\n        this.top = undefined;\r\n        this.bottom = undefined;\r\n        this.left = undefined;\r\n        this.right = undefined;\r\n        this.width = undefined;\r\n        this.height = undefined;\r\n        this._margins = {\r\n          left: 0,\r\n          right: 0,\r\n          top: 0,\r\n          bottom: 0\r\n        };\r\n        this.maxWidth = undefined;\r\n        this.maxHeight = undefined;\r\n        this.paddingTop = undefined;\r\n        this.paddingBottom = undefined;\r\n        this.paddingLeft = undefined;\r\n        this.paddingRight = undefined;\r\n        this.axis = undefined;\r\n        this.labelRotation = undefined;\r\n        this.min = undefined;\r\n        this.max = undefined;\r\n        this._range = undefined;\r\n        this.ticks = [];\r\n        this._gridLineItems = null;\r\n        this._labelItems = null;\r\n        this._labelSizes = null;\r\n        this._length = 0;\r\n        this._maxLength = 0;\r\n        this._longestTextCache = {};\r\n        this._startPixel = undefined;\r\n        this._endPixel = undefined;\r\n        this._reversePixels = false;\r\n        this._userMax = undefined;\r\n        this._userMin = undefined;\r\n        this._suggestedMax = undefined;\r\n        this._suggestedMin = undefined;\r\n        this._ticksLength = 0;\r\n        this._borderValue = 0;\r\n        this._cache = {};\r\n        this._dataLimitsCached = false;\r\n        this.$context = undefined;\r\n      }\r\n      init(options) {\r\n        const me = this;\r\n        me.options = options.setContext(me.getContext());\r\n        me.axis = options.axis;\r\n        me._userMin = me.parse(options.min);\r\n        me._userMax = me.parse(options.max);\r\n        me._suggestedMin = me.parse(options.suggestedMin);\r\n        me._suggestedMax = me.parse(options.suggestedMax);\r\n      }\r\n      parse(raw, index) {\r\n        return raw;\r\n      }\r\n      getUserBounds() {\r\n        let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\r\n        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\r\n        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\r\n        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\r\n        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\r\n        return {\r\n          min: finiteOrDefault(_userMin, _suggestedMin),\r\n          max: finiteOrDefault(_userMax, _suggestedMax),\r\n          minDefined: isNumberFinite(_userMin),\r\n          maxDefined: isNumberFinite(_userMax)\r\n        };\r\n      }\r\n      getMinMax(canStack) {\r\n        const me = this;\r\n        let {min, max, minDefined, maxDefined} = me.getUserBounds();\r\n        let range;\r\n        if (minDefined && maxDefined) {\r\n          return {min, max};\r\n        }\r\n        const metas = me.getMatchingVisibleMetas();\r\n        for (let i = 0, ilen = metas.length; i < ilen; ++i) {\r\n          range = metas[i].controller.getMinMax(me, canStack);\r\n          if (!minDefined) {\r\n            min = Math.min(min, range.min);\r\n          }\r\n          if (!maxDefined) {\r\n            max = Math.max(max, range.max);\r\n          }\r\n        }\r\n        return {\r\n          min: finiteOrDefault(min, finiteOrDefault(max, min)),\r\n          max: finiteOrDefault(max, finiteOrDefault(min, max))\r\n        };\r\n      }\r\n      getPadding() {\r\n        const me = this;\r\n        return {\r\n          left: me.paddingLeft || 0,\r\n          top: me.paddingTop || 0,\r\n          right: me.paddingRight || 0,\r\n          bottom: me.paddingBottom || 0\r\n        };\r\n      }\r\n      getTicks() {\r\n        return this.ticks;\r\n      }\r\n      getLabels() {\r\n        const data = this.chart.data;\r\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\r\n      }\r\n      beforeLayout() {\r\n        this._cache = {};\r\n        this._dataLimitsCached = false;\r\n      }\r\n      beforeUpdate() {\r\n        callback(this.options.beforeUpdate, [this]);\r\n      }\r\n      update(maxWidth, maxHeight, margins) {\r\n        const me = this;\r\n        const tickOpts = me.options.ticks;\r\n        const sampleSize = tickOpts.sampleSize;\r\n        me.beforeUpdate();\r\n        me.maxWidth = maxWidth;\r\n        me.maxHeight = maxHeight;\r\n        me._margins = margins = Object.assign({\r\n          left: 0,\r\n          right: 0,\r\n          top: 0,\r\n          bottom: 0\r\n        }, margins);\r\n        me.ticks = null;\r\n        me._labelSizes = null;\r\n        me._gridLineItems = null;\r\n        me._labelItems = null;\r\n        me.beforeSetDimensions();\r\n        me.setDimensions();\r\n        me.afterSetDimensions();\r\n        me._maxLength = me.isHorizontal()\r\n          ? me.width + margins.left + margins.right\r\n          : me.height + margins.top + margins.bottom;\r\n        if (!me._dataLimitsCached) {\r\n          me.beforeDataLimits();\r\n          me.determineDataLimits();\r\n          me.afterDataLimits();\r\n          me._range = _addGrace(me, me.options.grace);\r\n          me._dataLimitsCached = true;\r\n        }\r\n        me.beforeBuildTicks();\r\n        me.ticks = me.buildTicks() || [];\r\n        me.afterBuildTicks();\r\n        const samplingEnabled = sampleSize < me.ticks.length;\r\n        me._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);\r\n        me.configure();\r\n        me.beforeCalculateLabelRotation();\r\n        me.calculateLabelRotation();\r\n        me.afterCalculateLabelRotation();\r\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\r\n          me.ticks = autoSkip(me, me.ticks);\r\n          me._labelSizes = null;\r\n        }\r\n        if (samplingEnabled) {\r\n          me._convertTicksToLabels(me.ticks);\r\n        }\r\n        me.beforeFit();\r\n        me.fit();\r\n        me.afterFit();\r\n        me.afterUpdate();\r\n      }\r\n      configure() {\r\n        const me = this;\r\n        let reversePixels = me.options.reverse;\r\n        let startPixel, endPixel;\r\n        if (me.isHorizontal()) {\r\n          startPixel = me.left;\r\n          endPixel = me.right;\r\n        } else {\r\n          startPixel = me.top;\r\n          endPixel = me.bottom;\r\n          reversePixels = !reversePixels;\r\n        }\r\n        me._startPixel = startPixel;\r\n        me._endPixel = endPixel;\r\n        me._reversePixels = reversePixels;\r\n        me._length = endPixel - startPixel;\r\n        me._alignToPixels = me.options.alignToPixels;\r\n      }\r\n      afterUpdate() {\r\n        callback(this.options.afterUpdate, [this]);\r\n      }\r\n      beforeSetDimensions() {\r\n        callback(this.options.beforeSetDimensions, [this]);\r\n      }\r\n      setDimensions() {\r\n        const me = this;\r\n        if (me.isHorizontal()) {\r\n          me.width = me.maxWidth;\r\n          me.left = 0;\r\n          me.right = me.width;\r\n        } else {\r\n          me.height = me.maxHeight;\r\n          me.top = 0;\r\n          me.bottom = me.height;\r\n        }\r\n        me.paddingLeft = 0;\r\n        me.paddingTop = 0;\r\n        me.paddingRight = 0;\r\n        me.paddingBottom = 0;\r\n      }\r\n      afterSetDimensions() {\r\n        callback(this.options.afterSetDimensions, [this]);\r\n      }\r\n      _callHooks(name) {\r\n        const me = this;\r\n        me.chart.notifyPlugins(name, me.getContext());\r\n        callback(me.options[name], [me]);\r\n      }\r\n      beforeDataLimits() {\r\n        this._callHooks('beforeDataLimits');\r\n      }\r\n      determineDataLimits() {}\r\n      afterDataLimits() {\r\n        this._callHooks('afterDataLimits');\r\n      }\r\n      beforeBuildTicks() {\r\n        this._callHooks('beforeBuildTicks');\r\n      }\r\n      buildTicks() {\r\n        return [];\r\n      }\r\n      afterBuildTicks() {\r\n        this._callHooks('afterBuildTicks');\r\n      }\r\n      beforeTickToLabelConversion() {\r\n        callback(this.options.beforeTickToLabelConversion, [this]);\r\n      }\r\n      generateTickLabels(ticks) {\r\n        const me = this;\r\n        const tickOpts = me.options.ticks;\r\n        let i, ilen, tick;\r\n        for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n          tick = ticks[i];\r\n          tick.label = callback(tickOpts.callback, [tick.value, i, ticks], me);\r\n        }\r\n        for (i = 0; i < ilen; i++) {\r\n          if (isNullOrUndef(ticks[i].label)) {\r\n            ticks.splice(i, 1);\r\n            ilen--;\r\n            i--;\r\n          }\r\n        }\r\n      }\r\n      afterTickToLabelConversion() {\r\n        callback(this.options.afterTickToLabelConversion, [this]);\r\n      }\r\n      beforeCalculateLabelRotation() {\r\n        callback(this.options.beforeCalculateLabelRotation, [this]);\r\n      }\r\n      calculateLabelRotation() {\r\n        const me = this;\r\n        const options = me.options;\r\n        const tickOpts = options.ticks;\r\n        const numTicks = me.ticks.length;\r\n        const minRotation = tickOpts.minRotation || 0;\r\n        const maxRotation = tickOpts.maxRotation;\r\n        let labelRotation = minRotation;\r\n        let tickWidth, maxHeight, maxLabelDiagonal;\r\n        if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {\r\n          me.labelRotation = minRotation;\r\n          return;\r\n        }\r\n        const labelSizes = me._getLabelSizes();\r\n        const maxLabelWidth = labelSizes.widest.width;\r\n        const maxLabelHeight = labelSizes.highest.height;\r\n        const maxWidth = _limitValue(me.chart.width - maxLabelWidth, 0, me.maxWidth);\r\n        tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);\r\n        if (maxLabelWidth + 6 > tickWidth) {\r\n          tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n          maxHeight = me.maxHeight - getTickMarkLength(options.grid)\r\n                    - tickOpts.padding - getTitleHeight(options.title, me.chart.options.font);\r\n          maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n          labelRotation = toDegrees(Math.min(\r\n            Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),\r\n            Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)\r\n          ));\r\n          labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n        }\r\n        me.labelRotation = labelRotation;\r\n      }\r\n      afterCalculateLabelRotation() {\r\n        callback(this.options.afterCalculateLabelRotation, [this]);\r\n      }\r\n      beforeFit() {\r\n        callback(this.options.beforeFit, [this]);\r\n      }\r\n      fit() {\r\n        const me = this;\r\n        const minSize = {\r\n          width: 0,\r\n          height: 0\r\n        };\r\n        const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = me;\r\n        const display = me._isVisible();\r\n        const isHorizontal = me.isHorizontal();\r\n        if (display) {\r\n          const titleHeight = getTitleHeight(titleOpts, chart.options.font);\r\n          if (isHorizontal) {\r\n            minSize.width = me.maxWidth;\r\n            minSize.height = getTickMarkLength(gridOpts) + titleHeight;\r\n          } else {\r\n            minSize.height = me.maxHeight;\r\n            minSize.width = getTickMarkLength(gridOpts) + titleHeight;\r\n          }\r\n          if (tickOpts.display && me.ticks.length) {\r\n            const {first, last, widest, highest} = me._getLabelSizes();\r\n            const tickPadding = tickOpts.padding * 2;\r\n            const angleRadians = toRadians(me.labelRotation);\r\n            const cos = Math.cos(angleRadians);\r\n            const sin = Math.sin(angleRadians);\r\n            if (isHorizontal) {\r\n              const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\r\n              minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\r\n            } else {\r\n              const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\r\n              minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth + tickPadding);\r\n            }\r\n            me._calculatePadding(first, last, sin, cos);\r\n          }\r\n        }\r\n        me._handleMargins();\r\n        if (isHorizontal) {\r\n          me.width = me._length = chart.width - me._margins.left - me._margins.right;\r\n          me.height = minSize.height;\r\n        } else {\r\n          me.width = minSize.width;\r\n          me.height = me._length = chart.height - me._margins.top - me._margins.bottom;\r\n        }\r\n      }\r\n      _calculatePadding(first, last, sin, cos) {\r\n        const me = this;\r\n        const {ticks: {align, padding}, position} = me.options;\r\n        const isRotated = me.labelRotation !== 0;\r\n        const labelsBelowTicks = position !== 'top' && me.axis === 'x';\r\n        if (me.isHorizontal()) {\r\n          const offsetLeft = me.getPixelForTick(0) - me.left;\r\n          const offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);\r\n          let paddingLeft = 0;\r\n          let paddingRight = 0;\r\n          if (isRotated) {\r\n            if (labelsBelowTicks) {\r\n              paddingLeft = cos * first.width;\r\n              paddingRight = sin * last.height;\r\n            } else {\r\n              paddingLeft = sin * first.height;\r\n              paddingRight = cos * last.width;\r\n            }\r\n          } else if (align === 'start') {\r\n            paddingRight = last.width;\r\n          } else if (align === 'end') {\r\n            paddingLeft = first.width;\r\n          } else {\r\n            paddingLeft = first.width / 2;\r\n            paddingRight = last.width / 2;\r\n          }\r\n          me.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * me.width / (me.width - offsetLeft), 0);\r\n          me.paddingRight = Math.max((paddingRight - offsetRight + padding) * me.width / (me.width - offsetRight), 0);\r\n        } else {\r\n          let paddingTop = last.height / 2;\r\n          let paddingBottom = first.height / 2;\r\n          if (align === 'start') {\r\n            paddingTop = 0;\r\n            paddingBottom = first.height;\r\n          } else if (align === 'end') {\r\n            paddingTop = last.height;\r\n            paddingBottom = 0;\r\n          }\r\n          me.paddingTop = paddingTop + padding;\r\n          me.paddingBottom = paddingBottom + padding;\r\n        }\r\n      }\r\n      _handleMargins() {\r\n        const me = this;\r\n        if (me._margins) {\r\n          me._margins.left = Math.max(me.paddingLeft, me._margins.left);\r\n          me._margins.top = Math.max(me.paddingTop, me._margins.top);\r\n          me._margins.right = Math.max(me.paddingRight, me._margins.right);\r\n          me._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);\r\n        }\r\n      }\r\n      afterFit() {\r\n        callback(this.options.afterFit, [this]);\r\n      }\r\n      isHorizontal() {\r\n        const {axis, position} = this.options;\r\n        return position === 'top' || position === 'bottom' || axis === 'x';\r\n      }\r\n      isFullSize() {\r\n        return this.options.fullSize;\r\n      }\r\n      _convertTicksToLabels(ticks) {\r\n        const me = this;\r\n        me.beforeTickToLabelConversion();\r\n        me.generateTickLabels(ticks);\r\n        me.afterTickToLabelConversion();\r\n      }\r\n      _getLabelSizes() {\r\n        const me = this;\r\n        let labelSizes = me._labelSizes;\r\n        if (!labelSizes) {\r\n          const sampleSize = me.options.ticks.sampleSize;\r\n          let ticks = me.ticks;\r\n          if (sampleSize < ticks.length) {\r\n            ticks = sample(ticks, sampleSize);\r\n          }\r\n          me._labelSizes = labelSizes = me._computeLabelSizes(ticks, ticks.length);\r\n        }\r\n        return labelSizes;\r\n      }\r\n      _computeLabelSizes(ticks, length) {\r\n        const {ctx, _longestTextCache: caches} = this;\r\n        const widths = [];\r\n        const heights = [];\r\n        let widestLabelSize = 0;\r\n        let highestLabelSize = 0;\r\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\r\n        for (i = 0; i < length; ++i) {\r\n          label = ticks[i].label;\r\n          tickFont = this._resolveTickFontOptions(i);\r\n          ctx.font = fontString = tickFont.string;\r\n          cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n          lineHeight = tickFont.lineHeight;\r\n          width = height = 0;\r\n          if (!isNullOrUndef(label) && !isArray(label)) {\r\n            width = _measureText(ctx, cache.data, cache.gc, width, label);\r\n            height = lineHeight;\r\n          } else if (isArray(label)) {\r\n            for (j = 0, jlen = label.length; j < jlen; ++j) {\r\n              nestedLabel = label[j];\r\n              if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\r\n                width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\r\n                height += lineHeight;\r\n              }\r\n            }\r\n          }\r\n          widths.push(width);\r\n          heights.push(height);\r\n          widestLabelSize = Math.max(width, widestLabelSize);\r\n          highestLabelSize = Math.max(height, highestLabelSize);\r\n        }\r\n        garbageCollect(caches, length);\r\n        const widest = widths.indexOf(widestLabelSize);\r\n        const highest = heights.indexOf(highestLabelSize);\r\n        const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\r\n        return {\r\n          first: valueAt(0),\r\n          last: valueAt(length - 1),\r\n          widest: valueAt(widest),\r\n          highest: valueAt(highest),\r\n          widths,\r\n          heights,\r\n        };\r\n      }\r\n      getLabelForValue(value) {\r\n        return value;\r\n      }\r\n      getPixelForValue(value, index) {\r\n        return NaN;\r\n      }\r\n      getValueForPixel(pixel) {}\r\n      getPixelForTick(index) {\r\n        const ticks = this.ticks;\r\n        if (index < 0 || index > ticks.length - 1) {\r\n          return null;\r\n        }\r\n        return this.getPixelForValue(ticks[index].value);\r\n      }\r\n      getPixelForDecimal(decimal) {\r\n        const me = this;\r\n        if (me._reversePixels) {\r\n          decimal = 1 - decimal;\r\n        }\r\n        const pixel = me._startPixel + decimal * me._length;\r\n        return _int16Range(me._alignToPixels ? _alignPixel(me.chart, pixel, 0) : pixel);\r\n      }\r\n      getDecimalForPixel(pixel) {\r\n        const decimal = (pixel - this._startPixel) / this._length;\r\n        return this._reversePixels ? 1 - decimal : decimal;\r\n      }\r\n      getBasePixel() {\r\n        return this.getPixelForValue(this.getBaseValue());\r\n      }\r\n      getBaseValue() {\r\n        const {min, max} = this;\r\n        return min < 0 && max < 0 ? max :\r\n          min > 0 && max > 0 ? min :\r\n          0;\r\n      }\r\n      getContext(index) {\r\n        const me = this;\r\n        const ticks = me.ticks || [];\r\n        if (index >= 0 && index < ticks.length) {\r\n          const tick = ticks[index];\r\n          return tick.$context ||\r\n                    (tick.$context = createTickContext(me.getContext(), index, tick));\r\n        }\r\n        return me.$context ||\r\n                (me.$context = createScaleContext(me.chart.getContext(), me));\r\n      }\r\n      _tickSize() {\r\n        const me = this;\r\n        const optionTicks = me.options.ticks;\r\n        const rot = toRadians(me.labelRotation);\r\n        const cos = Math.abs(Math.cos(rot));\r\n        const sin = Math.abs(Math.sin(rot));\r\n        const labelSizes = me._getLabelSizes();\r\n        const padding = optionTicks.autoSkipPadding || 0;\r\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\r\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\r\n        return me.isHorizontal()\r\n          ? h * cos > w * sin ? w / cos : h / sin\r\n          : h * sin < w * cos ? h / cos : w / sin;\r\n      }\r\n      _isVisible() {\r\n        const display = this.options.display;\r\n        if (display !== 'auto') {\r\n          return !!display;\r\n        }\r\n        return this.getMatchingVisibleMetas().length > 0;\r\n      }\r\n      _computeGridLineItems(chartArea) {\r\n        const me = this;\r\n        const axis = me.axis;\r\n        const chart = me.chart;\r\n        const options = me.options;\r\n        const {grid, position} = options;\r\n        const offset = grid.offset;\r\n        const isHorizontal = me.isHorizontal();\r\n        const ticks = me.ticks;\r\n        const ticksLength = ticks.length + (offset ? 1 : 0);\r\n        const tl = getTickMarkLength(grid);\r\n        const items = [];\r\n        const borderOpts = grid.setContext(me.getContext());\r\n        const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\r\n        const axisHalfWidth = axisWidth / 2;\r\n        const alignBorderValue = function(pixel) {\r\n          return _alignPixel(chart, pixel, axisWidth);\r\n        };\r\n        let borderValue, i, lineValue, alignedLineValue;\r\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\r\n        if (position === 'top') {\r\n          borderValue = alignBorderValue(me.bottom);\r\n          ty1 = me.bottom - tl;\r\n          ty2 = borderValue - axisHalfWidth;\r\n          y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\r\n          y2 = chartArea.bottom;\r\n        } else if (position === 'bottom') {\r\n          borderValue = alignBorderValue(me.top);\r\n          y1 = chartArea.top;\r\n          y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n          ty1 = borderValue + axisHalfWidth;\r\n          ty2 = me.top + tl;\r\n        } else if (position === 'left') {\r\n          borderValue = alignBorderValue(me.right);\r\n          tx1 = me.right - tl;\r\n          tx2 = borderValue - axisHalfWidth;\r\n          x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\r\n          x2 = chartArea.right;\r\n        } else if (position === 'right') {\r\n          borderValue = alignBorderValue(me.left);\r\n          x1 = chartArea.left;\r\n          x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\r\n          tx1 = borderValue + axisHalfWidth;\r\n          tx2 = me.left + tl;\r\n        } else if (axis === 'x') {\r\n          if (position === 'center') {\r\n            borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\r\n          } else if (isObject(position)) {\r\n            const positionAxisID = Object.keys(position)[0];\r\n            const value = position[positionAxisID];\r\n            borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\r\n          }\r\n          y1 = chartArea.top;\r\n          y2 = chartArea.bottom;\r\n          ty1 = borderValue + axisHalfWidth;\r\n          ty2 = ty1 + tl;\r\n        } else if (axis === 'y') {\r\n          if (position === 'center') {\r\n            borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\r\n          } else if (isObject(position)) {\r\n            const positionAxisID = Object.keys(position)[0];\r\n            const value = position[positionAxisID];\r\n            borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));\r\n          }\r\n          tx1 = borderValue - axisHalfWidth;\r\n          tx2 = tx1 - tl;\r\n          x1 = chartArea.left;\r\n          x2 = chartArea.right;\r\n        }\r\n        for (i = 0; i < ticksLength; ++i) {\r\n          const optsAtIndex = grid.setContext(me.getContext(i));\r\n          const lineWidth = optsAtIndex.lineWidth;\r\n          const lineColor = optsAtIndex.color;\r\n          const borderDash = grid.borderDash || [];\r\n          const borderDashOffset = optsAtIndex.borderDashOffset;\r\n          const tickWidth = optsAtIndex.tickWidth;\r\n          const tickColor = optsAtIndex.tickColor;\r\n          const tickBorderDash = optsAtIndex.tickBorderDash || [];\r\n          const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\r\n          lineValue = getPixelForGridLine(me, i, offset);\r\n          if (lineValue === undefined) {\r\n            continue;\r\n          }\r\n          alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\r\n          if (isHorizontal) {\r\n            tx1 = tx2 = x1 = x2 = alignedLineValue;\r\n          } else {\r\n            ty1 = ty2 = y1 = y2 = alignedLineValue;\r\n          }\r\n          items.push({\r\n            tx1,\r\n            ty1,\r\n            tx2,\r\n            ty2,\r\n            x1,\r\n            y1,\r\n            x2,\r\n            y2,\r\n            width: lineWidth,\r\n            color: lineColor,\r\n            borderDash,\r\n            borderDashOffset,\r\n            tickWidth,\r\n            tickColor,\r\n            tickBorderDash,\r\n            tickBorderDashOffset,\r\n          });\r\n        }\r\n        me._ticksLength = ticksLength;\r\n        me._borderValue = borderValue;\r\n        return items;\r\n      }\r\n      _computeLabelItems(chartArea) {\r\n        const me = this;\r\n        const axis = me.axis;\r\n        const options = me.options;\r\n        const {position, ticks: optionTicks} = options;\r\n        const isHorizontal = me.isHorizontal();\r\n        const ticks = me.ticks;\r\n        const {align, crossAlign, padding, mirror} = optionTicks;\r\n        const tl = getTickMarkLength(options.grid);\r\n        const tickAndPadding = tl + padding;\r\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\r\n        const rotation = -toRadians(me.labelRotation);\r\n        const items = [];\r\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n        let textBaseline = 'middle';\r\n        if (position === 'top') {\r\n          y = me.bottom - hTickAndPadding;\r\n          textAlign = me._getXAxisLabelAlignment();\r\n        } else if (position === 'bottom') {\r\n          y = me.top + hTickAndPadding;\r\n          textAlign = me._getXAxisLabelAlignment();\r\n        } else if (position === 'left') {\r\n          const ret = me._getYAxisLabelAlignment(tl);\r\n          textAlign = ret.textAlign;\r\n          x = ret.x;\r\n        } else if (position === 'right') {\r\n          const ret = me._getYAxisLabelAlignment(tl);\r\n          textAlign = ret.textAlign;\r\n          x = ret.x;\r\n        } else if (axis === 'x') {\r\n          if (position === 'center') {\r\n            y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\r\n          } else if (isObject(position)) {\r\n            const positionAxisID = Object.keys(position)[0];\r\n            const value = position[positionAxisID];\r\n            y = me.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\r\n          }\r\n          textAlign = me._getXAxisLabelAlignment();\r\n        } else if (axis === 'y') {\r\n          if (position === 'center') {\r\n            x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\r\n          } else if (isObject(position)) {\r\n            const positionAxisID = Object.keys(position)[0];\r\n            const value = position[positionAxisID];\r\n            x = me.chart.scales[positionAxisID].getPixelForValue(value);\r\n          }\r\n          textAlign = me._getYAxisLabelAlignment(tl).textAlign;\r\n        }\r\n        if (axis === 'y') {\r\n          if (align === 'start') {\r\n            textBaseline = 'top';\r\n          } else if (align === 'end') {\r\n            textBaseline = 'bottom';\r\n          }\r\n        }\r\n        const labelSizes = me._getLabelSizes();\r\n        for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n          tick = ticks[i];\r\n          label = tick.label;\r\n          const optsAtIndex = optionTicks.setContext(me.getContext(i));\r\n          pixel = me.getPixelForTick(i) + optionTicks.labelOffset;\r\n          font = me._resolveTickFontOptions(i);\r\n          lineHeight = font.lineHeight;\r\n          lineCount = isArray(label) ? label.length : 1;\r\n          const halfCount = lineCount / 2;\r\n          const color = optsAtIndex.color;\r\n          const strokeColor = optsAtIndex.textStrokeColor;\r\n          const strokeWidth = optsAtIndex.textStrokeWidth;\r\n          if (isHorizontal) {\r\n            x = pixel;\r\n            if (position === 'top') {\r\n              if (crossAlign === 'near' || rotation !== 0) {\r\n                textOffset = -lineCount * lineHeight + lineHeight / 2;\r\n              } else if (crossAlign === 'center') {\r\n                textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\r\n              } else {\r\n                textOffset = -labelSizes.highest.height + lineHeight / 2;\r\n              }\r\n            } else {\r\n              if (crossAlign === 'near' || rotation !== 0) {\r\n                textOffset = lineHeight / 2;\r\n              } else if (crossAlign === 'center') {\r\n                textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\r\n              } else {\r\n                textOffset = labelSizes.highest.height - lineCount * lineHeight;\r\n              }\r\n            }\r\n            if (mirror) {\r\n              textOffset *= -1;\r\n            }\r\n          } else {\r\n            y = pixel;\r\n            textOffset = (1 - lineCount) * lineHeight / 2;\r\n          }\r\n          let backdrop;\r\n          if (optsAtIndex.showLabelBackdrop) {\r\n            const labelPadding = toPadding(optsAtIndex.backdropPadding);\r\n            const height = labelSizes.heights[i];\r\n            const width = labelSizes.widths[i];\r\n            let top = y + textOffset - labelPadding.top;\r\n            let left = x - labelPadding.left;\r\n            switch (textBaseline) {\r\n            case 'middle':\r\n              top -= height / 2;\r\n              break;\r\n            case 'bottom':\r\n              top -= height;\r\n              break;\r\n            }\r\n            switch (textAlign) {\r\n            case 'center':\r\n              left -= width / 2;\r\n              break;\r\n            case 'right':\r\n              left -= width;\r\n              break;\r\n            }\r\n            backdrop = {\r\n              left,\r\n              top,\r\n              width: width + labelPadding.width,\r\n              height: height + labelPadding.height,\r\n              color: optsAtIndex.backdropColor,\r\n            };\r\n          }\r\n          items.push({\r\n            rotation,\r\n            label,\r\n            font,\r\n            color,\r\n            strokeColor,\r\n            strokeWidth,\r\n            textOffset,\r\n            textAlign,\r\n            textBaseline,\r\n            translation: [x, y],\r\n            backdrop,\r\n          });\r\n        }\r\n        return items;\r\n      }\r\n      _getXAxisLabelAlignment() {\r\n        const me = this;\r\n        const {position, ticks} = me.options;\r\n        const rotation = -toRadians(me.labelRotation);\r\n        if (rotation) {\r\n          return position === 'top' ? 'left' : 'right';\r\n        }\r\n        let align = 'center';\r\n        if (ticks.align === 'start') {\r\n          align = 'left';\r\n        } else if (ticks.align === 'end') {\r\n          align = 'right';\r\n        }\r\n        return align;\r\n      }\r\n      _getYAxisLabelAlignment(tl) {\r\n        const me = this;\r\n        const {position, ticks: {crossAlign, mirror, padding}} = me.options;\r\n        const labelSizes = me._getLabelSizes();\r\n        const tickAndPadding = tl + padding;\r\n        const widest = labelSizes.widest.width;\r\n        let textAlign;\r\n        let x;\r\n        if (position === 'left') {\r\n          if (mirror) {\r\n            textAlign = 'left';\r\n            x = me.right + padding;\r\n          } else {\r\n            x = me.right - tickAndPadding;\r\n            if (crossAlign === 'near') {\r\n              textAlign = 'right';\r\n            } else if (crossAlign === 'center') {\r\n              textAlign = 'center';\r\n              x -= (widest / 2);\r\n            } else {\r\n              textAlign = 'left';\r\n              x = me.left;\r\n            }\r\n          }\r\n        } else if (position === 'right') {\r\n          if (mirror) {\r\n            textAlign = 'right';\r\n            x = me.left + padding;\r\n          } else {\r\n            x = me.left + tickAndPadding;\r\n            if (crossAlign === 'near') {\r\n              textAlign = 'left';\r\n            } else if (crossAlign === 'center') {\r\n              textAlign = 'center';\r\n              x += widest / 2;\r\n            } else {\r\n              textAlign = 'right';\r\n              x = me.right;\r\n            }\r\n          }\r\n        } else {\r\n          textAlign = 'right';\r\n        }\r\n        return {textAlign, x};\r\n      }\r\n      _computeLabelArea() {\r\n        const me = this;\r\n        if (me.options.ticks.mirror) {\r\n          return;\r\n        }\r\n        const chart = me.chart;\r\n        const position = me.options.position;\r\n        if (position === 'left' || position === 'right') {\r\n          return {top: 0, left: me.left, bottom: chart.height, right: me.right};\r\n        } if (position === 'top' || position === 'bottom') {\r\n          return {top: me.top, left: 0, bottom: me.bottom, right: chart.width};\r\n        }\r\n      }\r\n      drawBackground() {\r\n        const {ctx, options: {backgroundColor}, left, top, width, height} = this;\r\n        if (backgroundColor) {\r\n          ctx.save();\r\n          ctx.fillStyle = backgroundColor;\r\n          ctx.fillRect(left, top, width, height);\r\n          ctx.restore();\r\n        }\r\n      }\r\n      getLineWidthForValue(value) {\r\n        const me = this;\r\n        const grid = me.options.grid;\r\n        if (!me._isVisible() || !grid.display) {\r\n          return 0;\r\n        }\r\n        const ticks = me.ticks;\r\n        const index = ticks.findIndex(t => t.value === value);\r\n        if (index >= 0) {\r\n          const opts = grid.setContext(me.getContext(index));\r\n          return opts.lineWidth;\r\n        }\r\n        return 0;\r\n      }\r\n      drawGrid(chartArea) {\r\n        const me = this;\r\n        const grid = me.options.grid;\r\n        const ctx = me.ctx;\r\n        const items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));\r\n        let i, ilen;\r\n        const drawLine = (p1, p2, style) => {\r\n          if (!style.width || !style.color) {\r\n            return;\r\n          }\r\n          ctx.save();\r\n          ctx.lineWidth = style.width;\r\n          ctx.strokeStyle = style.color;\r\n          ctx.setLineDash(style.borderDash || []);\r\n          ctx.lineDashOffset = style.borderDashOffset;\r\n          ctx.beginPath();\r\n          ctx.moveTo(p1.x, p1.y);\r\n          ctx.lineTo(p2.x, p2.y);\r\n          ctx.stroke();\r\n          ctx.restore();\r\n        };\r\n        if (grid.display) {\r\n          for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n            const item = items[i];\r\n            if (grid.drawOnChartArea) {\r\n              drawLine(\r\n                {x: item.x1, y: item.y1},\r\n                {x: item.x2, y: item.y2},\r\n                item\r\n              );\r\n            }\r\n            if (grid.drawTicks) {\r\n              drawLine(\r\n                {x: item.tx1, y: item.ty1},\r\n                {x: item.tx2, y: item.ty2},\r\n                {\r\n                  color: item.tickColor,\r\n                  width: item.tickWidth,\r\n                  borderDash: item.tickBorderDash,\r\n                  borderDashOffset: item.tickBorderDashOffset\r\n                }\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n      drawBorder() {\r\n        const me = this;\r\n        const {chart, ctx, options: {grid}} = me;\r\n        const borderOpts = grid.setContext(me.getContext());\r\n        const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\r\n        if (!axisWidth) {\r\n          return;\r\n        }\r\n        const lastLineWidth = grid.setContext(me.getContext(0)).lineWidth;\r\n        const borderValue = me._borderValue;\r\n        let x1, x2, y1, y2;\r\n        if (me.isHorizontal()) {\r\n          x1 = _alignPixel(chart, me.left, axisWidth) - axisWidth / 2;\r\n          x2 = _alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\r\n          y1 = y2 = borderValue;\r\n        } else {\r\n          y1 = _alignPixel(chart, me.top, axisWidth) - axisWidth / 2;\r\n          y2 = _alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\r\n          x1 = x2 = borderValue;\r\n        }\r\n        ctx.save();\r\n        ctx.lineWidth = borderOpts.borderWidth;\r\n        ctx.strokeStyle = borderOpts.borderColor;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        ctx.stroke();\r\n        ctx.restore();\r\n      }\r\n      drawLabels(chartArea) {\r\n        const me = this;\r\n        const optionTicks = me.options.ticks;\r\n        if (!optionTicks.display) {\r\n          return;\r\n        }\r\n        const ctx = me.ctx;\r\n        const area = me._computeLabelArea();\r\n        if (area) {\r\n          clipArea(ctx, area);\r\n        }\r\n        const items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));\r\n        let i, ilen;\r\n        for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n          const item = items[i];\r\n          const tickFont = item.font;\r\n          const label = item.label;\r\n          if (item.backdrop) {\r\n            ctx.fillStyle = item.backdrop.color;\r\n            ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\r\n          }\r\n          let y = item.textOffset;\r\n          renderText(ctx, label, 0, y, tickFont, item);\r\n        }\r\n        if (area) {\r\n          unclipArea(ctx);\r\n        }\r\n      }\r\n      drawTitle() {\r\n        const {ctx, options: {position, title, reverse}} = this;\r\n        if (!title.display) {\r\n          return;\r\n        }\r\n        const font = toFont(title.font);\r\n        const padding = toPadding(title.padding);\r\n        const align = title.align;\r\n        let offset = font.lineHeight / 2;\r\n        if (position === 'bottom') {\r\n          offset += padding.bottom;\r\n          if (isArray(title.text)) {\r\n            offset += font.lineHeight * (title.text.length - 1);\r\n          }\r\n        } else {\r\n          offset += padding.top;\r\n        }\r\n        const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\r\n        renderText(ctx, title.text, 0, 0, font, {\r\n          color: title.color,\r\n          maxWidth,\r\n          rotation,\r\n          textAlign: titleAlign(align, position, reverse),\r\n          textBaseline: 'middle',\r\n          translation: [titleX, titleY],\r\n        });\r\n      }\r\n      draw(chartArea) {\r\n        const me = this;\r\n        if (!me._isVisible()) {\r\n          return;\r\n        }\r\n        me.drawBackground();\r\n        me.drawGrid(chartArea);\r\n        me.drawBorder();\r\n        me.drawTitle();\r\n        me.drawLabels(chartArea);\r\n      }\r\n      _layers() {\r\n        const me = this;\r\n        const opts = me.options;\r\n        const tz = opts.ticks && opts.ticks.z || 0;\r\n        const gz = opts.grid && opts.grid.z || 0;\r\n        if (!me._isVisible() || me.draw !== Scale.prototype.draw) {\r\n          return [{\r\n            z: tz,\r\n            draw(chartArea) {\r\n              me.draw(chartArea);\r\n            }\r\n          }];\r\n        }\r\n        return [{\r\n          z: gz,\r\n          draw(chartArea) {\r\n            me.drawBackground();\r\n            me.drawGrid(chartArea);\r\n            me.drawTitle();\r\n          }\r\n        }, {\r\n          z: gz + 1,\r\n          draw() {\r\n            me.drawBorder();\r\n          }\r\n        }, {\r\n          z: tz,\r\n          draw(chartArea) {\r\n            me.drawLabels(chartArea);\r\n          }\r\n        }];\r\n      }\r\n      getMatchingVisibleMetas(type) {\r\n        const me = this;\r\n        const metas = me.chart.getSortedVisibleDatasetMetas();\r\n        const axisID = me.axis + 'AxisID';\r\n        const result = [];\r\n        let i, ilen;\r\n        for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n          const meta = metas[i];\r\n          if (meta[axisID] === me.id && (!type || meta.type === type)) {\r\n            result.push(meta);\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      _resolveTickFontOptions(index) {\r\n        const opts = this.options.ticks.setContext(this.getContext(index));\r\n        return toFont(opts.font);\r\n      }\r\n      _maxDigits() {\r\n        const me = this;\r\n        const fontSize = me._resolveTickFontOptions(0).lineHeight;\r\n        return (me.isHorizontal() ? me.width : me.height) / fontSize;\r\n      }\r\n    }\r\n    \r\n    function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\r\n      if (!defined(fallback)) {\r\n        fallback = _resolve('_fallback', scopes);\r\n      }\r\n      const cache = {\r\n        [Symbol.toStringTag]: 'Object',\r\n        _cacheable: true,\r\n        _scopes: scopes,\r\n        _rootScopes: rootScopes,\r\n        _fallback: fallback,\r\n        _getTarget: getTarget,\r\n        override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\r\n      };\r\n      return new Proxy(cache, {\r\n        deleteProperty(target, prop) {\r\n          delete target[prop];\r\n          delete target._keys;\r\n          delete scopes[0][prop];\r\n          return true;\r\n        },\r\n        get(target, prop) {\r\n          return _cached(target, prop,\r\n            () => _resolveWithPrefixes(prop, prefixes, scopes, target));\r\n        },\r\n        getOwnPropertyDescriptor(target, prop) {\r\n          return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\r\n        },\r\n        getPrototypeOf() {\r\n          return Reflect.getPrototypeOf(scopes[0]);\r\n        },\r\n        has(target, prop) {\r\n          return getKeysFromAllScopes(target).includes(prop);\r\n        },\r\n        ownKeys(target) {\r\n          return getKeysFromAllScopes(target);\r\n        },\r\n        set(target, prop, value) {\r\n          const storage = target._storage || (target._storage = getTarget());\r\n          storage[prop] = value;\r\n          delete target[prop];\r\n          delete target._keys;\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n    function _attachContext(proxy, context, subProxy, descriptorDefaults) {\r\n      const cache = {\r\n        _cacheable: false,\r\n        _proxy: proxy,\r\n        _context: context,\r\n        _subProxy: subProxy,\r\n        _stack: new Set(),\r\n        _descriptors: _descriptors(proxy, descriptorDefaults),\r\n        setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\r\n        override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\r\n      };\r\n      return new Proxy(cache, {\r\n        deleteProperty(target, prop) {\r\n          delete target[prop];\r\n          delete proxy[prop];\r\n          return true;\r\n        },\r\n        get(target, prop, receiver) {\r\n          return _cached(target, prop,\r\n            () => _resolveWithContext(target, prop, receiver));\r\n        },\r\n        getOwnPropertyDescriptor(target, prop) {\r\n          return target._descriptors.allKeys\r\n            ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\r\n            : Reflect.getOwnPropertyDescriptor(proxy, prop);\r\n        },\r\n        getPrototypeOf() {\r\n          return Reflect.getPrototypeOf(proxy);\r\n        },\r\n        has(target, prop) {\r\n          return Reflect.has(proxy, prop);\r\n        },\r\n        ownKeys() {\r\n          return Reflect.ownKeys(proxy);\r\n        },\r\n        set(target, prop, value) {\r\n          proxy[prop] = value;\r\n          delete target[prop];\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n    function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\r\n      const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\r\n      return {\r\n        allKeys: _allKeys,\r\n        scriptable: _scriptable,\r\n        indexable: _indexable,\r\n        isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\r\n        isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\r\n      };\r\n    }\r\n    const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\r\n    const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters';\r\n    function _cached(target, prop, resolve) {\r\n      let value = target[prop];\r\n      if (defined(value)) {\r\n        return value;\r\n      }\r\n      value = resolve();\r\n      if (defined(value)) {\r\n        target[prop] = value;\r\n      }\r\n      return value;\r\n    }\r\n    function _resolveWithContext(target, prop, receiver) {\r\n      const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n      let value = _proxy[prop];\r\n      if (isFunction(value) && descriptors.isScriptable(prop)) {\r\n        value = _resolveScriptable(prop, value, target, receiver);\r\n      }\r\n      if (isArray(value) && value.length) {\r\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\r\n      }\r\n      if (needsSubResolver(prop, value)) {\r\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\r\n      }\r\n      return value;\r\n    }\r\n    function _resolveScriptable(prop, value, target, receiver) {\r\n      const {_proxy, _context, _subProxy, _stack} = target;\r\n      if (_stack.has(prop)) {\r\n        throw new Error('Recursion detected: ' + [..._stack].join('->') + '->' + prop);\r\n      }\r\n      _stack.add(prop);\r\n      value = value(_context, _subProxy || receiver);\r\n      _stack.delete(prop);\r\n      if (isObject(value)) {\r\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\r\n      }\r\n      return value;\r\n    }\r\n    function _resolveArray(prop, value, target, isIndexable) {\r\n      const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n      if (defined(_context.index) && isIndexable(prop)) {\r\n        value = value[_context.index % value.length];\r\n      } else if (isObject(value[0])) {\r\n        const arr = value;\r\n        const scopes = _proxy._scopes.filter(s => s !== arr);\r\n        value = [];\r\n        for (const item of arr) {\r\n          const resolver = createSubResolver(scopes, _proxy, prop, item);\r\n          value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n    function resolveFallback(fallback, prop, value) {\r\n      return isFunction(fallback) ? fallback(prop, value) : fallback;\r\n    }\r\n    const getScope = (key, parent) => key === true ? parent\r\n      : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\r\n    function addScopes(set, parentScopes, key, parentFallback) {\r\n      for (const parent of parentScopes) {\r\n        const scope = getScope(key, parent);\r\n        if (scope) {\r\n          set.add(scope);\r\n          const fallback = resolveFallback(scope._fallback, key, scope);\r\n          if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\r\n            return fallback;\r\n          }\r\n        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\r\n          return null;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n    function createSubResolver(parentScopes, resolver, prop, value) {\r\n      const rootScopes = resolver._rootScopes;\r\n      const fallback = resolveFallback(resolver._fallback, prop, value);\r\n      const allScopes = [...parentScopes, ...rootScopes];\r\n      const set = new Set();\r\n      set.add(value);\r\n      let key = addScopesFromKey(set, allScopes, prop, fallback || prop);\r\n      if (key === null) {\r\n        return false;\r\n      }\r\n      if (defined(fallback) && fallback !== prop) {\r\n        key = addScopesFromKey(set, allScopes, fallback, key);\r\n        if (key === null) {\r\n          return false;\r\n        }\r\n      }\r\n      return _createResolver([...set], [''], rootScopes, fallback,\r\n        () => subGetTarget(resolver, prop, value));\r\n    }\r\n    function addScopesFromKey(set, allScopes, key, fallback) {\r\n      while (key) {\r\n        key = addScopes(set, allScopes, key, fallback);\r\n      }\r\n      return key;\r\n    }\r\n    function subGetTarget(resolver, prop, value) {\r\n      const parent = resolver._getTarget();\r\n      if (!(prop in parent)) {\r\n        parent[prop] = {};\r\n      }\r\n      const target = parent[prop];\r\n      if (isArray(target) && isObject(value)) {\r\n        return value;\r\n      }\r\n      return target;\r\n    }\r\n    function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\r\n      let value;\r\n      for (const prefix of prefixes) {\r\n        value = _resolve(readKey(prefix, prop), scopes);\r\n        if (defined(value)) {\r\n          return needsSubResolver(prop, value)\r\n            ? createSubResolver(scopes, proxy, prop, value)\r\n            : value;\r\n        }\r\n      }\r\n    }\r\n    function _resolve(key, scopes) {\r\n      for (const scope of scopes) {\r\n        if (!scope) {\r\n          continue;\r\n        }\r\n        const value = scope[key];\r\n        if (defined(value)) {\r\n          return value;\r\n        }\r\n      }\r\n    }\r\n    function getKeysFromAllScopes(target) {\r\n      let keys = target._keys;\r\n      if (!keys) {\r\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\r\n      }\r\n      return keys;\r\n    }\r\n    function resolveKeysFromAllScopes(scopes) {\r\n      const set = new Set();\r\n      for (const scope of scopes) {\r\n        for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\r\n          set.add(key);\r\n        }\r\n      }\r\n      return [...set];\r\n    }\r\n    \r\n    const EPSILON = Number.EPSILON || 1e-14;\r\n    const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\r\n    const getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\r\n    function splineCurve(firstPoint, middlePoint, afterPoint, t) {\r\n      const previous = firstPoint.skip ? middlePoint : firstPoint;\r\n      const current = middlePoint;\r\n      const next = afterPoint.skip ? middlePoint : afterPoint;\r\n      const d01 = distanceBetweenPoints(current, previous);\r\n      const d12 = distanceBetweenPoints(next, current);\r\n      let s01 = d01 / (d01 + d12);\r\n      let s12 = d12 / (d01 + d12);\r\n      s01 = isNaN(s01) ? 0 : s01;\r\n      s12 = isNaN(s12) ? 0 : s12;\r\n      const fa = t * s01;\r\n      const fb = t * s12;\r\n      return {\r\n        previous: {\r\n          x: current.x - fa * (next.x - previous.x),\r\n          y: current.y - fa * (next.y - previous.y)\r\n        },\r\n        next: {\r\n          x: current.x + fb * (next.x - previous.x),\r\n          y: current.y + fb * (next.y - previous.y)\r\n        }\r\n      };\r\n    }\r\n    function monotoneAdjust(points, deltaK, mK) {\r\n      const pointsLen = points.length;\r\n      let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\r\n      let pointAfter = getPoint(points, 0);\r\n      for (let i = 0; i < pointsLen - 1; ++i) {\r\n        pointCurrent = pointAfter;\r\n        pointAfter = getPoint(points, i + 1);\r\n        if (!pointCurrent || !pointAfter) {\r\n          continue;\r\n        }\r\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\r\n          mK[i] = mK[i + 1] = 0;\r\n          continue;\r\n        }\r\n        alphaK = mK[i] / deltaK[i];\r\n        betaK = mK[i + 1] / deltaK[i];\r\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n        if (squaredMagnitude <= 9) {\r\n          continue;\r\n        }\r\n        tauK = 3 / Math.sqrt(squaredMagnitude);\r\n        mK[i] = alphaK * tauK * deltaK[i];\r\n        mK[i + 1] = betaK * tauK * deltaK[i];\r\n      }\r\n    }\r\n    function monotoneCompute(points, mK, indexAxis = 'x') {\r\n      const valueAxis = getValueAxis(indexAxis);\r\n      const pointsLen = points.length;\r\n      let delta, pointBefore, pointCurrent;\r\n      let pointAfter = getPoint(points, 0);\r\n      for (let i = 0; i < pointsLen; ++i) {\r\n        pointBefore = pointCurrent;\r\n        pointCurrent = pointAfter;\r\n        pointAfter = getPoint(points, i + 1);\r\n        if (!pointCurrent) {\r\n          continue;\r\n        }\r\n        const iPixel = pointCurrent[indexAxis];\r\n        const vPixel = pointCurrent[valueAxis];\r\n        if (pointBefore) {\r\n          delta = (iPixel - pointBefore[indexAxis]) / 3;\r\n          pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\r\n          pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\r\n        }\r\n        if (pointAfter) {\r\n          delta = (pointAfter[indexAxis] - iPixel) / 3;\r\n          pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\r\n          pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\r\n        }\r\n      }\r\n    }\r\n    function splineCurveMonotone(points, indexAxis = 'x') {\r\n      const valueAxis = getValueAxis(indexAxis);\r\n      const pointsLen = points.length;\r\n      const deltaK = Array(pointsLen).fill(0);\r\n      const mK = Array(pointsLen);\r\n      let i, pointBefore, pointCurrent;\r\n      let pointAfter = getPoint(points, 0);\r\n      for (i = 0; i < pointsLen; ++i) {\r\n        pointBefore = pointCurrent;\r\n        pointCurrent = pointAfter;\r\n        pointAfter = getPoint(points, i + 1);\r\n        if (!pointCurrent) {\r\n          continue;\r\n        }\r\n        if (pointAfter) {\r\n          const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\r\n          deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\r\n        }\r\n        mK[i] = !pointBefore ? deltaK[i]\r\n          : !pointAfter ? deltaK[i - 1]\r\n          : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\r\n          : (deltaK[i - 1] + deltaK[i]) / 2;\r\n      }\r\n      monotoneAdjust(points, deltaK, mK);\r\n      monotoneCompute(points, mK, indexAxis);\r\n    }\r\n    function capControlPoint(pt, min, max) {\r\n      return Math.max(Math.min(pt, max), min);\r\n    }\r\n    function capBezierPoints(points, area) {\r\n      let i, ilen, point, inArea, inAreaPrev;\r\n      let inAreaNext = _isPointInArea(points[0], area);\r\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n        inAreaPrev = inArea;\r\n        inArea = inAreaNext;\r\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\r\n        if (!inArea) {\r\n          continue;\r\n        }\r\n        point = points[i];\r\n        if (inAreaPrev) {\r\n          point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\r\n          point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\r\n        }\r\n        if (inAreaNext) {\r\n          point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\r\n          point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\r\n        }\r\n      }\r\n    }\r\n    function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\r\n      let i, ilen, point, controlPoints;\r\n      if (options.spanGaps) {\r\n        points = points.filter((pt) => !pt.skip);\r\n      }\r\n      if (options.cubicInterpolationMode === 'monotone') {\r\n        splineCurveMonotone(points, indexAxis);\r\n      } else {\r\n        let prev = loop ? points[points.length - 1] : points[0];\r\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n          point = points[i];\r\n          controlPoints = splineCurve(\r\n            prev,\r\n            point,\r\n            points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\r\n            options.tension\r\n          );\r\n          point.cp1x = controlPoints.previous.x;\r\n          point.cp1y = controlPoints.previous.y;\r\n          point.cp2x = controlPoints.next.x;\r\n          point.cp2y = controlPoints.next.y;\r\n          prev = point;\r\n        }\r\n      }\r\n      if (options.capBezierPoints) {\r\n        capBezierPoints(points, area);\r\n      }\r\n    }\r\n    \r\n    function _pointInLine(p1, p2, t, mode) {\r\n      return {\r\n        x: p1.x + t * (p2.x - p1.x),\r\n        y: p1.y + t * (p2.y - p1.y)\r\n      };\r\n    }\r\n    function _steppedInterpolation(p1, p2, t, mode) {\r\n      return {\r\n        x: p1.x + t * (p2.x - p1.x),\r\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\r\n        : mode === 'after' ? t < 1 ? p1.y : p2.y\r\n        : t > 0 ? p2.y : p1.y\r\n      };\r\n    }\r\n    function _bezierInterpolation(p1, p2, t, mode) {\r\n      const cp1 = {x: p1.cp2x, y: p1.cp2y};\r\n      const cp2 = {x: p2.cp1x, y: p2.cp1y};\r\n      const a = _pointInLine(p1, cp1, t);\r\n      const b = _pointInLine(cp1, cp2, t);\r\n      const c = _pointInLine(cp2, p2, t);\r\n      const d = _pointInLine(a, b, t);\r\n      const e = _pointInLine(b, c, t);\r\n      return _pointInLine(d, e, t);\r\n    }\r\n    \r\n    const getRightToLeftAdapter = function(rectX, width) {\r\n      return {\r\n        x(x) {\r\n          return rectX + rectX + width - x;\r\n        },\r\n        setWidth(w) {\r\n          width = w;\r\n        },\r\n        textAlign(align) {\r\n          if (align === 'center') {\r\n            return align;\r\n          }\r\n          return align === 'right' ? 'left' : 'right';\r\n        },\r\n        xPlus(x, value) {\r\n          return x - value;\r\n        },\r\n        leftForLtr(x, itemWidth) {\r\n          return x - itemWidth;\r\n        },\r\n      };\r\n    };\r\n    const getLeftToRightAdapter = function() {\r\n      return {\r\n        x(x) {\r\n          return x;\r\n        },\r\n        setWidth(w) {\r\n        },\r\n        textAlign(align) {\r\n          return align;\r\n        },\r\n        xPlus(x, value) {\r\n          return x + value;\r\n        },\r\n        leftForLtr(x, _itemWidth) {\r\n          return x;\r\n        },\r\n      };\r\n    };\r\n    function getRtlAdapter(rtl, rectX, width) {\r\n      return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\r\n    }\r\n    function overrideTextDirection(ctx, direction) {\r\n      let style, original;\r\n      if (direction === 'ltr' || direction === 'rtl') {\r\n        style = ctx.canvas.style;\r\n        original = [\r\n          style.getPropertyValue('direction'),\r\n          style.getPropertyPriority('direction'),\r\n        ];\r\n        style.setProperty('direction', direction, 'important');\r\n        ctx.prevTextDirection = original;\r\n      }\r\n    }\r\n    function restoreTextDirection(ctx, original) {\r\n      if (original !== undefined) {\r\n        delete ctx.prevTextDirection;\r\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\r\n      }\r\n    }\r\n    \r\n    function propertyFn(property) {\r\n      if (property === 'angle') {\r\n        return {\r\n          between: _angleBetween,\r\n          compare: _angleDiff,\r\n          normalize: _normalizeAngle,\r\n        };\r\n      }\r\n      return {\r\n        between: (n, s, e) => n >= Math.min(s, e) && n <= Math.max(e, s),\r\n        compare: (a, b) => a - b,\r\n        normalize: x => x\r\n      };\r\n    }\r\n    function normalizeSegment({start, end, count, loop, style}) {\r\n      return {\r\n        start: start % count,\r\n        end: end % count,\r\n        loop: loop && (end - start + 1) % count === 0,\r\n        style\r\n      };\r\n    }\r\n    function getSegment(segment, points, bounds) {\r\n      const {property, start: startBound, end: endBound} = bounds;\r\n      const {between, normalize} = propertyFn(property);\r\n      const count = points.length;\r\n      let {start, end, loop} = segment;\r\n      let i, ilen;\r\n      if (loop) {\r\n        start += count;\r\n        end += count;\r\n        for (i = 0, ilen = count; i < ilen; ++i) {\r\n          if (!between(normalize(points[start % count][property]), startBound, endBound)) {\r\n            break;\r\n          }\r\n          start--;\r\n          end--;\r\n        }\r\n        start %= count;\r\n        end %= count;\r\n      }\r\n      if (end < start) {\r\n        end += count;\r\n      }\r\n      return {start, end, loop, style: segment.style};\r\n    }\r\n    function _boundSegment(segment, points, bounds) {\r\n      if (!bounds) {\r\n        return [segment];\r\n      }\r\n      const {property, start: startBound, end: endBound} = bounds;\r\n      const count = points.length;\r\n      const {compare, between, normalize} = propertyFn(property);\r\n      const {start, end, loop, style} = getSegment(segment, points, bounds);\r\n      const result = [];\r\n      let inside = false;\r\n      let subStart = null;\r\n      let value, point, prevValue;\r\n      const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\r\n      const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\r\n      const shouldStart = () => inside || startIsBefore();\r\n      const shouldStop = () => !inside || endIsBefore();\r\n      for (let i = start, prev = start; i <= end; ++i) {\r\n        point = points[i % count];\r\n        if (point.skip) {\r\n          continue;\r\n        }\r\n        value = normalize(point[property]);\r\n        if (value === prevValue) {\r\n          continue;\r\n        }\r\n        inside = between(value, startBound, endBound);\r\n        if (subStart === null && shouldStart()) {\r\n          subStart = compare(value, startBound) === 0 ? i : prev;\r\n        }\r\n        if (subStart !== null && shouldStop()) {\r\n          result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\r\n          subStart = null;\r\n        }\r\n        prev = i;\r\n        prevValue = value;\r\n      }\r\n      if (subStart !== null) {\r\n        result.push(normalizeSegment({start: subStart, end, loop, count, style}));\r\n      }\r\n      return result;\r\n    }\r\n    function _boundSegments(line, bounds) {\r\n      const result = [];\r\n      const segments = line.segments;\r\n      for (let i = 0; i < segments.length; i++) {\r\n        const sub = _boundSegment(segments[i], line.points, bounds);\r\n        if (sub.length) {\r\n          result.push(...sub);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n    function findStartAndEnd(points, count, loop, spanGaps) {\r\n      let start = 0;\r\n      let end = count - 1;\r\n      if (loop && !spanGaps) {\r\n        while (start < count && !points[start].skip) {\r\n          start++;\r\n        }\r\n      }\r\n      while (start < count && points[start].skip) {\r\n        start++;\r\n      }\r\n      start %= count;\r\n      if (loop) {\r\n        end += start;\r\n      }\r\n      while (end > start && points[end % count].skip) {\r\n        end--;\r\n      }\r\n      end %= count;\r\n      return {start, end};\r\n    }\r\n    function solidSegments(points, start, max, loop) {\r\n      const count = points.length;\r\n      const result = [];\r\n      let last = start;\r\n      let prev = points[start];\r\n      let end;\r\n      for (end = start + 1; end <= max; ++end) {\r\n        const cur = points[end % count];\r\n        if (cur.skip || cur.stop) {\r\n          if (!prev.skip) {\r\n            loop = false;\r\n            result.push({start: start % count, end: (end - 1) % count, loop});\r\n            start = last = cur.stop ? end : null;\r\n          }\r\n        } else {\r\n          last = end;\r\n          if (prev.skip) {\r\n            start = end;\r\n          }\r\n        }\r\n        prev = cur;\r\n      }\r\n      if (last !== null) {\r\n        result.push({start: start % count, end: last % count, loop});\r\n      }\r\n      return result;\r\n    }\r\n    function _computeSegments(line, segmentOptions) {\r\n      const points = line.points;\r\n      const spanGaps = line.options.spanGaps;\r\n      const count = points.length;\r\n      if (!count) {\r\n        return [];\r\n      }\r\n      const loop = !!line._loop;\r\n      const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\r\n      if (spanGaps === true) {\r\n        return splitByStyles([{start, end, loop}], points, segmentOptions);\r\n      }\r\n      const max = end < start ? end + count : end;\r\n      const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\r\n      return splitByStyles(solidSegments(points, start, max, completeLoop), points, segmentOptions);\r\n    }\r\n    function splitByStyles(segments, points, segmentOptions) {\r\n      if (!segmentOptions || !segmentOptions.setContext || !points) {\r\n        return segments;\r\n      }\r\n      return doSplitByStyles(segments, points, segmentOptions);\r\n    }\r\n    function doSplitByStyles(segments, points, segmentOptions) {\r\n      const count = points.length;\r\n      const result = [];\r\n      let start = segments[0].start;\r\n      let i = start;\r\n      for (const segment of segments) {\r\n        let prevStyle, style;\r\n        let prev = points[start % count];\r\n        for (i = start + 1; i <= segment.end; i++) {\r\n          const pt = points[i % count];\r\n          style = readStyle(segmentOptions.setContext({type: 'segment', p0: prev, p1: pt}));\r\n          if (styleChanged(style, prevStyle)) {\r\n            result.push({start: start, end: i - 1, loop: segment.loop, style: prevStyle});\r\n            prevStyle = style;\r\n            start = i - 1;\r\n          }\r\n          prev = pt;\r\n          prevStyle = style;\r\n        }\r\n        if (start < i - 1) {\r\n          result.push({start, end: i - 1, loop: segment.loop, style});\r\n          start = i - 1;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n    function readStyle(options) {\r\n      return {\r\n        backgroundColor: options.backgroundColor,\r\n        borderCapStyle: options.borderCapStyle,\r\n        borderDash: options.borderDash,\r\n        borderDashOffset: options.borderDashOffset,\r\n        borderJoinStyle: options.borderJoinStyle,\r\n        borderWidth: options.borderWidth,\r\n        borderColor: options.borderColor\r\n      };\r\n    }\r\n    function styleChanged(style, prevStyle) {\r\n      return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\r\n    }\r\n    \r\n    var helpers = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    easingEffects: effects,\r\n    color: color,\r\n    getHoverColor: getHoverColor,\r\n    noop: noop,\r\n    uid: uid,\r\n    isNullOrUndef: isNullOrUndef,\r\n    isArray: isArray,\r\n    isObject: isObject,\r\n    isFinite: isNumberFinite,\r\n    finiteOrDefault: finiteOrDefault,\r\n    valueOrDefault: valueOrDefault,\r\n    toPercentage: toPercentage,\r\n    toDimension: toDimension,\r\n    callback: callback,\r\n    each: each,\r\n    _elementsEqual: _elementsEqual,\r\n    clone: clone,\r\n    _merger: _merger,\r\n    merge: merge,\r\n    mergeIf: mergeIf,\r\n    _mergerIf: _mergerIf,\r\n    _deprecated: _deprecated,\r\n    resolveObjectKey: resolveObjectKey,\r\n    _capitalize: _capitalize,\r\n    defined: defined,\r\n    isFunction: isFunction,\r\n    setsEqual: setsEqual,\r\n    toFontString: toFontString,\r\n    _measureText: _measureText,\r\n    _longestText: _longestText,\r\n    _alignPixel: _alignPixel,\r\n    clearCanvas: clearCanvas,\r\n    drawPoint: drawPoint,\r\n    _isPointInArea: _isPointInArea,\r\n    clipArea: clipArea,\r\n    unclipArea: unclipArea,\r\n    _steppedLineTo: _steppedLineTo,\r\n    _bezierCurveTo: _bezierCurveTo,\r\n    renderText: renderText,\r\n    addRoundedRectPath: addRoundedRectPath,\r\n    _lookup: _lookup,\r\n    _lookupByKey: _lookupByKey,\r\n    _rlookupByKey: _rlookupByKey,\r\n    _filterBetween: _filterBetween,\r\n    listenArrayEvents: listenArrayEvents,\r\n    unlistenArrayEvents: unlistenArrayEvents,\r\n    _arrayUnique: _arrayUnique,\r\n    _createResolver: _createResolver,\r\n    _attachContext: _attachContext,\r\n    _descriptors: _descriptors,\r\n    splineCurve: splineCurve,\r\n    splineCurveMonotone: splineCurveMonotone,\r\n    _updateBezierControlPoints: _updateBezierControlPoints,\r\n    _getParentNode: _getParentNode,\r\n    getStyle: getStyle,\r\n    getRelativePosition: getRelativePosition$1,\r\n    getMaximumSize: getMaximumSize,\r\n    retinaScale: retinaScale,\r\n    supportsEventListenerOptions: supportsEventListenerOptions,\r\n    readUsedSize: readUsedSize,\r\n    fontString: fontString,\r\n    requestAnimFrame: requestAnimFrame,\r\n    throttled: throttled,\r\n    debounce: debounce,\r\n    _toLeftRightCenter: _toLeftRightCenter,\r\n    _alignStartEnd: _alignStartEnd,\r\n    _textX: _textX,\r\n    _pointInLine: _pointInLine,\r\n    _steppedInterpolation: _steppedInterpolation,\r\n    _bezierInterpolation: _bezierInterpolation,\r\n    formatNumber: formatNumber,\r\n    toLineHeight: toLineHeight,\r\n    _readValueToProps: _readValueToProps,\r\n    toTRBL: toTRBL,\r\n    toTRBLCorners: toTRBLCorners,\r\n    toPadding: toPadding,\r\n    toFont: toFont,\r\n    resolve: resolve,\r\n    _addGrace: _addGrace,\r\n    PI: PI,\r\n    TAU: TAU,\r\n    PITAU: PITAU,\r\n    INFINITY: INFINITY,\r\n    RAD_PER_DEG: RAD_PER_DEG,\r\n    HALF_PI: HALF_PI,\r\n    QUARTER_PI: QUARTER_PI,\r\n    TWO_THIRDS_PI: TWO_THIRDS_PI,\r\n    log10: log10,\r\n    sign: sign,\r\n    niceNum: niceNum,\r\n    _factorize: _factorize,\r\n    isNumber: isNumber,\r\n    almostEquals: almostEquals,\r\n    almostWhole: almostWhole,\r\n    _setMinAndMaxByKey: _setMinAndMaxByKey,\r\n    toRadians: toRadians,\r\n    toDegrees: toDegrees,\r\n    _decimalPlaces: _decimalPlaces,\r\n    getAngleFromPoint: getAngleFromPoint,\r\n    distanceBetweenPoints: distanceBetweenPoints,\r\n    _angleDiff: _angleDiff,\r\n    _normalizeAngle: _normalizeAngle,\r\n    _angleBetween: _angleBetween,\r\n    _limitValue: _limitValue,\r\n    _int16Range: _int16Range,\r\n    getRtlAdapter: getRtlAdapter,\r\n    overrideTextDirection: overrideTextDirection,\r\n    restoreTextDirection: restoreTextDirection,\r\n    _boundSegment: _boundSegment,\r\n    _boundSegments: _boundSegments,\r\n    _computeSegments: _computeSegments\r\n    });\r\n    \r\n    class TypedRegistry {\r\n      constructor(type, scope, override) {\r\n        this.type = type;\r\n        this.scope = scope;\r\n        this.override = override;\r\n        this.items = Object.create(null);\r\n      }\r\n      isForType(type) {\r\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\r\n      }\r\n      register(item) {\r\n        const me = this;\r\n        const proto = Object.getPrototypeOf(item);\r\n        let parentScope;\r\n        if (isIChartComponent(proto)) {\r\n          parentScope = me.register(proto);\r\n        }\r\n        const items = me.items;\r\n        const id = item.id;\r\n        const scope = me.scope + '.' + id;\r\n        if (!id) {\r\n          throw new Error('class does not have id: ' + item);\r\n        }\r\n        if (id in items) {\r\n          return scope;\r\n        }\r\n        items[id] = item;\r\n        registerDefaults(item, scope, parentScope);\r\n        if (me.override) {\r\n          defaults.override(item.id, item.overrides);\r\n        }\r\n        return scope;\r\n      }\r\n      get(id) {\r\n        return this.items[id];\r\n      }\r\n      unregister(item) {\r\n        const items = this.items;\r\n        const id = item.id;\r\n        const scope = this.scope;\r\n        if (id in items) {\r\n          delete items[id];\r\n        }\r\n        if (scope && id in defaults[scope]) {\r\n          delete defaults[scope][id];\r\n          if (this.override) {\r\n            delete overrides[id];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    function registerDefaults(item, scope, parentScope) {\r\n      const itemDefaults = merge(Object.create(null), [\r\n        parentScope ? defaults.get(parentScope) : {},\r\n        defaults.get(scope),\r\n        item.defaults\r\n      ]);\r\n      defaults.set(scope, itemDefaults);\r\n      if (item.defaultRoutes) {\r\n        routeDefaults(scope, item.defaultRoutes);\r\n      }\r\n      if (item.descriptors) {\r\n        defaults.describe(scope, item.descriptors);\r\n      }\r\n    }\r\n    function routeDefaults(scope, routes) {\r\n      Object.keys(routes).forEach(property => {\r\n        const propertyParts = property.split('.');\r\n        const sourceName = propertyParts.pop();\r\n        const sourceScope = [scope].concat(propertyParts).join('.');\r\n        const parts = routes[property].split('.');\r\n        const targetName = parts.pop();\r\n        const targetScope = parts.join('.');\r\n        defaults.route(sourceScope, sourceName, targetScope, targetName);\r\n      });\r\n    }\r\n    function isIChartComponent(proto) {\r\n      return 'id' in proto && 'defaults' in proto;\r\n    }\r\n    \r\n    class Registry {\r\n      constructor() {\r\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\r\n        this.elements = new TypedRegistry(Element, 'elements');\r\n        this.plugins = new TypedRegistry(Object, 'plugins');\r\n        this.scales = new TypedRegistry(Scale, 'scales');\r\n        this._typedRegistries = [this.controllers, this.scales, this.elements];\r\n      }\r\n      add(...args) {\r\n        this._each('register', args);\r\n      }\r\n      remove(...args) {\r\n        this._each('unregister', args);\r\n      }\r\n      addControllers(...args) {\r\n        this._each('register', args, this.controllers);\r\n      }\r\n      addElements(...args) {\r\n        this._each('register', args, this.elements);\r\n      }\r\n      addPlugins(...args) {\r\n        this._each('register', args, this.plugins);\r\n      }\r\n      addScales(...args) {\r\n        this._each('register', args, this.scales);\r\n      }\r\n      getController(id) {\r\n        return this._get(id, this.controllers, 'controller');\r\n      }\r\n      getElement(id) {\r\n        return this._get(id, this.elements, 'element');\r\n      }\r\n      getPlugin(id) {\r\n        return this._get(id, this.plugins, 'plugin');\r\n      }\r\n      getScale(id) {\r\n        return this._get(id, this.scales, 'scale');\r\n      }\r\n      removeControllers(...args) {\r\n        this._each('unregister', args, this.controllers);\r\n      }\r\n      removeElements(...args) {\r\n        this._each('unregister', args, this.elements);\r\n      }\r\n      removePlugins(...args) {\r\n        this._each('unregister', args, this.plugins);\r\n      }\r\n      removeScales(...args) {\r\n        this._each('unregister', args, this.scales);\r\n      }\r\n      _each(method, args, typedRegistry) {\r\n        const me = this;\r\n        [...args].forEach(arg => {\r\n          const reg = typedRegistry || me._getRegistryForType(arg);\r\n          if (typedRegistry || reg.isForType(arg) || (reg === me.plugins && arg.id)) {\r\n            me._exec(method, reg, arg);\r\n          } else {\r\n            each(arg, item => {\r\n              const itemReg = typedRegistry || me._getRegistryForType(item);\r\n              me._exec(method, itemReg, item);\r\n            });\r\n          }\r\n        });\r\n      }\r\n      _exec(method, registry, component) {\r\n        const camelMethod = _capitalize(method);\r\n        callback(component['before' + camelMethod], [], component);\r\n        registry[method](component);\r\n        callback(component['after' + camelMethod], [], component);\r\n      }\r\n      _getRegistryForType(type) {\r\n        for (let i = 0; i < this._typedRegistries.length; i++) {\r\n          const reg = this._typedRegistries[i];\r\n          if (reg.isForType(type)) {\r\n            return reg;\r\n          }\r\n        }\r\n        return this.plugins;\r\n      }\r\n      _get(id, typedRegistry, type) {\r\n        const item = typedRegistry.get(id);\r\n        if (item === undefined) {\r\n          throw new Error('\"' + id + '\" is not a registered ' + type + '.');\r\n        }\r\n        return item;\r\n      }\r\n    }\r\n    var registry = new Registry();\r\n    \r\n    class PluginService {\r\n      constructor() {\r\n        this._init = [];\r\n      }\r\n      notify(chart, hook, args, filter) {\r\n        const me = this;\r\n        if (hook === 'beforeInit') {\r\n          me._init = me._createDescriptors(chart, true);\r\n          me._notify(me._init, chart, 'install');\r\n        }\r\n        const descriptors = filter ? me._descriptors(chart).filter(filter) : me._descriptors(chart);\r\n        const result = me._notify(descriptors, chart, hook, args);\r\n        if (hook === 'destroy') {\r\n          me._notify(descriptors, chart, 'stop');\r\n          me._notify(me._init, chart, 'uninstall');\r\n        }\r\n        return result;\r\n      }\r\n      _notify(descriptors, chart, hook, args) {\r\n        args = args || {};\r\n        for (const descriptor of descriptors) {\r\n          const plugin = descriptor.plugin;\r\n          const method = plugin[hook];\r\n          const params = [chart, args, descriptor.options];\r\n          if (callback(method, params, plugin) === false && args.cancelable) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      invalidate() {\r\n        if (!isNullOrUndef(this._cache)) {\r\n          this._oldCache = this._cache;\r\n          this._cache = undefined;\r\n        }\r\n      }\r\n      _descriptors(chart) {\r\n        if (this._cache) {\r\n          return this._cache;\r\n        }\r\n        const descriptors = this._cache = this._createDescriptors(chart);\r\n        this._notifyStateChanges(chart);\r\n        return descriptors;\r\n      }\r\n      _createDescriptors(chart, all) {\r\n        const config = chart && chart.config;\r\n        const options = valueOrDefault(config.options && config.options.plugins, {});\r\n        const plugins = allPlugins(config);\r\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\r\n      }\r\n      _notifyStateChanges(chart) {\r\n        const previousDescriptors = this._oldCache || [];\r\n        const descriptors = this._cache;\r\n        const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\r\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\r\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\r\n      }\r\n    }\r\n    function allPlugins(config) {\r\n      const plugins = [];\r\n      const keys = Object.keys(registry.plugins.items);\r\n      for (let i = 0; i < keys.length; i++) {\r\n        plugins.push(registry.getPlugin(keys[i]));\r\n      }\r\n      const local = config.plugins || [];\r\n      for (let i = 0; i < local.length; i++) {\r\n        const plugin = local[i];\r\n        if (plugins.indexOf(plugin) === -1) {\r\n          plugins.push(plugin);\r\n        }\r\n      }\r\n      return plugins;\r\n    }\r\n    function getOpts(options, all) {\r\n      if (!all && options === false) {\r\n        return null;\r\n      }\r\n      if (options === true) {\r\n        return {};\r\n      }\r\n      return options;\r\n    }\r\n    function createDescriptors(chart, plugins, options, all) {\r\n      const result = [];\r\n      const context = chart.getContext();\r\n      for (let i = 0; i < plugins.length; i++) {\r\n        const plugin = plugins[i];\r\n        const id = plugin.id;\r\n        const opts = getOpts(options[id], all);\r\n        if (opts === null) {\r\n          continue;\r\n        }\r\n        result.push({\r\n          plugin,\r\n          options: pluginOpts(chart.config, plugin, opts, context)\r\n        });\r\n      }\r\n      return result;\r\n    }\r\n    function pluginOpts(config, plugin, opts, context) {\r\n      const keys = config.pluginScopeKeys(plugin);\r\n      const scopes = config.getOptionScopes(opts, keys);\r\n      return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});\r\n    }\r\n    \r\n    function getIndexAxis(type, options) {\r\n      const datasetDefaults = defaults.datasets[type] || {};\r\n      const datasetOptions = (options.datasets || {})[type] || {};\r\n      return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\r\n    }\r\n    function getAxisFromDefaultScaleID(id, indexAxis) {\r\n      let axis = id;\r\n      if (id === '_index_') {\r\n        axis = indexAxis;\r\n      } else if (id === '_value_') {\r\n        axis = indexAxis === 'x' ? 'y' : 'x';\r\n      }\r\n      return axis;\r\n    }\r\n    function getDefaultScaleIDFromAxis(axis, indexAxis) {\r\n      return axis === indexAxis ? '_index_' : '_value_';\r\n    }\r\n    function axisFromPosition(position) {\r\n      if (position === 'top' || position === 'bottom') {\r\n        return 'x';\r\n      }\r\n      if (position === 'left' || position === 'right') {\r\n        return 'y';\r\n      }\r\n    }\r\n    function determineAxis(id, scaleOptions) {\r\n      if (id === 'x' || id === 'y') {\r\n        return id;\r\n      }\r\n      return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\r\n    }\r\n    function mergeScaleConfig(config, options) {\r\n      const chartDefaults = overrides[config.type] || {scales: {}};\r\n      const configScales = options.scales || {};\r\n      const chartIndexAxis = getIndexAxis(config.type, options);\r\n      const firstIDs = Object.create(null);\r\n      const scales = Object.create(null);\r\n      Object.keys(configScales).forEach(id => {\r\n        const scaleConf = configScales[id];\r\n        const axis = determineAxis(id, scaleConf);\r\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\r\n        const defaultScaleOptions = chartDefaults.scales || {};\r\n        firstIDs[axis] = firstIDs[axis] || id;\r\n        scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\r\n      });\r\n      config.data.datasets.forEach(dataset => {\r\n        const type = dataset.type || config.type;\r\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\r\n        const datasetDefaults = overrides[type] || {};\r\n        const defaultScaleOptions = datasetDefaults.scales || {};\r\n        Object.keys(defaultScaleOptions).forEach(defaultID => {\r\n          const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\r\n          const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\r\n          scales[id] = scales[id] || Object.create(null);\r\n          mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\r\n        });\r\n      });\r\n      Object.keys(scales).forEach(key => {\r\n        const scale = scales[key];\r\n        mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\r\n      });\r\n      return scales;\r\n    }\r\n    function initOptions(config) {\r\n      const options = config.options || (config.options = {});\r\n      options.plugins = valueOrDefault(options.plugins, {});\r\n      options.scales = mergeScaleConfig(config, options);\r\n    }\r\n    function initData(data) {\r\n      data = data || {};\r\n      data.datasets = data.datasets || [];\r\n      data.labels = data.labels || [];\r\n      return data;\r\n    }\r\n    function initConfig(config) {\r\n      config = config || {};\r\n      config.data = initData(config.data);\r\n      initOptions(config);\r\n      return config;\r\n    }\r\n    const keyCache = new Map();\r\n    const keysCached = new Set();\r\n    function cachedKeys(cacheKey, generate) {\r\n      let keys = keyCache.get(cacheKey);\r\n      if (!keys) {\r\n        keys = generate();\r\n        keyCache.set(cacheKey, keys);\r\n        keysCached.add(keys);\r\n      }\r\n      return keys;\r\n    }\r\n    const addIfFound = (set, obj, key) => {\r\n      const opts = resolveObjectKey(obj, key);\r\n      if (opts !== undefined) {\r\n        set.add(opts);\r\n      }\r\n    };\r\n    class Config {\r\n      constructor(config) {\r\n        this._config = initConfig(config);\r\n        this._scopeCache = new Map();\r\n        this._resolverCache = new Map();\r\n      }\r\n      get type() {\r\n        return this._config.type;\r\n      }\r\n      set type(type) {\r\n        this._config.type = type;\r\n      }\r\n      get data() {\r\n        return this._config.data;\r\n      }\r\n      set data(data) {\r\n        this._config.data = initData(data);\r\n      }\r\n      get options() {\r\n        return this._config.options;\r\n      }\r\n      set options(options) {\r\n        this._config.options = options;\r\n      }\r\n      get plugins() {\r\n        return this._config.plugins;\r\n      }\r\n      update() {\r\n        const config = this._config;\r\n        this.clearCache();\r\n        initOptions(config);\r\n      }\r\n      clearCache() {\r\n        this._scopeCache.clear();\r\n        this._resolverCache.clear();\r\n      }\r\n      datasetScopeKeys(datasetType) {\r\n        return cachedKeys(datasetType,\r\n          () => [[\r\n            `datasets.${datasetType}`,\r\n            ''\r\n          ]]);\r\n      }\r\n      datasetAnimationScopeKeys(datasetType, transition) {\r\n        return cachedKeys(`${datasetType}.transition.${transition}`,\r\n          () => [\r\n            [\r\n              `datasets.${datasetType}.transitions.${transition}`,\r\n              `transitions.${transition}`,\r\n            ],\r\n            [\r\n              `datasets.${datasetType}`,\r\n              ''\r\n            ]\r\n          ]);\r\n      }\r\n      datasetElementScopeKeys(datasetType, elementType) {\r\n        return cachedKeys(`${datasetType}-${elementType}`,\r\n          () => [[\r\n            `datasets.${datasetType}.elements.${elementType}`,\r\n            `datasets.${datasetType}`,\r\n            `elements.${elementType}`,\r\n            ''\r\n          ]]);\r\n      }\r\n      pluginScopeKeys(plugin) {\r\n        const id = plugin.id;\r\n        const type = this.type;\r\n        return cachedKeys(`${type}-plugin-${id}`,\r\n          () => [[\r\n            `plugins.${id}`,\r\n            ...plugin.additionalOptionScopes || [],\r\n          ]]);\r\n      }\r\n      _cachedScopes(mainScope, resetCache) {\r\n        const _scopeCache = this._scopeCache;\r\n        let cache = _scopeCache.get(mainScope);\r\n        if (!cache || resetCache) {\r\n          cache = new Map();\r\n          _scopeCache.set(mainScope, cache);\r\n        }\r\n        return cache;\r\n      }\r\n      getOptionScopes(mainScope, keyLists, resetCache) {\r\n        const {options, type} = this;\r\n        const cache = this._cachedScopes(mainScope, resetCache);\r\n        const cached = cache.get(keyLists);\r\n        if (cached) {\r\n          return cached;\r\n        }\r\n        const scopes = new Set();\r\n        keyLists.forEach(keys => {\r\n          if (mainScope) {\r\n            scopes.add(mainScope);\r\n            keys.forEach(key => addIfFound(scopes, mainScope, key));\r\n          }\r\n          keys.forEach(key => addIfFound(scopes, options, key));\r\n          keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\r\n          keys.forEach(key => addIfFound(scopes, defaults, key));\r\n          keys.forEach(key => addIfFound(scopes, descriptors, key));\r\n        });\r\n        const array = [...scopes];\r\n        if (keysCached.has(keyLists)) {\r\n          cache.set(keyLists, array);\r\n        }\r\n        return array;\r\n      }\r\n      chartOptionScopes() {\r\n        const {options, type} = this;\r\n        return [\r\n          options,\r\n          overrides[type] || {},\r\n          defaults.datasets[type] || {},\r\n          {type},\r\n          defaults,\r\n          descriptors\r\n        ];\r\n      }\r\n      resolveNamedOptions(scopes, names, context, prefixes = ['']) {\r\n        const result = {$shared: true};\r\n        const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\r\n        let options = resolver;\r\n        if (needContext(resolver, names)) {\r\n          result.$shared = false;\r\n          context = isFunction(context) ? context() : context;\r\n          const subResolver = this.createResolver(scopes, context, subPrefixes);\r\n          options = _attachContext(resolver, context, subResolver);\r\n        }\r\n        for (const prop of names) {\r\n          result[prop] = options[prop];\r\n        }\r\n        return result;\r\n      }\r\n      createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\r\n        const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\r\n        return isObject(context)\r\n          ? _attachContext(resolver, context, undefined, descriptorDefaults)\r\n          : resolver;\r\n      }\r\n    }\r\n    function getResolver(resolverCache, scopes, prefixes) {\r\n      let cache = resolverCache.get(scopes);\r\n      if (!cache) {\r\n        cache = new Map();\r\n        resolverCache.set(scopes, cache);\r\n      }\r\n      const cacheKey = prefixes.join();\r\n      let cached = cache.get(cacheKey);\r\n      if (!cached) {\r\n        const resolver = _createResolver(scopes, prefixes);\r\n        cached = {\r\n          resolver,\r\n          subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\r\n        };\r\n        cache.set(cacheKey, cached);\r\n      }\r\n      return cached;\r\n    }\r\n    function needContext(proxy, names) {\r\n      const {isScriptable, isIndexable} = _descriptors(proxy);\r\n      for (const prop of names) {\r\n        if ((isScriptable(prop) && isFunction(proxy[prop]))\r\n          || (isIndexable(prop) && isArray(proxy[prop]))) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n    \r\n    var version = \"3.2.1\";\r\n    \r\n    const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\r\n    function positionIsHorizontal(position, axis) {\r\n      return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\r\n    }\r\n    function compare2Level(l1, l2) {\r\n      return function(a, b) {\r\n        return a[l1] === b[l1]\r\n          ? a[l2] - b[l2]\r\n          : a[l1] - b[l1];\r\n      };\r\n    }\r\n    function onAnimationsComplete(context) {\r\n      const chart = context.chart;\r\n      const animationOptions = chart.options.animation;\r\n      chart.notifyPlugins('afterRender');\r\n      callback(animationOptions && animationOptions.onComplete, [context], chart);\r\n    }\r\n    function onAnimationProgress(context) {\r\n      const chart = context.chart;\r\n      const animationOptions = chart.options.animation;\r\n      callback(animationOptions && animationOptions.onProgress, [context], chart);\r\n    }\r\n    function isDomSupported() {\r\n      return typeof window !== 'undefined' && typeof document !== 'undefined';\r\n    }\r\n    function getCanvas(item) {\r\n      if (isDomSupported() && typeof item === 'string') {\r\n        item = document.getElementById(item);\r\n      } else if (item && item.length) {\r\n        item = item[0];\r\n      }\r\n      if (item && item.canvas) {\r\n        item = item.canvas;\r\n      }\r\n      return item;\r\n    }\r\n    const instances = {};\r\n    const getChart = (key) => {\r\n      const canvas = getCanvas(key);\r\n      return Object.values(instances).filter((c) => c.canvas === canvas).pop();\r\n    };\r\n    class Chart {\r\n      constructor(item, config) {\r\n        const me = this;\r\n        this.config = config = new Config(config);\r\n        const initialCanvas = getCanvas(item);\r\n        const existingChart = getChart(initialCanvas);\r\n        if (existingChart) {\r\n          throw new Error(\r\n            'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\r\n                    ' must be destroyed before the canvas can be reused.'\r\n          );\r\n        }\r\n        const options = config.createResolver(config.chartOptionScopes(), me.getContext());\r\n        this.platform = me._initializePlatform(initialCanvas, config);\r\n        const context = me.platform.acquireContext(initialCanvas, options.aspectRatio);\r\n        const canvas = context && context.canvas;\r\n        const height = canvas && canvas.height;\r\n        const width = canvas && canvas.width;\r\n        this.id = uid();\r\n        this.ctx = context;\r\n        this.canvas = canvas;\r\n        this.width = width;\r\n        this.height = height;\r\n        this._options = options;\r\n        this._aspectRatio = this.aspectRatio;\r\n        this._layers = [];\r\n        this._metasets = [];\r\n        this._stacks = undefined;\r\n        this.boxes = [];\r\n        this.currentDevicePixelRatio = undefined;\r\n        this.chartArea = undefined;\r\n        this._active = [];\r\n        this._lastEvent = undefined;\r\n        this._listeners = {};\r\n        this._responsiveListeners = undefined;\r\n        this._sortedMetasets = [];\r\n        this.scales = {};\r\n        this.scale = undefined;\r\n        this._plugins = new PluginService();\r\n        this.$proxies = {};\r\n        this._hiddenIndices = {};\r\n        this.attached = false;\r\n        this._animationsDisabled = undefined;\r\n        this.$context = undefined;\r\n        this._doResize = debounce(() => this.update('resize'), options.resizeDelay || 0);\r\n        instances[me.id] = me;\r\n        if (!context || !canvas) {\r\n          console.error(\"Failed to create chart: can't acquire context from the given item\");\r\n          return;\r\n        }\r\n        animator.listen(me, 'complete', onAnimationsComplete);\r\n        animator.listen(me, 'progress', onAnimationProgress);\r\n        me._initialize();\r\n        if (me.attached) {\r\n          me.update();\r\n        }\r\n      }\r\n      get aspectRatio() {\r\n        const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\r\n        if (!isNullOrUndef(aspectRatio)) {\r\n          return aspectRatio;\r\n        }\r\n        if (maintainAspectRatio && _aspectRatio) {\r\n          return _aspectRatio;\r\n        }\r\n        return height ? width / height : null;\r\n      }\r\n      get data() {\r\n        return this.config.data;\r\n      }\r\n      set data(data) {\r\n        this.config.data = data;\r\n      }\r\n      get options() {\r\n        return this._options;\r\n      }\r\n      set options(options) {\r\n        this.config.options = options;\r\n      }\r\n      _initialize() {\r\n        const me = this;\r\n        me.notifyPlugins('beforeInit');\r\n        if (me.options.responsive) {\r\n          me.resize();\r\n        } else {\r\n          retinaScale(me, me.options.devicePixelRatio);\r\n        }\r\n        me.bindEvents();\r\n        me.notifyPlugins('afterInit');\r\n        return me;\r\n      }\r\n      _initializePlatform(canvas, config) {\r\n        if (config.platform) {\r\n          return new config.platform();\r\n        } else if (!isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\r\n          return new BasicPlatform();\r\n        }\r\n        return new DomPlatform();\r\n      }\r\n      clear() {\r\n        clearCanvas(this.canvas, this.ctx);\r\n        return this;\r\n      }\r\n      stop() {\r\n        animator.stop(this);\r\n        return this;\r\n      }\r\n      resize(width, height) {\r\n        if (!animator.running(this)) {\r\n          this._resize(width, height);\r\n        } else {\r\n          this._resizeBeforeDraw = {width, height};\r\n        }\r\n      }\r\n      _resize(width, height) {\r\n        const me = this;\r\n        const options = me.options;\r\n        const canvas = me.canvas;\r\n        const aspectRatio = options.maintainAspectRatio && me.aspectRatio;\r\n        const newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);\r\n        const newRatio = options.devicePixelRatio || me.platform.getDevicePixelRatio();\r\n        me.width = newSize.width;\r\n        me.height = newSize.height;\r\n        me._aspectRatio = me.aspectRatio;\r\n        if (!retinaScale(me, newRatio, true)) {\r\n          return;\r\n        }\r\n        me.notifyPlugins('resize', {size: newSize});\r\n        callback(options.onResize, [me, newSize], me);\r\n        if (me.attached) {\r\n          if (me._doResize()) {\r\n            me.render();\r\n          }\r\n        }\r\n      }\r\n      ensureScalesHaveIDs() {\r\n        const options = this.options;\r\n        const scalesOptions = options.scales || {};\r\n        each(scalesOptions, (axisOptions, axisID) => {\r\n          axisOptions.id = axisID;\r\n        });\r\n      }\r\n      buildOrUpdateScales() {\r\n        const me = this;\r\n        const options = me.options;\r\n        const scaleOpts = options.scales;\r\n        const scales = me.scales;\r\n        const updated = Object.keys(scales).reduce((obj, id) => {\r\n          obj[id] = false;\r\n          return obj;\r\n        }, {});\r\n        let items = [];\r\n        if (scaleOpts) {\r\n          items = items.concat(\r\n            Object.keys(scaleOpts).map((id) => {\r\n              const scaleOptions = scaleOpts[id];\r\n              const axis = determineAxis(id, scaleOptions);\r\n              const isRadial = axis === 'r';\r\n              const isHorizontal = axis === 'x';\r\n              return {\r\n                options: scaleOptions,\r\n                dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\r\n                dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\r\n              };\r\n            })\r\n          );\r\n        }\r\n        each(items, (item) => {\r\n          const scaleOptions = item.options;\r\n          const id = scaleOptions.id;\r\n          const axis = determineAxis(id, scaleOptions);\r\n          const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\r\n          if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\r\n            scaleOptions.position = item.dposition;\r\n          }\r\n          updated[id] = true;\r\n          let scale = null;\r\n          if (id in scales && scales[id].type === scaleType) {\r\n            scale = scales[id];\r\n          } else {\r\n            const scaleClass = registry.getScale(scaleType);\r\n            scale = new scaleClass({\r\n              id,\r\n              type: scaleType,\r\n              ctx: me.ctx,\r\n              chart: me\r\n            });\r\n            scales[scale.id] = scale;\r\n          }\r\n          scale.init(scaleOptions, options);\r\n        });\r\n        each(updated, (hasUpdated, id) => {\r\n          if (!hasUpdated) {\r\n            delete scales[id];\r\n          }\r\n        });\r\n        each(scales, (scale) => {\r\n          layouts.configure(me, scale, scale.options);\r\n          layouts.addBox(me, scale);\r\n        });\r\n      }\r\n      _updateMetasetIndex(meta, index) {\r\n        const metasets = this._metasets;\r\n        const oldIndex = meta.index;\r\n        if (oldIndex !== index) {\r\n          metasets[oldIndex] = metasets[index];\r\n          metasets[index] = meta;\r\n          meta.index = index;\r\n        }\r\n      }\r\n      _updateMetasets() {\r\n        const me = this;\r\n        const metasets = me._metasets;\r\n        const numData = me.data.datasets.length;\r\n        const numMeta = metasets.length;\r\n        if (numMeta > numData) {\r\n          for (let i = numData; i < numMeta; ++i) {\r\n            me._destroyDatasetMeta(i);\r\n          }\r\n          metasets.splice(numData, numMeta - numData);\r\n        }\r\n        me._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\r\n      }\r\n      _removeUnreferencedMetasets() {\r\n        const me = this;\r\n        const {_metasets: metasets, data: {datasets}} = me;\r\n        if (metasets.length > datasets.length) {\r\n          delete me._stacks;\r\n        }\r\n        metasets.forEach((meta, index) => {\r\n          if (datasets.filter(x => x === meta._dataset).length === 0) {\r\n            me._destroyDatasetMeta(index);\r\n          }\r\n        });\r\n      }\r\n      buildOrUpdateControllers() {\r\n        const me = this;\r\n        const newControllers = [];\r\n        const datasets = me.data.datasets;\r\n        let i, ilen;\r\n        me._removeUnreferencedMetasets();\r\n        for (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n          const dataset = datasets[i];\r\n          let meta = me.getDatasetMeta(i);\r\n          const type = dataset.type || me.config.type;\r\n          if (meta.type && meta.type !== type) {\r\n            me._destroyDatasetMeta(i);\r\n            meta = me.getDatasetMeta(i);\r\n          }\r\n          meta.type = type;\r\n          meta.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);\r\n          meta.order = dataset.order || 0;\r\n          me._updateMetasetIndex(meta, i);\r\n          meta.label = '' + dataset.label;\r\n          meta.visible = me.isDatasetVisible(i);\r\n          if (meta.controller) {\r\n            meta.controller.updateIndex(i);\r\n            meta.controller.linkScales();\r\n          } else {\r\n            const ControllerClass = registry.getController(type);\r\n            const {datasetElementType, dataElementType} = defaults.datasets[type];\r\n            Object.assign(ControllerClass.prototype, {\r\n              dataElementType: registry.getElement(dataElementType),\r\n              datasetElementType: datasetElementType && registry.getElement(datasetElementType)\r\n            });\r\n            meta.controller = new ControllerClass(me, i);\r\n            newControllers.push(meta.controller);\r\n          }\r\n        }\r\n        me._updateMetasets();\r\n        return newControllers;\r\n      }\r\n      _resetElements() {\r\n        const me = this;\r\n        each(me.data.datasets, (dataset, datasetIndex) => {\r\n          me.getDatasetMeta(datasetIndex).controller.reset();\r\n        }, me);\r\n      }\r\n      reset() {\r\n        this._resetElements();\r\n        this.notifyPlugins('reset');\r\n      }\r\n      update(mode) {\r\n        const me = this;\r\n        const config = me.config;\r\n        config.update();\r\n        me._options = config.createResolver(config.chartOptionScopes(), me.getContext());\r\n        each(me.scales, (scale) => {\r\n          layouts.removeBox(me, scale);\r\n        });\r\n        const animsDisabled = me._animationsDisabled = !me.options.animation;\r\n        me.ensureScalesHaveIDs();\r\n        me.buildOrUpdateScales();\r\n        const existingEvents = new Set(Object.keys(me._listeners));\r\n        const newEvents = new Set(me.options.events);\r\n        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== me.options.responsive) {\r\n          me.unbindEvents();\r\n          me.bindEvents();\r\n        }\r\n        me._plugins.invalidate();\r\n        if (me.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\r\n          return;\r\n        }\r\n        const newControllers = me.buildOrUpdateControllers();\r\n        me.notifyPlugins('beforeElementsUpdate');\r\n        let minPadding = 0;\r\n        for (let i = 0, ilen = me.data.datasets.length; i < ilen; i++) {\r\n          const {controller} = me.getDatasetMeta(i);\r\n          const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\r\n          controller.buildOrUpdateElements(reset);\r\n          minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\r\n        }\r\n        me._minPadding = minPadding;\r\n        me._updateLayout(minPadding);\r\n        if (!animsDisabled) {\r\n          each(newControllers, (controller) => {\r\n            controller.reset();\r\n          });\r\n        }\r\n        me._updateDatasets(mode);\r\n        me.notifyPlugins('afterUpdate', {mode});\r\n        me._layers.sort(compare2Level('z', '_idx'));\r\n        if (me._lastEvent) {\r\n          me._eventHandler(me._lastEvent, true);\r\n        }\r\n        me.render();\r\n      }\r\n      _updateLayout(minPadding) {\r\n        const me = this;\r\n        if (me.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\r\n          return;\r\n        }\r\n        layouts.update(me, me.width, me.height, minPadding);\r\n        const area = me.chartArea;\r\n        const noArea = area.width <= 0 || area.height <= 0;\r\n        me._layers = [];\r\n        each(me.boxes, (box) => {\r\n          if (noArea && box.position === 'chartArea') {\r\n            return;\r\n          }\r\n          if (box.configure) {\r\n            box.configure();\r\n          }\r\n          me._layers.push(...box._layers());\r\n        }, me);\r\n        me._layers.forEach((item, index) => {\r\n          item._idx = index;\r\n        });\r\n        me.notifyPlugins('afterLayout');\r\n      }\r\n      _updateDatasets(mode) {\r\n        const me = this;\r\n        const isFunction = typeof mode === 'function';\r\n        if (me.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\r\n          return;\r\n        }\r\n        for (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n          me._updateDataset(i, isFunction ? mode({datasetIndex: i}) : mode);\r\n        }\r\n        me.notifyPlugins('afterDatasetsUpdate', {mode});\r\n      }\r\n      _updateDataset(index, mode) {\r\n        const me = this;\r\n        const meta = me.getDatasetMeta(index);\r\n        const args = {meta, index, mode, cancelable: true};\r\n        if (me.notifyPlugins('beforeDatasetUpdate', args) === false) {\r\n          return;\r\n        }\r\n        meta.controller._update(mode);\r\n        args.cancelable = false;\r\n        me.notifyPlugins('afterDatasetUpdate', args);\r\n      }\r\n      render() {\r\n        const me = this;\r\n        if (me.notifyPlugins('beforeRender', {cancelable: true}) === false) {\r\n          return;\r\n        }\r\n        if (animator.has(me)) {\r\n          if (me.attached && !animator.running(me)) {\r\n            animator.start(me);\r\n          }\r\n        } else {\r\n          me.draw();\r\n          onAnimationsComplete({chart: me});\r\n        }\r\n      }\r\n      draw() {\r\n        const me = this;\r\n        let i;\r\n        if (me._resizeBeforeDraw) {\r\n          const {width, height} = me._resizeBeforeDraw;\r\n          me._resize(width, height);\r\n          me._resizeBeforeDraw = null;\r\n        }\r\n        me.clear();\r\n        if (me.width <= 0 || me.height <= 0) {\r\n          return;\r\n        }\r\n        if (me.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\r\n          return;\r\n        }\r\n        const layers = me._layers;\r\n        for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\r\n          layers[i].draw(me.chartArea);\r\n        }\r\n        me._drawDatasets();\r\n        for (; i < layers.length; ++i) {\r\n          layers[i].draw(me.chartArea);\r\n        }\r\n        me.notifyPlugins('afterDraw');\r\n      }\r\n      _getSortedDatasetMetas(filterVisible) {\r\n        const me = this;\r\n        const metasets = me._sortedMetasets;\r\n        const result = [];\r\n        let i, ilen;\r\n        for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n          const meta = metasets[i];\r\n          if (!filterVisible || meta.visible) {\r\n            result.push(meta);\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      getSortedVisibleDatasetMetas() {\r\n        return this._getSortedDatasetMetas(true);\r\n      }\r\n      _drawDatasets() {\r\n        const me = this;\r\n        if (me.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\r\n          return;\r\n        }\r\n        const metasets = me.getSortedVisibleDatasetMetas();\r\n        for (let i = metasets.length - 1; i >= 0; --i) {\r\n          me._drawDataset(metasets[i]);\r\n        }\r\n        me.notifyPlugins('afterDatasetsDraw');\r\n      }\r\n      _drawDataset(meta) {\r\n        const me = this;\r\n        const ctx = me.ctx;\r\n        const clip = meta._clip;\r\n        const area = me.chartArea;\r\n        const args = {\r\n          meta,\r\n          index: meta.index,\r\n          cancelable: true\r\n        };\r\n        if (me.notifyPlugins('beforeDatasetDraw', args) === false) {\r\n          return;\r\n        }\r\n        clipArea(ctx, {\r\n          left: clip.left === false ? 0 : area.left - clip.left,\r\n          right: clip.right === false ? me.width : area.right + clip.right,\r\n          top: clip.top === false ? 0 : area.top - clip.top,\r\n          bottom: clip.bottom === false ? me.height : area.bottom + clip.bottom\r\n        });\r\n        meta.controller.draw();\r\n        unclipArea(ctx);\r\n        args.cancelable = false;\r\n        me.notifyPlugins('afterDatasetDraw', args);\r\n      }\r\n      getElementsAtEventForMode(e, mode, options, useFinalPosition) {\r\n        const method = Interaction.modes[mode];\r\n        if (typeof method === 'function') {\r\n          return method(this, e, options, useFinalPosition);\r\n        }\r\n        return [];\r\n      }\r\n      getDatasetMeta(datasetIndex) {\r\n        const me = this;\r\n        const dataset = me.data.datasets[datasetIndex];\r\n        const metasets = me._metasets;\r\n        let meta = metasets.filter(x => x && x._dataset === dataset).pop();\r\n        if (!meta) {\r\n          meta = metasets[datasetIndex] = {\r\n            type: null,\r\n            data: [],\r\n            dataset: null,\r\n            controller: null,\r\n            hidden: null,\r\n            xAxisID: null,\r\n            yAxisID: null,\r\n            order: dataset && dataset.order || 0,\r\n            index: datasetIndex,\r\n            _dataset: dataset,\r\n            _parsed: [],\r\n            _sorted: false\r\n          };\r\n        }\r\n        return meta;\r\n      }\r\n      getContext() {\r\n        return this.$context || (this.$context = {chart: this, type: 'chart'});\r\n      }\r\n      getVisibleDatasetCount() {\r\n        return this.getSortedVisibleDatasetMetas().length;\r\n      }\r\n      isDatasetVisible(datasetIndex) {\r\n        const dataset = this.data.datasets[datasetIndex];\r\n        if (!dataset) {\r\n          return false;\r\n        }\r\n        const meta = this.getDatasetMeta(datasetIndex);\r\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\r\n      }\r\n      setDatasetVisibility(datasetIndex, visible) {\r\n        const meta = this.getDatasetMeta(datasetIndex);\r\n        meta.hidden = !visible;\r\n      }\r\n      toggleDataVisibility(index) {\r\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\r\n      }\r\n      getDataVisibility(index) {\r\n        return !this._hiddenIndices[index];\r\n      }\r\n      _updateDatasetVisibility(datasetIndex, visible) {\r\n        const me = this;\r\n        const mode = visible ? 'show' : 'hide';\r\n        const meta = me.getDatasetMeta(datasetIndex);\r\n        const anims = meta.controller._resolveAnimations(undefined, mode);\r\n        me.setDatasetVisibility(datasetIndex, visible);\r\n        anims.update(meta, {visible});\r\n        me.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\r\n      }\r\n      hide(datasetIndex) {\r\n        this._updateDatasetVisibility(datasetIndex, false);\r\n      }\r\n      show(datasetIndex) {\r\n        this._updateDatasetVisibility(datasetIndex, true);\r\n      }\r\n      _destroyDatasetMeta(datasetIndex) {\r\n        const me = this;\r\n        const meta = me._metasets && me._metasets[datasetIndex];\r\n        if (meta && meta.controller) {\r\n          meta.controller._destroy();\r\n          delete me._metasets[datasetIndex];\r\n        }\r\n      }\r\n      destroy() {\r\n        const me = this;\r\n        const {canvas, ctx} = me;\r\n        let i, ilen;\r\n        me.stop();\r\n        animator.remove(me);\r\n        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n          me._destroyDatasetMeta(i);\r\n        }\r\n        me.config.clearCache();\r\n        if (canvas) {\r\n          me.unbindEvents();\r\n          clearCanvas(canvas, ctx);\r\n          me.platform.releaseContext(ctx);\r\n          me.canvas = null;\r\n          me.ctx = null;\r\n        }\r\n        me.notifyPlugins('destroy');\r\n        delete instances[me.id];\r\n      }\r\n      toBase64Image(...args) {\r\n        return this.canvas.toDataURL(...args);\r\n      }\r\n      bindEvents() {\r\n        this.bindUserEvents();\r\n        if (this.options.responsive) {\r\n          this.bindResponsiveEvents();\r\n        } else {\r\n          this.attached = true;\r\n        }\r\n      }\r\n      bindUserEvents() {\r\n        const me = this;\r\n        const listeners = me._listeners;\r\n        const platform = me.platform;\r\n        const _add = (type, listener) => {\r\n          platform.addEventListener(me, type, listener);\r\n          listeners[type] = listener;\r\n        };\r\n        const listener = function(e, x, y) {\r\n          e.offsetX = x;\r\n          e.offsetY = y;\r\n          me._eventHandler(e);\r\n        };\r\n        each(me.options.events, (type) => _add(type, listener));\r\n      }\r\n      bindResponsiveEvents() {\r\n        const me = this;\r\n        if (!me._responsiveListeners) {\r\n          me._responsiveListeners = {};\r\n        }\r\n        const listeners = me._responsiveListeners;\r\n        const platform = me.platform;\r\n        const _add = (type, listener) => {\r\n          platform.addEventListener(me, type, listener);\r\n          listeners[type] = listener;\r\n        };\r\n        const _remove = (type, listener) => {\r\n          if (listeners[type]) {\r\n            platform.removeEventListener(me, type, listener);\r\n            delete listeners[type];\r\n          }\r\n        };\r\n        const listener = (width, height) => {\r\n          if (me.canvas) {\r\n            me.resize(width, height);\r\n          }\r\n        };\r\n        let detached;\r\n        const attached = () => {\r\n          _remove('attach', attached);\r\n          me.attached = true;\r\n          me.resize();\r\n          _add('resize', listener);\r\n          _add('detach', detached);\r\n        };\r\n        detached = () => {\r\n          me.attached = false;\r\n          _remove('resize', listener);\r\n          _add('attach', attached);\r\n        };\r\n        if (platform.isAttached(me.canvas)) {\r\n          attached();\r\n        } else {\r\n          detached();\r\n        }\r\n      }\r\n      unbindEvents() {\r\n        const me = this;\r\n        each(me._listeners, (listener, type) => {\r\n          me.platform.removeEventListener(me, type, listener);\r\n        });\r\n        me._listeners = {};\r\n        each(me._responsiveListeners, (listener, type) => {\r\n          me.platform.removeEventListener(me, type, listener);\r\n        });\r\n        me._responsiveListeners = undefined;\r\n      }\r\n      updateHoverStyle(items, mode, enabled) {\r\n        const prefix = enabled ? 'set' : 'remove';\r\n        let meta, item, i, ilen;\r\n        if (mode === 'dataset') {\r\n          meta = this.getDatasetMeta(items[0].datasetIndex);\r\n          meta.controller['_' + prefix + 'DatasetHoverStyle']();\r\n        }\r\n        for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n          item = items[i];\r\n          const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\r\n          if (controller) {\r\n            controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\r\n          }\r\n        }\r\n      }\r\n      getActiveElements() {\r\n        return this._active || [];\r\n      }\r\n      setActiveElements(activeElements) {\r\n        const me = this;\r\n        const lastActive = me._active || [];\r\n        const active = activeElements.map(({datasetIndex, index}) => {\r\n          const meta = me.getDatasetMeta(datasetIndex);\r\n          if (!meta) {\r\n            throw new Error('No dataset found at index ' + datasetIndex);\r\n          }\r\n          return {\r\n            datasetIndex,\r\n            element: meta.data[index],\r\n            index,\r\n          };\r\n        });\r\n        const changed = !_elementsEqual(active, lastActive);\r\n        if (changed) {\r\n          me._active = active;\r\n          me._updateHoverStyles(active, lastActive);\r\n        }\r\n      }\r\n      notifyPlugins(hook, args, filter) {\r\n        return this._plugins.notify(this, hook, args, filter);\r\n      }\r\n      _updateHoverStyles(active, lastActive, replay) {\r\n        const me = this;\r\n        const hoverOptions = me.options.hover;\r\n        const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\r\n        const deactivated = diff(lastActive, active);\r\n        const activated = replay ? active : diff(active, lastActive);\r\n        if (deactivated.length) {\r\n          me.updateHoverStyle(deactivated, hoverOptions.mode, false);\r\n        }\r\n        if (activated.length && hoverOptions.mode) {\r\n          me.updateHoverStyle(activated, hoverOptions.mode, true);\r\n        }\r\n      }\r\n      _eventHandler(e, replay) {\r\n        const me = this;\r\n        const args = {event: e, replay, cancelable: true};\r\n        const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.type);\r\n        if (me.notifyPlugins('beforeEvent', args, eventFilter) === false) {\r\n          return;\r\n        }\r\n        const changed = me._handleEvent(e, replay);\r\n        args.cancelable = false;\r\n        me.notifyPlugins('afterEvent', args, eventFilter);\r\n        if (changed || args.changed) {\r\n          me.render();\r\n        }\r\n        return me;\r\n      }\r\n      _handleEvent(e, replay) {\r\n        const me = this;\r\n        const {_active: lastActive = [], options} = me;\r\n        const hoverOptions = options.hover;\r\n        const useFinalPosition = replay;\r\n        let active = [];\r\n        let changed = false;\r\n        let lastEvent = null;\r\n        if (e.type !== 'mouseout') {\r\n          active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\r\n          lastEvent = e.type === 'click' ? me._lastEvent : e;\r\n        }\r\n        me._lastEvent = null;\r\n        if (_isPointInArea(e, me.chartArea, me._minPadding)) {\r\n          callback(options.onHover, [e, active, me], me);\r\n          if (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {\r\n            callback(options.onClick, [e, active, me], me);\r\n          }\r\n        }\r\n        changed = !_elementsEqual(active, lastActive);\r\n        if (changed || replay) {\r\n          me._active = active;\r\n          me._updateHoverStyles(active, lastActive, replay);\r\n        }\r\n        me._lastEvent = lastEvent;\r\n        return changed;\r\n      }\r\n    }\r\n    const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\r\n    const enumerable = true;\r\n    Object.defineProperties(Chart, {\r\n      defaults: {\r\n        enumerable,\r\n        value: defaults\r\n      },\r\n      instances: {\r\n        enumerable,\r\n        value: instances\r\n      },\r\n      overrides: {\r\n        enumerable,\r\n        value: overrides\r\n      },\r\n      registry: {\r\n        enumerable,\r\n        value: registry\r\n      },\r\n      version: {\r\n        enumerable,\r\n        value: version\r\n      },\r\n      getChart: {\r\n        enumerable,\r\n        value: getChart\r\n      },\r\n      register: {\r\n        enumerable,\r\n        value: (...items) => {\r\n          registry.add(...items);\r\n          invalidatePlugins();\r\n        }\r\n      },\r\n      unregister: {\r\n        enumerable,\r\n        value: (...items) => {\r\n          registry.remove(...items);\r\n          invalidatePlugins();\r\n        }\r\n      }\r\n    });\r\n    \r\n    function abstract() {\r\n      throw new Error('This method is not implemented: either no adapter can be found or an incomplete integration was provided.');\r\n    }\r\n    class DateAdapter {\r\n      constructor(options) {\r\n        this.options = options || {};\r\n      }\r\n      formats() {\r\n        return abstract();\r\n      }\r\n      parse(value, format) {\r\n        return abstract();\r\n      }\r\n      format(timestamp, format) {\r\n        return abstract();\r\n      }\r\n      add(timestamp, amount, unit) {\r\n        return abstract();\r\n      }\r\n      diff(a, b, unit) {\r\n        return abstract();\r\n      }\r\n      startOf(timestamp, unit, weekday) {\r\n        return abstract();\r\n      }\r\n      endOf(timestamp, unit) {\r\n        return abstract();\r\n      }\r\n    }\r\n    DateAdapter.override = function(members) {\r\n      Object.assign(DateAdapter.prototype, members);\r\n    };\r\n    var _adapters = {\r\n      _date: DateAdapter\r\n    };\r\n    \r\n    function getAllScaleValues(scale) {\r\n      if (!scale._cache.$bar) {\r\n        const metas = scale.getMatchingVisibleMetas('bar');\r\n        let values = [];\r\n        for (let i = 0, ilen = metas.length; i < ilen; i++) {\r\n          values = values.concat(metas[i].controller.getAllParsedValues(scale));\r\n        }\r\n        scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\r\n      }\r\n      return scale._cache.$bar;\r\n    }\r\n    function computeMinSampleSize(scale) {\r\n      const values = getAllScaleValues(scale);\r\n      let min = scale._length;\r\n      let i, ilen, curr, prev;\r\n      const updateMinAndPrev = () => {\r\n        if (curr === 32767 || curr === -32768) {\r\n          return;\r\n        }\r\n        if (defined(prev)) {\r\n          min = Math.min(min, Math.abs(curr - prev) || min);\r\n        }\r\n        prev = curr;\r\n      };\r\n      for (i = 0, ilen = values.length; i < ilen; ++i) {\r\n        curr = scale.getPixelForValue(values[i]);\r\n        updateMinAndPrev();\r\n      }\r\n      prev = undefined;\r\n      for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\r\n        curr = scale.getPixelForTick(i);\r\n        updateMinAndPrev();\r\n      }\r\n      return min;\r\n    }\r\n    function computeFitCategoryTraits(index, ruler, options, stackCount) {\r\n      const thickness = options.barThickness;\r\n      let size, ratio;\r\n      if (isNullOrUndef(thickness)) {\r\n        size = ruler.min * options.categoryPercentage;\r\n        ratio = options.barPercentage;\r\n      } else {\r\n        size = thickness * stackCount;\r\n        ratio = 1;\r\n      }\r\n      return {\r\n        chunk: size / stackCount,\r\n        ratio,\r\n        start: ruler.pixels[index] - (size / 2)\r\n      };\r\n    }\r\n    function computeFlexCategoryTraits(index, ruler, options, stackCount) {\r\n      const pixels = ruler.pixels;\r\n      const curr = pixels[index];\r\n      let prev = index > 0 ? pixels[index - 1] : null;\r\n      let next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n      const percent = options.categoryPercentage;\r\n      if (prev === null) {\r\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n      }\r\n      if (next === null) {\r\n        next = curr + curr - prev;\r\n      }\r\n      const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\r\n      const size = Math.abs(next - prev) / 2 * percent;\r\n      return {\r\n        chunk: size / stackCount,\r\n        ratio: options.barPercentage,\r\n        start\r\n      };\r\n    }\r\n    function parseFloatBar(entry, item, vScale, i) {\r\n      const startValue = vScale.parse(entry[0], i);\r\n      const endValue = vScale.parse(entry[1], i);\r\n      const min = Math.min(startValue, endValue);\r\n      const max = Math.max(startValue, endValue);\r\n      let barStart = min;\r\n      let barEnd = max;\r\n      if (Math.abs(min) > Math.abs(max)) {\r\n        barStart = max;\r\n        barEnd = min;\r\n      }\r\n      item[vScale.axis] = barEnd;\r\n      item._custom = {\r\n        barStart,\r\n        barEnd,\r\n        start: startValue,\r\n        end: endValue,\r\n        min,\r\n        max\r\n      };\r\n    }\r\n    function parseValue(entry, item, vScale, i) {\r\n      if (isArray(entry)) {\r\n        parseFloatBar(entry, item, vScale, i);\r\n      } else {\r\n        item[vScale.axis] = vScale.parse(entry, i);\r\n      }\r\n      return item;\r\n    }\r\n    function parseArrayOrPrimitive(meta, data, start, count) {\r\n      const iScale = meta.iScale;\r\n      const vScale = meta.vScale;\r\n      const labels = iScale.getLabels();\r\n      const singleScale = iScale === vScale;\r\n      const parsed = [];\r\n      let i, ilen, item, entry;\r\n      for (i = start, ilen = start + count; i < ilen; ++i) {\r\n        entry = data[i];\r\n        item = {};\r\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\r\n        parsed.push(parseValue(entry, item, vScale, i));\r\n      }\r\n      return parsed;\r\n    }\r\n    function isFloatBar(custom) {\r\n      return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\r\n    }\r\n    class BarController extends DatasetController {\r\n      parsePrimitiveData(meta, data, start, count) {\r\n        return parseArrayOrPrimitive(meta, data, start, count);\r\n      }\r\n      parseArrayData(meta, data, start, count) {\r\n        return parseArrayOrPrimitive(meta, data, start, count);\r\n      }\r\n      parseObjectData(meta, data, start, count) {\r\n        const {iScale, vScale} = meta;\r\n        const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n        const parsed = [];\r\n        let i, ilen, item, obj;\r\n        for (i = start, ilen = start + count; i < ilen; ++i) {\r\n          obj = data[i];\r\n          item = {};\r\n          item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\r\n          parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\r\n        }\r\n        return parsed;\r\n      }\r\n      updateRangeFromParsed(range, scale, parsed, stack) {\r\n        super.updateRangeFromParsed(range, scale, parsed, stack);\r\n        const custom = parsed._custom;\r\n        if (custom && scale === this._cachedMeta.vScale) {\r\n          range.min = Math.min(range.min, custom.min);\r\n          range.max = Math.max(range.max, custom.max);\r\n        }\r\n      }\r\n      getLabelAndValue(index) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const {iScale, vScale} = meta;\r\n        const parsed = me.getParsed(index);\r\n        const custom = parsed._custom;\r\n        const value = isFloatBar(custom)\r\n          ? '[' + custom.start + ', ' + custom.end + ']'\r\n          : '' + vScale.getLabelForValue(parsed[vScale.axis]);\r\n        return {\r\n          label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\r\n          value\r\n        };\r\n      }\r\n      initialize() {\r\n        const me = this;\r\n        me.enableOptionSharing = true;\r\n        super.initialize();\r\n        const meta = me._cachedMeta;\r\n        meta.stack = me.getDataset().stack;\r\n      }\r\n      update(mode) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        me.updateElements(meta.data, 0, meta.data.length, mode);\r\n      }\r\n      updateElements(bars, start, count, mode) {\r\n        const me = this;\r\n        const reset = mode === 'reset';\r\n        const vScale = me._cachedMeta.vScale;\r\n        const base = vScale.getBasePixel();\r\n        const horizontal = vScale.isHorizontal();\r\n        const ruler = me._getRuler();\r\n        const firstOpts = me.resolveDataElementOptions(start, mode);\r\n        const sharedOptions = me.getSharedOptions(firstOpts);\r\n        const includeOptions = me.includeOptions(mode, sharedOptions);\r\n        me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n        for (let i = start; i < start + count; i++) {\r\n          const parsed = me.getParsed(i);\r\n          const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : me._calculateBarValuePixels(i);\r\n          const ipixels = me._calculateBarIndexPixels(i, ruler);\r\n          const stack = (parsed._stacks || {})[vScale.axis];\r\n          const properties = {\r\n            horizontal,\r\n            base: vpixels.base,\r\n            enableBorderRadius: !stack || isFloatBar(parsed._custom) || (me.index === stack._top || me.index === stack._bottom),\r\n            x: horizontal ? vpixels.head : ipixels.center,\r\n            y: horizontal ? ipixels.center : vpixels.head,\r\n            height: horizontal ? ipixels.size : undefined,\r\n            width: horizontal ? undefined : ipixels.size\r\n          };\r\n          if (includeOptions) {\r\n            properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\r\n          }\r\n          me.updateElement(bars[i], i, properties, mode);\r\n        }\r\n      }\r\n      _getStacks(last, dataIndex) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const iScale = meta.iScale;\r\n        const metasets = iScale.getMatchingVisibleMetas(me._type);\r\n        const stacked = iScale.options.stacked;\r\n        const ilen = metasets.length;\r\n        const stacks = [];\r\n        let i, item;\r\n        for (i = 0; i < ilen; ++i) {\r\n          item = metasets[i];\r\n          if (typeof dataIndex !== 'undefined') {\r\n            const val = item.controller.getParsed(dataIndex)[\r\n              item.controller._cachedMeta.vScale.axis\r\n            ];\r\n            if (isNullOrUndef(val) || isNaN(val)) {\r\n              continue;\r\n            }\r\n          }\r\n          if (stacked === false || stacks.indexOf(item.stack) === -1 ||\r\n                    (stacked === undefined && item.stack === undefined)) {\r\n            stacks.push(item.stack);\r\n          }\r\n          if (item.index === last) {\r\n            break;\r\n          }\r\n        }\r\n        if (!stacks.length) {\r\n          stacks.push(undefined);\r\n        }\r\n        return stacks;\r\n      }\r\n      _getStackCount(index) {\r\n        return this._getStacks(undefined, index).length;\r\n      }\r\n      _getStackIndex(datasetIndex, name, dataIndex) {\r\n        const stacks = this._getStacks(datasetIndex, dataIndex);\r\n        const index = (name !== undefined)\r\n          ? stacks.indexOf(name)\r\n          : -1;\r\n        return (index === -1)\r\n          ? stacks.length - 1\r\n          : index;\r\n      }\r\n      _getRuler() {\r\n        const me = this;\r\n        const opts = me.options;\r\n        const meta = me._cachedMeta;\r\n        const iScale = meta.iScale;\r\n        const pixels = [];\r\n        let i, ilen;\r\n        for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\r\n          pixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));\r\n        }\r\n        const barThickness = opts.barThickness;\r\n        const min = barThickness || computeMinSampleSize(iScale);\r\n        return {\r\n          min,\r\n          pixels,\r\n          start: iScale._startPixel,\r\n          end: iScale._endPixel,\r\n          stackCount: me._getStackCount(),\r\n          scale: iScale,\r\n          grouped: opts.grouped,\r\n          ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\r\n        };\r\n      }\r\n      _calculateBarValuePixels(index) {\r\n        const me = this;\r\n        const {vScale, _stacked} = me._cachedMeta;\r\n        const {base: baseValue, minBarLength} = me.options;\r\n        const parsed = me.getParsed(index);\r\n        const custom = parsed._custom;\r\n        const floating = isFloatBar(custom);\r\n        let value = parsed[vScale.axis];\r\n        let start = 0;\r\n        let length = _stacked ? me.applyStack(vScale, parsed, _stacked) : value;\r\n        let head, size;\r\n        if (length !== value) {\r\n          start = length - value;\r\n          length = value;\r\n        }\r\n        if (floating) {\r\n          value = custom.barStart;\r\n          length = custom.barEnd - custom.barStart;\r\n          if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\r\n            start = 0;\r\n          }\r\n          start += value;\r\n        }\r\n        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\r\n        let base = vScale.getPixelForValue(startValue);\r\n        if (this.chart.getDataVisibility(index)) {\r\n          head = vScale.getPixelForValue(start + length);\r\n        } else {\r\n          head = base;\r\n        }\r\n        size = head - base;\r\n        if (minBarLength !== undefined && Math.abs(size) < minBarLength) {\r\n          size = size < 0 ? -minBarLength : minBarLength;\r\n          if (value === 0) {\r\n            base -= size / 2;\r\n          }\r\n          head = base + size;\r\n        }\r\n        const actualBase = baseValue || 0;\r\n        if (base === vScale.getPixelForValue(actualBase)) {\r\n          const halfGrid = vScale.getLineWidthForValue(actualBase) / 2;\r\n          if (size > 0) {\r\n            base += halfGrid;\r\n            size -= halfGrid;\r\n          } else if (size < 0) {\r\n            base -= halfGrid;\r\n            size += halfGrid;\r\n          }\r\n        }\r\n        return {\r\n          size,\r\n          base,\r\n          head,\r\n          center: head + size / 2\r\n        };\r\n      }\r\n      _calculateBarIndexPixels(index, ruler) {\r\n        const me = this;\r\n        const scale = ruler.scale;\r\n        const options = me.options;\r\n        const skipNull = options.skipNull;\r\n        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\r\n        let center, size;\r\n        if (ruler.grouped) {\r\n          const stackCount = skipNull ? me._getStackCount(index) : ruler.stackCount;\r\n          const range = options.barThickness === 'flex'\r\n            ? computeFlexCategoryTraits(index, ruler, options, stackCount)\r\n            : computeFitCategoryTraits(index, ruler, options, stackCount);\r\n          const stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack, skipNull ? index : undefined);\r\n          center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n          size = Math.min(maxBarThickness, range.chunk * range.ratio);\r\n        } else {\r\n          center = scale.getPixelForValue(me.getParsed(index)[scale.axis], index);\r\n          size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\r\n        }\r\n        return {\r\n          base: center - size / 2,\r\n          head: center + size / 2,\r\n          center,\r\n          size\r\n        };\r\n      }\r\n      draw() {\r\n        const me = this;\r\n        const chart = me.chart;\r\n        const meta = me._cachedMeta;\r\n        const vScale = meta.vScale;\r\n        const rects = meta.data;\r\n        const ilen = rects.length;\r\n        let i = 0;\r\n        clipArea(chart.ctx, chart.chartArea);\r\n        for (; i < ilen; ++i) {\r\n          if (me.getParsed(i)[vScale.axis] !== null) {\r\n            rects[i].draw(me._ctx);\r\n          }\r\n        }\r\n        unclipArea(chart.ctx);\r\n      }\r\n    }\r\n    BarController.id = 'bar';\r\n    BarController.defaults = {\r\n      datasetElementType: false,\r\n      dataElementType: 'bar',\r\n      categoryPercentage: 0.8,\r\n      barPercentage: 0.9,\r\n      grouped: true,\r\n      animations: {\r\n        numbers: {\r\n          type: 'number',\r\n          properties: ['x', 'y', 'base', 'width', 'height']\r\n        }\r\n      }\r\n    };\r\n    BarController.overrides = {\r\n      interaction: {\r\n        mode: 'index'\r\n      },\r\n      scales: {\r\n        _index_: {\r\n          type: 'category',\r\n          offset: true,\r\n          grid: {\r\n            offset: true\r\n          }\r\n        },\r\n        _value_: {\r\n          type: 'linear',\r\n          beginAtZero: true,\r\n        }\r\n      }\r\n    };\r\n    \r\n    class BubbleController extends DatasetController {\r\n      initialize() {\r\n        this.enableOptionSharing = true;\r\n        super.initialize();\r\n      }\r\n      parseObjectData(meta, data, start, count) {\r\n        const {xScale, yScale} = meta;\r\n        const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n        const parsed = [];\r\n        let i, ilen, item;\r\n        for (i = start, ilen = start + count; i < ilen; ++i) {\r\n          item = data[i];\r\n          parsed.push({\r\n            x: xScale.parse(resolveObjectKey(item, xAxisKey), i),\r\n            y: yScale.parse(resolveObjectKey(item, yAxisKey), i),\r\n            _custom: item && item.r && +item.r\r\n          });\r\n        }\r\n        return parsed;\r\n      }\r\n      getMaxOverflow() {\r\n        const {data, _parsed} = this._cachedMeta;\r\n        let max = 0;\r\n        for (let i = data.length - 1; i >= 0; --i) {\r\n          max = Math.max(max, data[i].size() / 2, _parsed[i]._custom);\r\n        }\r\n        return max > 0 && max;\r\n      }\r\n      getLabelAndValue(index) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const {xScale, yScale} = meta;\r\n        const parsed = me.getParsed(index);\r\n        const x = xScale.getLabelForValue(parsed.x);\r\n        const y = yScale.getLabelForValue(parsed.y);\r\n        const r = parsed._custom;\r\n        return {\r\n          label: meta.label,\r\n          value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\r\n        };\r\n      }\r\n      update(mode) {\r\n        const me = this;\r\n        const points = me._cachedMeta.data;\r\n        me.updateElements(points, 0, points.length, mode);\r\n      }\r\n      updateElements(points, start, count, mode) {\r\n        const me = this;\r\n        const reset = mode === 'reset';\r\n        const {iScale, vScale} = me._cachedMeta;\r\n        const firstOpts = me.resolveDataElementOptions(start, mode);\r\n        const sharedOptions = me.getSharedOptions(firstOpts);\r\n        const includeOptions = me.includeOptions(mode, sharedOptions);\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        for (let i = start; i < start + count; i++) {\r\n          const point = points[i];\r\n          const parsed = !reset && me.getParsed(i);\r\n          const properties = {};\r\n          const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\r\n          const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\r\n          properties.skip = isNaN(iPixel) || isNaN(vPixel);\r\n          if (includeOptions) {\r\n            properties.options = me.resolveDataElementOptions(i, mode);\r\n            if (reset) {\r\n              properties.options.radius = 0;\r\n            }\r\n          }\r\n          me.updateElement(point, i, properties, mode);\r\n        }\r\n        me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n      }\r\n      resolveDataElementOptions(index, mode) {\r\n        const parsed = this.getParsed(index);\r\n        let values = super.resolveDataElementOptions(index, mode);\r\n        if (values.$shared) {\r\n          values = Object.assign({}, values, {$shared: false});\r\n        }\r\n        const radius = values.radius;\r\n        if (mode !== 'active') {\r\n          values.radius = 0;\r\n        }\r\n        values.radius += valueOrDefault(parsed && parsed._custom, radius);\r\n        return values;\r\n      }\r\n    }\r\n    BubbleController.id = 'bubble';\r\n    BubbleController.defaults = {\r\n      datasetElementType: false,\r\n      dataElementType: 'point',\r\n      animations: {\r\n        numbers: {\r\n          type: 'number',\r\n          properties: ['x', 'y', 'borderWidth', 'radius']\r\n        }\r\n      }\r\n    };\r\n    BubbleController.overrides = {\r\n      scales: {\r\n        x: {\r\n          type: 'linear'\r\n        },\r\n        y: {\r\n          type: 'linear'\r\n        }\r\n      },\r\n      plugins: {\r\n        tooltip: {\r\n          callbacks: {\r\n            title() {\r\n              return '';\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    function getRatioAndOffset(rotation, circumference, cutout) {\r\n      let ratioX = 1;\r\n      let ratioY = 1;\r\n      let offsetX = 0;\r\n      let offsetY = 0;\r\n      if (circumference < TAU) {\r\n        const startAngle = rotation;\r\n        const endAngle = startAngle + circumference;\r\n        const startX = Math.cos(startAngle);\r\n        const startY = Math.sin(startAngle);\r\n        const endX = Math.cos(endAngle);\r\n        const endY = Math.sin(endAngle);\r\n        const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\r\n        const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\r\n        const maxX = calcMax(0, startX, endX);\r\n        const maxY = calcMax(HALF_PI, startY, endY);\r\n        const minX = calcMin(PI, startX, endX);\r\n        const minY = calcMin(PI + HALF_PI, startY, endY);\r\n        ratioX = (maxX - minX) / 2;\r\n        ratioY = (maxY - minY) / 2;\r\n        offsetX = -(maxX + minX) / 2;\r\n        offsetY = -(maxY + minY) / 2;\r\n      }\r\n      return {ratioX, ratioY, offsetX, offsetY};\r\n    }\r\n    class DoughnutController extends DatasetController {\r\n      constructor(chart, datasetIndex) {\r\n        super(chart, datasetIndex);\r\n        this.enableOptionSharing = true;\r\n        this.innerRadius = undefined;\r\n        this.outerRadius = undefined;\r\n        this.offsetX = undefined;\r\n        this.offsetY = undefined;\r\n      }\r\n      linkScales() {}\r\n      parse(start, count) {\r\n        const data = this.getDataset().data;\r\n        const meta = this._cachedMeta;\r\n        let i, ilen;\r\n        for (i = start, ilen = start + count; i < ilen; ++i) {\r\n          meta._parsed[i] = +data[i];\r\n        }\r\n      }\r\n      _getRotation() {\r\n        return toRadians(this.options.rotation - 90);\r\n      }\r\n      _getCircumference() {\r\n        return toRadians(this.options.circumference);\r\n      }\r\n      _getRotationExtents() {\r\n        let min = TAU;\r\n        let max = -TAU;\r\n        const me = this;\r\n        for (let i = 0; i < me.chart.data.datasets.length; ++i) {\r\n          if (me.chart.isDatasetVisible(i)) {\r\n            const controller = me.chart.getDatasetMeta(i).controller;\r\n            const rotation = controller._getRotation();\r\n            const circumference = controller._getCircumference();\r\n            min = Math.min(min, rotation);\r\n            max = Math.max(max, rotation + circumference);\r\n          }\r\n        }\r\n        return {\r\n          rotation: min,\r\n          circumference: max - min,\r\n        };\r\n      }\r\n      update(mode) {\r\n        const me = this;\r\n        const chart = me.chart;\r\n        const {chartArea} = chart;\r\n        const meta = me._cachedMeta;\r\n        const arcs = meta.data;\r\n        const spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs);\r\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\r\n        const cutout = Math.min(toPercentage(me.options.cutout, maxSize), 1);\r\n        const chartWeight = me._getRingWeight(me.index);\r\n        const {circumference, rotation} = me._getRotationExtents();\r\n        const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\r\n        const maxWidth = (chartArea.width - spacing) / ratioX;\r\n        const maxHeight = (chartArea.height - spacing) / ratioY;\r\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n        const outerRadius = toDimension(me.options.radius, maxRadius);\r\n        const innerRadius = Math.max(outerRadius * cutout, 0);\r\n        const radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();\r\n        me.offsetX = offsetX * outerRadius;\r\n        me.offsetY = offsetY * outerRadius;\r\n        meta.total = me.calculateTotal();\r\n        me.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);\r\n        me.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);\r\n        me.updateElements(arcs, 0, arcs.length, mode);\r\n      }\r\n      _circumference(i, reset) {\r\n        const me = this;\r\n        const opts = me.options;\r\n        const meta = me._cachedMeta;\r\n        const circumference = me._getCircumference();\r\n        if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null) {\r\n          return 0;\r\n        }\r\n        return me.calculateCircumference(meta._parsed[i] * circumference / TAU);\r\n      }\r\n      updateElements(arcs, start, count, mode) {\r\n        const me = this;\r\n        const reset = mode === 'reset';\r\n        const chart = me.chart;\r\n        const chartArea = chart.chartArea;\r\n        const opts = chart.options;\r\n        const animationOpts = opts.animation;\r\n        const centerX = (chartArea.left + chartArea.right) / 2;\r\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\r\n        const animateScale = reset && animationOpts.animateScale;\r\n        const innerRadius = animateScale ? 0 : me.innerRadius;\r\n        const outerRadius = animateScale ? 0 : me.outerRadius;\r\n        const firstOpts = me.resolveDataElementOptions(start, mode);\r\n        const sharedOptions = me.getSharedOptions(firstOpts);\r\n        const includeOptions = me.includeOptions(mode, sharedOptions);\r\n        let startAngle = me._getRotation();\r\n        let i;\r\n        for (i = 0; i < start; ++i) {\r\n          startAngle += me._circumference(i, reset);\r\n        }\r\n        for (i = start; i < start + count; ++i) {\r\n          const circumference = me._circumference(i, reset);\r\n          const arc = arcs[i];\r\n          const properties = {\r\n            x: centerX + me.offsetX,\r\n            y: centerY + me.offsetY,\r\n            startAngle,\r\n            endAngle: startAngle + circumference,\r\n            circumference,\r\n            outerRadius,\r\n            innerRadius\r\n          };\r\n          if (includeOptions) {\r\n            properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\r\n          }\r\n          startAngle += circumference;\r\n          me.updateElement(arc, i, properties, mode);\r\n        }\r\n        me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n      }\r\n      calculateTotal() {\r\n        const meta = this._cachedMeta;\r\n        const metaData = meta.data;\r\n        let total = 0;\r\n        let i;\r\n        for (i = 0; i < metaData.length; i++) {\r\n          const value = meta._parsed[i];\r\n          if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i)) {\r\n            total += Math.abs(value);\r\n          }\r\n        }\r\n        return total;\r\n      }\r\n      calculateCircumference(value) {\r\n        const total = this._cachedMeta.total;\r\n        if (total > 0 && !isNaN(value)) {\r\n          return TAU * (Math.abs(value) / total);\r\n        }\r\n        return 0;\r\n      }\r\n      getLabelAndValue(index) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const chart = me.chart;\r\n        const labels = chart.data.labels || [];\r\n        const value = formatNumber(meta._parsed[index], chart.options.locale);\r\n        return {\r\n          label: labels[index] || '',\r\n          value,\r\n        };\r\n      }\r\n      getMaxBorderWidth(arcs) {\r\n        const me = this;\r\n        let max = 0;\r\n        const chart = me.chart;\r\n        let i, ilen, meta, controller, options;\r\n        if (!arcs) {\r\n          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n            if (chart.isDatasetVisible(i)) {\r\n              meta = chart.getDatasetMeta(i);\r\n              arcs = meta.data;\r\n              controller = meta.controller;\r\n              if (controller !== me) {\r\n                controller.configure();\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (!arcs) {\r\n          return 0;\r\n        }\r\n        for (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n          options = controller.resolveDataElementOptions(i);\r\n          if (options.borderAlign !== 'inner') {\r\n            max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\r\n          }\r\n        }\r\n        return max;\r\n      }\r\n      getMaxOffset(arcs) {\r\n        let max = 0;\r\n        for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n          const options = this.resolveDataElementOptions(i);\r\n          max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\r\n        }\r\n        return max;\r\n      }\r\n      _getRingWeightOffset(datasetIndex) {\r\n        let ringWeightOffset = 0;\r\n        for (let i = 0; i < datasetIndex; ++i) {\r\n          if (this.chart.isDatasetVisible(i)) {\r\n            ringWeightOffset += this._getRingWeight(i);\r\n          }\r\n        }\r\n        return ringWeightOffset;\r\n      }\r\n      _getRingWeight(datasetIndex) {\r\n        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\r\n      }\r\n      _getVisibleDatasetWeightTotal() {\r\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\r\n      }\r\n    }\r\n    DoughnutController.id = 'doughnut';\r\n    DoughnutController.defaults = {\r\n      datasetElementType: false,\r\n      dataElementType: 'arc',\r\n      animation: {\r\n        animateRotate: true,\r\n        animateScale: false\r\n      },\r\n      animations: {\r\n        numbers: {\r\n          type: 'number',\r\n          properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth']\r\n        },\r\n      },\r\n      cutout: '50%',\r\n      rotation: 0,\r\n      circumference: 360,\r\n      radius: '100%',\r\n      indexAxis: 'r',\r\n    };\r\n    DoughnutController.overrides = {\r\n      aspectRatio: 1,\r\n      plugins: {\r\n        legend: {\r\n          labels: {\r\n            generateLabels(chart) {\r\n              const data = chart.data;\r\n              if (data.labels.length && data.datasets.length) {\r\n                return data.labels.map((label, i) => {\r\n                  const meta = chart.getDatasetMeta(0);\r\n                  const style = meta.controller.getStyle(i);\r\n                  return {\r\n                    text: label,\r\n                    fillStyle: style.backgroundColor,\r\n                    strokeStyle: style.borderColor,\r\n                    lineWidth: style.borderWidth,\r\n                    hidden: !chart.getDataVisibility(i),\r\n                    index: i\r\n                  };\r\n                });\r\n              }\r\n              return [];\r\n            }\r\n          },\r\n          onClick(e, legendItem, legend) {\r\n            legend.chart.toggleDataVisibility(legendItem.index);\r\n            legend.chart.update();\r\n          }\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            title() {\r\n              return '';\r\n            },\r\n            label(tooltipItem) {\r\n              let dataLabel = tooltipItem.label;\r\n              const value = ': ' + tooltipItem.formattedValue;\r\n              if (isArray(dataLabel)) {\r\n                dataLabel = dataLabel.slice();\r\n                dataLabel[0] += value;\r\n              } else {\r\n                dataLabel += value;\r\n              }\r\n              return dataLabel;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n    \r\n    class LineController extends DatasetController {\r\n      initialize() {\r\n        this.enableOptionSharing = true;\r\n        super.initialize();\r\n      }\r\n      update(mode) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const {dataset: line, data: points = [], _dataset} = meta;\r\n        const animationsDisabled = me.chart._animationsDisabled;\r\n        let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n        me._drawStart = start;\r\n        me._drawCount = count;\r\n        if (scaleRangesChanged(meta)) {\r\n          start = 0;\r\n          count = points.length;\r\n        }\r\n        line._decimated = !!_dataset._decimated;\r\n        line.points = points;\r\n        const options = me.resolveDatasetElementOptions(mode);\r\n        if (!me.options.showLine) {\r\n          options.borderWidth = 0;\r\n        }\r\n        options.segment = me.options.segment;\r\n        me.updateElement(line, undefined, {\r\n          animated: !animationsDisabled,\r\n          options\r\n        }, mode);\r\n        me.updateElements(points, start, count, mode);\r\n      }\r\n      updateElements(points, start, count, mode) {\r\n        const me = this;\r\n        const reset = mode === 'reset';\r\n        const {iScale, vScale, _stacked} = me._cachedMeta;\r\n        const firstOpts = me.resolveDataElementOptions(start, mode);\r\n        const sharedOptions = me.getSharedOptions(firstOpts);\r\n        const includeOptions = me.includeOptions(mode, sharedOptions);\r\n        const iAxis = iScale.axis;\r\n        const vAxis = vScale.axis;\r\n        const spanGaps = me.options.spanGaps;\r\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n        const directUpdate = me.chart._animationsDisabled || reset || mode === 'none';\r\n        let prevParsed = start > 0 && me.getParsed(start - 1);\r\n        for (let i = start; i < start + count; ++i) {\r\n          const point = points[i];\r\n          const parsed = me.getParsed(i);\r\n          const properties = directUpdate ? point : {};\r\n          const nullData = isNullOrUndef(parsed[vAxis]);\r\n          const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n          const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? me.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n          properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n          properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\r\n          properties.parsed = parsed;\r\n          if (includeOptions) {\r\n            properties.options = sharedOptions || me.resolveDataElementOptions(i, mode);\r\n          }\r\n          if (!directUpdate) {\r\n            me.updateElement(point, i, properties, mode);\r\n          }\r\n          prevParsed = parsed;\r\n        }\r\n        me.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n      }\r\n      getMaxOverflow() {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const dataset = meta.dataset;\r\n        const border = dataset.options && dataset.options.borderWidth || 0;\r\n        const data = meta.data || [];\r\n        if (!data.length) {\r\n          return border;\r\n        }\r\n        const firstPoint = data[0].size(me.resolveDataElementOptions(0));\r\n        const lastPoint = data[data.length - 1].size(me.resolveDataElementOptions(data.length - 1));\r\n        return Math.max(border, firstPoint, lastPoint) / 2;\r\n      }\r\n      draw() {\r\n        const meta = this._cachedMeta;\r\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\r\n        super.draw();\r\n      }\r\n    }\r\n    LineController.id = 'line';\r\n    LineController.defaults = {\r\n      datasetElementType: 'line',\r\n      dataElementType: 'point',\r\n      showLine: true,\r\n      spanGaps: false,\r\n    };\r\n    LineController.overrides = {\r\n      scales: {\r\n        _index_: {\r\n          type: 'category',\r\n        },\r\n        _value_: {\r\n          type: 'linear',\r\n        },\r\n      }\r\n    };\r\n    function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\r\n      const pointCount = points.length;\r\n      let start = 0;\r\n      let count = pointCount;\r\n      if (meta._sorted) {\r\n        const {iScale, _parsed} = meta;\r\n        const axis = iScale.axis;\r\n        const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n        if (minDefined) {\r\n          start = _limitValue(Math.min(\r\n            _lookupByKey(_parsed, iScale.axis, min).lo,\r\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\r\n          0, pointCount - 1);\r\n        }\r\n        if (maxDefined) {\r\n          count = _limitValue(Math.max(\r\n            _lookupByKey(_parsed, iScale.axis, max).hi + 1,\r\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),\r\n          start, pointCount) - start;\r\n        } else {\r\n          count = pointCount - start;\r\n        }\r\n      }\r\n      return {start, count};\r\n    }\r\n    function scaleRangesChanged(meta) {\r\n      const {xScale, yScale, _scaleRanges} = meta;\r\n      const newRanges = {\r\n        xmin: xScale.min,\r\n        xmax: xScale.max,\r\n        ymin: yScale.min,\r\n        ymax: yScale.max\r\n      };\r\n      if (!_scaleRanges) {\r\n        meta._scaleRanges = newRanges;\r\n        return true;\r\n      }\r\n      const changed = _scaleRanges.xmin !== xScale.min\r\n            || _scaleRanges.xmax !== xScale.max\r\n            || _scaleRanges.ymin !== yScale.min\r\n            || _scaleRanges.ymax !== yScale.max;\r\n      Object.assign(_scaleRanges, newRanges);\r\n      return changed;\r\n    }\r\n    \r\n    class PolarAreaController extends DatasetController {\r\n      constructor(chart, datasetIndex) {\r\n        super(chart, datasetIndex);\r\n        this.innerRadius = undefined;\r\n        this.outerRadius = undefined;\r\n      }\r\n      getLabelAndValue(index) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const chart = me.chart;\r\n        const labels = chart.data.labels || [];\r\n        const value = formatNumber(meta._parsed[index].r, chart.options.locale);\r\n        return {\r\n          label: labels[index] || '',\r\n          value,\r\n        };\r\n      }\r\n      update(mode) {\r\n        const arcs = this._cachedMeta.data;\r\n        this._updateRadius();\r\n        this.updateElements(arcs, 0, arcs.length, mode);\r\n      }\r\n      _updateRadius() {\r\n        const me = this;\r\n        const chart = me.chart;\r\n        const chartArea = chart.chartArea;\r\n        const opts = chart.options;\r\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n        const outerRadius = Math.max(minSize / 2, 0);\r\n        const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\r\n        me.outerRadius = outerRadius - (radiusLength * me.index);\r\n        me.innerRadius = me.outerRadius - radiusLength;\r\n      }\r\n      updateElements(arcs, start, count, mode) {\r\n        const me = this;\r\n        const reset = mode === 'reset';\r\n        const chart = me.chart;\r\n        const dataset = me.getDataset();\r\n        const opts = chart.options;\r\n        const animationOpts = opts.animation;\r\n        const scale = me._cachedMeta.rScale;\r\n        const centerX = scale.xCenter;\r\n        const centerY = scale.yCenter;\r\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\r\n        let angle = datasetStartAngle;\r\n        let i;\r\n        const defaultAngle = 360 / me.countVisibleElements();\r\n        for (i = 0; i < start; ++i) {\r\n          angle += me._computeAngle(i, mode, defaultAngle);\r\n        }\r\n        for (i = start; i < start + count; i++) {\r\n          const arc = arcs[i];\r\n          let startAngle = angle;\r\n          let endAngle = angle + me._computeAngle(i, mode, defaultAngle);\r\n          let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\r\n          angle = endAngle;\r\n          if (reset) {\r\n            if (animationOpts.animateScale) {\r\n              outerRadius = 0;\r\n            }\r\n            if (animationOpts.animateRotate) {\r\n              startAngle = endAngle = datasetStartAngle;\r\n            }\r\n          }\r\n          const properties = {\r\n            x: centerX,\r\n            y: centerY,\r\n            innerRadius: 0,\r\n            outerRadius,\r\n            startAngle,\r\n            endAngle,\r\n            options: me.resolveDataElementOptions(i, mode)\r\n          };\r\n          me.updateElement(arc, i, properties, mode);\r\n        }\r\n      }\r\n      countVisibleElements() {\r\n        const dataset = this.getDataset();\r\n        const meta = this._cachedMeta;\r\n        let count = 0;\r\n        meta.data.forEach((element, index) => {\r\n          if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\r\n            count++;\r\n          }\r\n        });\r\n        return count;\r\n      }\r\n      _computeAngle(index, mode, defaultAngle) {\r\n        return this.chart.getDataVisibility(index)\r\n          ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\r\n          : 0;\r\n      }\r\n    }\r\n    PolarAreaController.id = 'polarArea';\r\n    PolarAreaController.defaults = {\r\n      dataElementType: 'arc',\r\n      animation: {\r\n        animateRotate: true,\r\n        animateScale: true\r\n      },\r\n      animations: {\r\n        numbers: {\r\n          type: 'number',\r\n          properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\r\n        },\r\n      },\r\n      indexAxis: 'r',\r\n      startAngle: 0,\r\n    };\r\n    PolarAreaController.overrides = {\r\n      aspectRatio: 1,\r\n      plugins: {\r\n        legend: {\r\n          labels: {\r\n            generateLabels(chart) {\r\n              const data = chart.data;\r\n              if (data.labels.length && data.datasets.length) {\r\n                return data.labels.map((label, i) => {\r\n                  const meta = chart.getDatasetMeta(0);\r\n                  const style = meta.controller.getStyle(i);\r\n                  return {\r\n                    text: label,\r\n                    fillStyle: style.backgroundColor,\r\n                    strokeStyle: style.borderColor,\r\n                    lineWidth: style.borderWidth,\r\n                    hidden: !chart.getDataVisibility(i),\r\n                    index: i\r\n                  };\r\n                });\r\n              }\r\n              return [];\r\n            }\r\n          },\r\n          onClick(e, legendItem, legend) {\r\n            legend.chart.toggleDataVisibility(legendItem.index);\r\n            legend.chart.update();\r\n          }\r\n        },\r\n        tooltip: {\r\n          callbacks: {\r\n            title() {\r\n              return '';\r\n            },\r\n            label(context) {\r\n              return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\r\n            }\r\n          }\r\n        }\r\n      },\r\n      scales: {\r\n        r: {\r\n          type: 'radialLinear',\r\n          angleLines: {\r\n            display: false\r\n          },\r\n          beginAtZero: true,\r\n          grid: {\r\n            circular: true\r\n          },\r\n          pointLabels: {\r\n            display: false\r\n          },\r\n          startAngle: 0\r\n        }\r\n      }\r\n    };\r\n    \r\n    class PieController extends DoughnutController {\r\n    }\r\n    PieController.id = 'pie';\r\n    PieController.defaults = {\r\n      cutout: 0,\r\n      rotation: 0,\r\n      circumference: 360,\r\n      radius: '100%'\r\n    };\r\n    \r\n    class RadarController extends DatasetController {\r\n      getLabelAndValue(index) {\r\n        const me = this;\r\n        const vScale = me._cachedMeta.vScale;\r\n        const parsed = me.getParsed(index);\r\n        return {\r\n          label: vScale.getLabels()[index],\r\n          value: '' + vScale.getLabelForValue(parsed[vScale.axis])\r\n        };\r\n      }\r\n      update(mode) {\r\n        const me = this;\r\n        const meta = me._cachedMeta;\r\n        const line = meta.dataset;\r\n        const points = meta.data || [];\r\n        const labels = meta.iScale.getLabels();\r\n        line.points = points;\r\n        if (mode !== 'resize') {\r\n          const options = me.resolveDatasetElementOptions(mode);\r\n          if (!me.options.showLine) {\r\n            options.borderWidth = 0;\r\n          }\r\n          const properties = {\r\n            _loop: true,\r\n            _fullLoop: labels.length === points.length,\r\n            options\r\n          };\r\n          me.updateElement(line, undefined, properties, mode);\r\n        }\r\n        me.updateElements(points, 0, points.length, mode);\r\n      }\r\n      updateElements(points, start, count, mode) {\r\n        const me = this;\r\n        const dataset = me.getDataset();\r\n        const scale = me._cachedMeta.rScale;\r\n        const reset = mode === 'reset';\r\n        for (let i = start; i < start + count; i++) {\r\n          const point = points[i];\r\n          const options = me.resolveDataElementOptions(i, mode);\r\n          const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\r\n          const x = reset ? scale.xCenter : pointPosition.x;\r\n          const y = reset ? scale.yCenter : pointPosition.y;\r\n          const properties = {\r\n            x,\r\n            y,\r\n            angle: pointPosition.angle,\r\n            skip: isNaN(x) || isNaN(y),\r\n            options\r\n          };\r\n          me.updateElement(point, i, properties, mode);\r\n        }\r\n      }\r\n    }\r\n    RadarController.id = 'radar';\r\n    RadarController.defaults = {\r\n      datasetElementType: 'line',\r\n      dataElementType: 'point',\r\n      indexAxis: 'r',\r\n      showLine: true,\r\n      elements: {\r\n        line: {\r\n          fill: 'start'\r\n        }\r\n      },\r\n    };\r\n    RadarController.overrides = {\r\n      aspectRatio: 1,\r\n      scales: {\r\n        r: {\r\n          type: 'radialLinear',\r\n        }\r\n      }\r\n    };\r\n    \r\n    class ScatterController extends LineController {\r\n    }\r\n    ScatterController.id = 'scatter';\r\n    ScatterController.defaults = {\r\n      showLine: false,\r\n      fill: false\r\n    };\r\n    ScatterController.overrides = {\r\n      interaction: {\r\n        mode: 'point'\r\n      },\r\n      plugins: {\r\n        tooltip: {\r\n          callbacks: {\r\n            title() {\r\n              return '';\r\n            },\r\n            label(item) {\r\n              return '(' + item.label + ', ' + item.formattedValue + ')';\r\n            }\r\n          }\r\n        }\r\n      },\r\n      scales: {\r\n        x: {\r\n          type: 'linear'\r\n        },\r\n        y: {\r\n          type: 'linear'\r\n        }\r\n      }\r\n    };\r\n    \r\n    var controllers = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    BarController: BarController,\r\n    BubbleController: BubbleController,\r\n    DoughnutController: DoughnutController,\r\n    LineController: LineController,\r\n    PolarAreaController: PolarAreaController,\r\n    PieController: PieController,\r\n    RadarController: RadarController,\r\n    ScatterController: ScatterController\r\n    });\r\n    \r\n    function clipArc(ctx, element) {\r\n      const {startAngle, endAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\r\n      let angleMargin = pixelMargin / outerRadius;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n      if (innerRadius > pixelMargin) {\r\n        angleMargin = pixelMargin / innerRadius;\r\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\r\n      } else {\r\n        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\r\n      }\r\n      ctx.closePath();\r\n      ctx.clip();\r\n    }\r\n    function toRadiusCorners(value) {\r\n      return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\r\n    }\r\n    function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\r\n      const o = toRadiusCorners(arc.options.borderRadius);\r\n      const halfThickness = (outerRadius - innerRadius) / 2;\r\n      const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\r\n      const computeOuterLimit = (val) => {\r\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\r\n        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\r\n      };\r\n      return {\r\n        outerStart: computeOuterLimit(o.outerStart),\r\n        outerEnd: computeOuterLimit(o.outerEnd),\r\n        innerStart: _limitValue(o.innerStart, 0, innerLimit),\r\n        innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\r\n      };\r\n    }\r\n    function rThetaToXY(r, theta, x, y) {\r\n      return {\r\n        x: x + r * Math.cos(theta),\r\n        y: y + r * Math.sin(theta),\r\n      };\r\n    }\r\n    function pathArc(ctx, element, offset) {\r\n      const {x, y, startAngle: start, endAngle: end, pixelMargin, innerRadius: innerR} = element;\r\n      const outerRadius = Math.max(element.outerRadius + offset - pixelMargin, 0);\r\n      const innerRadius = innerR > 0 ? innerR + offset + pixelMargin : 0;\r\n      const alpha = end - start;\r\n      const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\r\n      const angleOffset = (alpha - beta) / 2;\r\n      const startAngle = start + angleOffset;\r\n      const endAngle = end - angleOffset;\r\n      const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\r\n      const outerStartAdjustedRadius = outerRadius - outerStart;\r\n      const outerEndAdjustedRadius = outerRadius - outerEnd;\r\n      const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\r\n      const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\r\n      const innerStartAdjustedRadius = innerRadius + innerStart;\r\n      const innerEndAdjustedRadius = innerRadius + innerEnd;\r\n      const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\r\n      const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\r\n      if (outerEnd > 0) {\r\n        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\r\n        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\r\n      }\r\n      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\r\n      ctx.lineTo(p4.x, p4.y);\r\n      if (innerEnd > 0) {\r\n        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\r\n        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\r\n      }\r\n      ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\r\n      if (innerStart > 0) {\r\n        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\r\n        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\r\n      }\r\n      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\r\n      ctx.lineTo(p8.x, p8.y);\r\n      if (outerStart > 0) {\r\n        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\r\n        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\r\n      }\r\n      ctx.closePath();\r\n    }\r\n    function drawArc(ctx, element, offset) {\r\n      if (element.fullCircles) {\r\n        element.endAngle = element.startAngle + TAU;\r\n        pathArc(ctx, element, offset);\r\n        for (let i = 0; i < element.fullCircles; ++i) {\r\n          ctx.fill();\r\n        }\r\n      }\r\n      if (!isNaN(element.circumference)) {\r\n        element.endAngle = element.startAngle + element.circumference % TAU;\r\n      }\r\n      pathArc(ctx, element, offset);\r\n      ctx.fill();\r\n    }\r\n    function drawFullCircleBorders(ctx, element, inner) {\r\n      const {x, y, startAngle, endAngle, pixelMargin} = element;\r\n      const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\r\n      const innerRadius = element.innerRadius + pixelMargin;\r\n      let i;\r\n      if (inner) {\r\n        element.endAngle = element.startAngle + TAU;\r\n        clipArc(ctx, element);\r\n        element.endAngle = endAngle;\r\n        if (element.endAngle === element.startAngle) {\r\n          element.endAngle += TAU;\r\n          element.fullCircles--;\r\n        }\r\n      }\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\r\n      for (i = 0; i < element.fullCircles; ++i) {\r\n        ctx.stroke();\r\n      }\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\r\n      for (i = 0; i < element.fullCircles; ++i) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n    function drawBorder(ctx, element, offset) {\r\n      const {options} = element;\r\n      const inner = options.borderAlign === 'inner';\r\n      if (!options.borderWidth) {\r\n        return;\r\n      }\r\n      if (inner) {\r\n        ctx.lineWidth = options.borderWidth * 2;\r\n        ctx.lineJoin = 'round';\r\n      } else {\r\n        ctx.lineWidth = options.borderWidth;\r\n        ctx.lineJoin = 'bevel';\r\n      }\r\n      if (element.fullCircles) {\r\n        drawFullCircleBorders(ctx, element, inner);\r\n      }\r\n      if (inner) {\r\n        clipArc(ctx, element);\r\n      }\r\n      pathArc(ctx, element, offset);\r\n      ctx.stroke();\r\n    }\r\n    class ArcElement extends Element {\r\n      constructor(cfg) {\r\n        super();\r\n        this.options = undefined;\r\n        this.circumference = undefined;\r\n        this.startAngle = undefined;\r\n        this.endAngle = undefined;\r\n        this.innerRadius = undefined;\r\n        this.outerRadius = undefined;\r\n        this.pixelMargin = 0;\r\n        this.fullCircles = 0;\r\n        if (cfg) {\r\n          Object.assign(this, cfg);\r\n        }\r\n      }\r\n      inRange(chartX, chartY, useFinalPosition) {\r\n        const point = this.getProps(['x', 'y'], useFinalPosition);\r\n        const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\r\n        const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\r\n          'startAngle',\r\n          'endAngle',\r\n          'innerRadius',\r\n          'outerRadius',\r\n          'circumference'\r\n        ], useFinalPosition);\r\n        const betweenAngles = circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\r\n        const withinRadius = (distance >= innerRadius && distance <= outerRadius);\r\n        return (betweenAngles && withinRadius);\r\n      }\r\n      getCenterPoint(useFinalPosition) {\r\n        const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\r\n          'x',\r\n          'y',\r\n          'startAngle',\r\n          'endAngle',\r\n          'innerRadius',\r\n          'outerRadius'\r\n        ], useFinalPosition);\r\n        const halfAngle = (startAngle + endAngle) / 2;\r\n        const halfRadius = (innerRadius + outerRadius) / 2;\r\n        return {\r\n          x: x + Math.cos(halfAngle) * halfRadius,\r\n          y: y + Math.sin(halfAngle) * halfRadius\r\n        };\r\n      }\r\n      tooltipPosition(useFinalPosition) {\r\n        return this.getCenterPoint(useFinalPosition);\r\n      }\r\n      draw(ctx) {\r\n        const me = this;\r\n        const options = me.options;\r\n        const offset = (options.offset || 0) / 2;\r\n        me.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\r\n        me.fullCircles = Math.floor(me.circumference / TAU);\r\n        if (me.circumference === 0 || me.innerRadius < 0 || me.outerRadius < 0) {\r\n          return;\r\n        }\r\n        ctx.save();\r\n        let radiusOffset = 0;\r\n        if (offset) {\r\n          radiusOffset = offset / 2;\r\n          const halfAngle = (me.startAngle + me.endAngle) / 2;\r\n          ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\r\n          if (me.circumference >= PI) {\r\n            radiusOffset = offset;\r\n          }\r\n        }\r\n        ctx.fillStyle = options.backgroundColor;\r\n        ctx.strokeStyle = options.borderColor;\r\n        drawArc(ctx, me, radiusOffset);\r\n        drawBorder(ctx, me, radiusOffset);\r\n        ctx.restore();\r\n      }\r\n    }\r\n    ArcElement.id = 'arc';\r\n    ArcElement.defaults = {\r\n      borderAlign: 'center',\r\n      borderColor: '#fff',\r\n      borderRadius: 0,\r\n      borderWidth: 2,\r\n      offset: 0,\r\n      angle: undefined,\r\n    };\r\n    ArcElement.defaultRoutes = {\r\n      backgroundColor: 'backgroundColor'\r\n    };\r\n    \r\n    function setStyle(ctx, options, style = options) {\r\n      ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\r\n      ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\r\n      ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\r\n      ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\r\n      ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\r\n      ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\r\n    }\r\n    function lineTo(ctx, previous, target) {\r\n      ctx.lineTo(target.x, target.y);\r\n    }\r\n    function getLineMethod(options) {\r\n      if (options.stepped) {\r\n        return _steppedLineTo;\r\n      }\r\n      if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n        return _bezierCurveTo;\r\n      }\r\n      return lineTo;\r\n    }\r\n    function pathVars(points, segment, params = {}) {\r\n      const count = points.length;\r\n      const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\r\n      const {start: segmentStart, end: segmentEnd} = segment;\r\n      const start = Math.max(paramsStart, segmentStart);\r\n      const end = Math.min(paramsEnd, segmentEnd);\r\n      const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\r\n      return {\r\n        count,\r\n        start,\r\n        loop: segment.loop,\r\n        ilen: end < start && !outside ? count + end - start : end - start\r\n      };\r\n    }\r\n    function pathSegment(ctx, line, segment, params) {\r\n      const {points, options} = line;\r\n      const {count, start, loop, ilen} = pathVars(points, segment, params);\r\n      const lineMethod = getLineMethod(options);\r\n      let {move = true, reverse} = params || {};\r\n      let i, point, prev;\r\n      for (i = 0; i <= ilen; ++i) {\r\n        point = points[(start + (reverse ? ilen - i : i)) % count];\r\n        if (point.skip) {\r\n          continue;\r\n        } else if (move) {\r\n          ctx.moveTo(point.x, point.y);\r\n          move = false;\r\n        } else {\r\n          lineMethod(ctx, prev, point, reverse, options.stepped);\r\n        }\r\n        prev = point;\r\n      }\r\n      if (loop) {\r\n        point = points[(start + (reverse ? ilen : 0)) % count];\r\n        lineMethod(ctx, prev, point, reverse, options.stepped);\r\n      }\r\n      return !!loop;\r\n    }\r\n    function fastPathSegment(ctx, line, segment, params) {\r\n      const points = line.points;\r\n      const {count, start, ilen} = pathVars(points, segment, params);\r\n      const {move = true, reverse} = params || {};\r\n      let avgX = 0;\r\n      let countX = 0;\r\n      let i, point, prevX, minY, maxY, lastY;\r\n      const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\r\n      const drawX = () => {\r\n        if (minY !== maxY) {\r\n          ctx.lineTo(avgX, maxY);\r\n          ctx.lineTo(avgX, minY);\r\n          ctx.lineTo(avgX, lastY);\r\n        }\r\n      };\r\n      if (move) {\r\n        point = points[pointIndex(0)];\r\n        ctx.moveTo(point.x, point.y);\r\n      }\r\n      for (i = 0; i <= ilen; ++i) {\r\n        point = points[pointIndex(i)];\r\n        if (point.skip) {\r\n          continue;\r\n        }\r\n        const x = point.x;\r\n        const y = point.y;\r\n        const truncX = x | 0;\r\n        if (truncX === prevX) {\r\n          if (y < minY) {\r\n            minY = y;\r\n          } else if (y > maxY) {\r\n            maxY = y;\r\n          }\r\n          avgX = (countX * avgX + x) / ++countX;\r\n        } else {\r\n          drawX();\r\n          ctx.lineTo(x, y);\r\n          prevX = truncX;\r\n          countX = 0;\r\n          minY = maxY = y;\r\n        }\r\n        lastY = y;\r\n      }\r\n      drawX();\r\n    }\r\n    function _getSegmentMethod(line) {\r\n      const opts = line.options;\r\n      const borderDash = opts.borderDash && opts.borderDash.length;\r\n      const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\r\n      return useFastPath ? fastPathSegment : pathSegment;\r\n    }\r\n    function _getInterpolationMethod(options) {\r\n      if (options.stepped) {\r\n        return _steppedInterpolation;\r\n      }\r\n      if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n        return _bezierInterpolation;\r\n      }\r\n      return _pointInLine;\r\n    }\r\n    function strokePathWithCache(ctx, line, start, count) {\r\n      let path = line._path;\r\n      if (!path) {\r\n        path = line._path = new Path2D();\r\n        if (line.path(path, start, count)) {\r\n          path.closePath();\r\n        }\r\n      }\r\n      setStyle(ctx, line.options);\r\n      ctx.stroke(path);\r\n    }\r\n    function strokePathDirect(ctx, line, start, count) {\r\n      const {segments, options} = line;\r\n      const segmentMethod = _getSegmentMethod(line);\r\n      for (const segment of segments) {\r\n        setStyle(ctx, options, segment.style);\r\n        ctx.beginPath();\r\n        if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\r\n          ctx.closePath();\r\n        }\r\n        ctx.stroke();\r\n      }\r\n    }\r\n    const usePath2D = typeof Path2D === 'function';\r\n    function draw(ctx, line, start, count) {\r\n      if (usePath2D && line.segments.length === 1) {\r\n        strokePathWithCache(ctx, line, start, count);\r\n      } else {\r\n        strokePathDirect(ctx, line, start, count);\r\n      }\r\n    }\r\n    class LineElement extends Element {\r\n      constructor(cfg) {\r\n        super();\r\n        this.animated = true;\r\n        this.options = undefined;\r\n        this._loop = undefined;\r\n        this._fullLoop = undefined;\r\n        this._path = undefined;\r\n        this._points = undefined;\r\n        this._segments = undefined;\r\n        this._decimated = false;\r\n        this._pointsUpdated = false;\r\n        if (cfg) {\r\n          Object.assign(this, cfg);\r\n        }\r\n      }\r\n      updateControlPoints(chartArea, indexAxis) {\r\n        const me = this;\r\n        const options = me.options;\r\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !me._pointsUpdated) {\r\n          const loop = options.spanGaps ? me._loop : me._fullLoop;\r\n          _updateBezierControlPoints(me._points, options, chartArea, loop, indexAxis);\r\n          me._pointsUpdated = true;\r\n        }\r\n      }\r\n      set points(points) {\r\n        const me = this;\r\n        me._points = points;\r\n        delete me._segments;\r\n        delete me._path;\r\n        me._pointsUpdated = false;\r\n      }\r\n      get points() {\r\n        return this._points;\r\n      }\r\n      get segments() {\r\n        return this._segments || (this._segments = _computeSegments(this, this.options.segment));\r\n      }\r\n      first() {\r\n        const segments = this.segments;\r\n        const points = this.points;\r\n        return segments.length && points[segments[0].start];\r\n      }\r\n      last() {\r\n        const segments = this.segments;\r\n        const points = this.points;\r\n        const count = segments.length;\r\n        return count && points[segments[count - 1].end];\r\n      }\r\n      interpolate(point, property) {\r\n        const me = this;\r\n        const options = me.options;\r\n        const value = point[property];\r\n        const points = me.points;\r\n        const segments = _boundSegments(me, {property, start: value, end: value});\r\n        if (!segments.length) {\r\n          return;\r\n        }\r\n        const result = [];\r\n        const _interpolate = _getInterpolationMethod(options);\r\n        let i, ilen;\r\n        for (i = 0, ilen = segments.length; i < ilen; ++i) {\r\n          const {start, end} = segments[i];\r\n          const p1 = points[start];\r\n          const p2 = points[end];\r\n          if (p1 === p2) {\r\n            result.push(p1);\r\n            continue;\r\n          }\r\n          const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\r\n          const interpolated = _interpolate(p1, p2, t, options.stepped);\r\n          interpolated[property] = point[property];\r\n          result.push(interpolated);\r\n        }\r\n        return result.length === 1 ? result[0] : result;\r\n      }\r\n      pathSegment(ctx, segment, params) {\r\n        const segmentMethod = _getSegmentMethod(this);\r\n        return segmentMethod(ctx, this, segment, params);\r\n      }\r\n      path(ctx, start, count) {\r\n        const me = this;\r\n        const segments = me.segments;\r\n        const segmentMethod = _getSegmentMethod(me);\r\n        let loop = me._loop;\r\n        start = start || 0;\r\n        count = count || (me.points.length - start);\r\n        for (const segment of segments) {\r\n          loop &= segmentMethod(ctx, me, segment, {start, end: start + count - 1});\r\n        }\r\n        return !!loop;\r\n      }\r\n      draw(ctx, chartArea, start, count) {\r\n        const me = this;\r\n        const options = me.options || {};\r\n        const points = me.points || [];\r\n        if (!points.length || !options.borderWidth) {\r\n          return;\r\n        }\r\n        ctx.save();\r\n        draw(ctx, me, start, count);\r\n        ctx.restore();\r\n        if (me.animated) {\r\n          me._pointsUpdated = false;\r\n          me._path = undefined;\r\n        }\r\n      }\r\n    }\r\n    LineElement.id = 'line';\r\n    LineElement.defaults = {\r\n      borderCapStyle: 'butt',\r\n      borderDash: [],\r\n      borderDashOffset: 0,\r\n      borderJoinStyle: 'miter',\r\n      borderWidth: 3,\r\n      capBezierPoints: true,\r\n      cubicInterpolationMode: 'default',\r\n      fill: false,\r\n      spanGaps: false,\r\n      stepped: false,\r\n      tension: 0,\r\n    };\r\n    LineElement.defaultRoutes = {\r\n      backgroundColor: 'backgroundColor',\r\n      borderColor: 'borderColor'\r\n    };\r\n    LineElement.descriptors = {\r\n      _scriptable: true,\r\n      _indexable: (name) => name !== 'borderDash' && name !== 'fill',\r\n    };\r\n    \r\n    function inRange$1(el, pos, axis, useFinalPosition) {\r\n      const options = el.options;\r\n      const {[axis]: value} = el.getProps([axis], useFinalPosition);\r\n      return (Math.abs(pos - value) < options.radius + options.hitRadius);\r\n    }\r\n    class PointElement extends Element {\r\n      constructor(cfg) {\r\n        super();\r\n        this.options = undefined;\r\n        this.parsed = undefined;\r\n        this.skip = undefined;\r\n        this.stop = undefined;\r\n        if (cfg) {\r\n          Object.assign(this, cfg);\r\n        }\r\n      }\r\n      inRange(mouseX, mouseY, useFinalPosition) {\r\n        const options = this.options;\r\n        const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n        return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\r\n      }\r\n      inXRange(mouseX, useFinalPosition) {\r\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\r\n      }\r\n      inYRange(mouseY, useFinalPosition) {\r\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\r\n      }\r\n      getCenterPoint(useFinalPosition) {\r\n        const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n        return {x, y};\r\n      }\r\n      size(options) {\r\n        options = options || this.options || {};\r\n        let radius = options.radius || 0;\r\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\r\n        const borderWidth = radius && options.borderWidth || 0;\r\n        return (radius + borderWidth) * 2;\r\n      }\r\n      draw(ctx) {\r\n        const me = this;\r\n        const options = me.options;\r\n        if (me.skip || options.radius < 0.1) {\r\n          return;\r\n        }\r\n        ctx.strokeStyle = options.borderColor;\r\n        ctx.lineWidth = options.borderWidth;\r\n        ctx.fillStyle = options.backgroundColor;\r\n        drawPoint(ctx, options, me.x, me.y);\r\n      }\r\n      getRange() {\r\n        const options = this.options || {};\r\n        return options.radius + options.hitRadius;\r\n      }\r\n    }\r\n    PointElement.id = 'point';\r\n    PointElement.defaults = {\r\n      borderWidth: 1,\r\n      hitRadius: 1,\r\n      hoverBorderWidth: 1,\r\n      hoverRadius: 4,\r\n      pointStyle: 'circle',\r\n      radius: 3,\r\n      rotation: 0\r\n    };\r\n    PointElement.defaultRoutes = {\r\n      backgroundColor: 'backgroundColor',\r\n      borderColor: 'borderColor'\r\n    };\r\n    \r\n    function getBarBounds(bar, useFinalPosition) {\r\n      const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\r\n      let left, right, top, bottom, half;\r\n      if (bar.horizontal) {\r\n        half = height / 2;\r\n        left = Math.min(x, base);\r\n        right = Math.max(x, base);\r\n        top = y - half;\r\n        bottom = y + half;\r\n      } else {\r\n        half = width / 2;\r\n        left = x - half;\r\n        right = x + half;\r\n        top = Math.min(y, base);\r\n        bottom = Math.max(y, base);\r\n      }\r\n      return {left, top, right, bottom};\r\n    }\r\n    function parseBorderSkipped(bar) {\r\n      let edge = bar.options.borderSkipped;\r\n      const res = {};\r\n      if (!edge) {\r\n        return res;\r\n      }\r\n      edge = bar.horizontal\r\n        ? parseEdge(edge, 'left', 'right', bar.base > bar.x)\r\n        : parseEdge(edge, 'bottom', 'top', bar.base < bar.y);\r\n      res[edge] = true;\r\n      return res;\r\n    }\r\n    function parseEdge(edge, a, b, reverse) {\r\n      if (reverse) {\r\n        edge = swap(edge, a, b);\r\n        edge = startEnd(edge, b, a);\r\n      } else {\r\n        edge = startEnd(edge, a, b);\r\n      }\r\n      return edge;\r\n    }\r\n    function swap(orig, v1, v2) {\r\n      return orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n    }\r\n    function startEnd(v, start, end) {\r\n      return v === 'start' ? start : v === 'end' ? end : v;\r\n    }\r\n    function skipOrLimit(skip, value, min, max) {\r\n      return skip ? 0 : Math.max(Math.min(value, max), min);\r\n    }\r\n    function parseBorderWidth(bar, maxW, maxH) {\r\n      const value = bar.options.borderWidth;\r\n      const skip = parseBorderSkipped(bar);\r\n      const o = toTRBL(value);\r\n      return {\r\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\r\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\r\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\r\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\r\n      };\r\n    }\r\n    function parseBorderRadius(bar, maxW, maxH) {\r\n      const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\r\n      const value = bar.options.borderRadius;\r\n      const o = toTRBLCorners(value);\r\n      const maxR = Math.min(maxW, maxH);\r\n      const skip = parseBorderSkipped(bar);\r\n      const enableBorder = enableBorderRadius || isObject(value);\r\n      return {\r\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\r\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\r\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\r\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\r\n      };\r\n    }\r\n    function boundingRects(bar) {\r\n      const bounds = getBarBounds(bar);\r\n      const width = bounds.right - bounds.left;\r\n      const height = bounds.bottom - bounds.top;\r\n      const border = parseBorderWidth(bar, width / 2, height / 2);\r\n      const radius = parseBorderRadius(bar, width / 2, height / 2);\r\n      return {\r\n        outer: {\r\n          x: bounds.left,\r\n          y: bounds.top,\r\n          w: width,\r\n          h: height,\r\n          radius\r\n        },\r\n        inner: {\r\n          x: bounds.left + border.l,\r\n          y: bounds.top + border.t,\r\n          w: width - border.l - border.r,\r\n          h: height - border.t - border.b,\r\n          radius: {\r\n            topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\r\n            topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\r\n            bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\r\n            bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\r\n          }\r\n        }\r\n      };\r\n    }\r\n    function inRange(bar, x, y, useFinalPosition) {\r\n      const skipX = x === null;\r\n      const skipY = y === null;\r\n      const skipBoth = skipX && skipY;\r\n      const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\r\n      return bounds\r\n            && (skipX || x >= bounds.left && x <= bounds.right)\r\n            && (skipY || y >= bounds.top && y <= bounds.bottom);\r\n    }\r\n    function hasRadius(radius) {\r\n      return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\r\n    }\r\n    function addNormalRectPath(ctx, rect) {\r\n      ctx.rect(rect.x, rect.y, rect.w, rect.h);\r\n    }\r\n    class BarElement extends Element {\r\n      constructor(cfg) {\r\n        super();\r\n        this.options = undefined;\r\n        this.horizontal = undefined;\r\n        this.base = undefined;\r\n        this.width = undefined;\r\n        this.height = undefined;\r\n        if (cfg) {\r\n          Object.assign(this, cfg);\r\n        }\r\n      }\r\n      draw(ctx) {\r\n        const options = this.options;\r\n        const {inner, outer} = boundingRects(this);\r\n        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\r\n        ctx.save();\r\n        if (outer.w !== inner.w || outer.h !== inner.h) {\r\n          ctx.beginPath();\r\n          addRectPath(ctx, outer);\r\n          ctx.clip();\r\n          addRectPath(ctx, inner);\r\n          ctx.fillStyle = options.borderColor;\r\n          ctx.fill('evenodd');\r\n        }\r\n        ctx.beginPath();\r\n        addRectPath(ctx, inner);\r\n        ctx.fillStyle = options.backgroundColor;\r\n        ctx.fill();\r\n        ctx.restore();\r\n      }\r\n      inRange(mouseX, mouseY, useFinalPosition) {\r\n        return inRange(this, mouseX, mouseY, useFinalPosition);\r\n      }\r\n      inXRange(mouseX, useFinalPosition) {\r\n        return inRange(this, mouseX, null, useFinalPosition);\r\n      }\r\n      inYRange(mouseY, useFinalPosition) {\r\n        return inRange(this, null, mouseY, useFinalPosition);\r\n      }\r\n      getCenterPoint(useFinalPosition) {\r\n        const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\r\n        return {\r\n          x: horizontal ? (x + base) / 2 : x,\r\n          y: horizontal ? y : (y + base) / 2\r\n        };\r\n      }\r\n      getRange(axis) {\r\n        return axis === 'x' ? this.width / 2 : this.height / 2;\r\n      }\r\n    }\r\n    BarElement.id = 'bar';\r\n    BarElement.defaults = {\r\n      borderSkipped: 'start',\r\n      borderWidth: 0,\r\n      borderRadius: 0,\r\n      enableBorderRadius: true,\r\n      pointStyle: undefined\r\n    };\r\n    BarElement.defaultRoutes = {\r\n      backgroundColor: 'backgroundColor',\r\n      borderColor: 'borderColor'\r\n    };\r\n    \r\n    var elements = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    ArcElement: ArcElement,\r\n    LineElement: LineElement,\r\n    PointElement: PointElement,\r\n    BarElement: BarElement\r\n    });\r\n    \r\n    function lttbDecimation(data, start, count, availableWidth, options) {\r\n      const samples = options.samples || availableWidth;\r\n      if (samples >= count) {\r\n        return data.slice(start, start + count);\r\n      }\r\n      const decimated = [];\r\n      const bucketWidth = (count - 2) / (samples - 2);\r\n      let sampledIndex = 0;\r\n      const endIndex = start + count - 1;\r\n      let a = start;\r\n      let i, maxAreaPoint, maxArea, area, nextA;\r\n      decimated[sampledIndex++] = data[a];\r\n      for (i = 0; i < samples - 2; i++) {\r\n        let avgX = 0;\r\n        let avgY = 0;\r\n        let j;\r\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\r\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\r\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\r\n        for (j = avgRangeStart; j < avgRangeEnd; j++) {\r\n          avgX += data[j].x;\r\n          avgY += data[j].y;\r\n        }\r\n        avgX /= avgRangeLength;\r\n        avgY /= avgRangeLength;\r\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\r\n        const rangeTo = Math.floor((i + 1) * bucketWidth) + 1 + start;\r\n        const {x: pointAx, y: pointAy} = data[a];\r\n        maxArea = area = -1;\r\n        for (j = rangeOffs; j < rangeTo; j++) {\r\n          area = 0.5 * Math.abs(\r\n            (pointAx - avgX) * (data[j].y - pointAy) -\r\n            (pointAx - data[j].x) * (avgY - pointAy)\r\n          );\r\n          if (area > maxArea) {\r\n            maxArea = area;\r\n            maxAreaPoint = data[j];\r\n            nextA = j;\r\n          }\r\n        }\r\n        decimated[sampledIndex++] = maxAreaPoint;\r\n        a = nextA;\r\n      }\r\n      decimated[sampledIndex++] = data[endIndex];\r\n      return decimated;\r\n    }\r\n    function minMaxDecimation(data, start, count, availableWidth) {\r\n      let avgX = 0;\r\n      let countX = 0;\r\n      let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\r\n      const decimated = [];\r\n      const endIndex = start + count - 1;\r\n      const xMin = data[start].x;\r\n      const xMax = data[endIndex].x;\r\n      const dx = xMax - xMin;\r\n      for (i = start; i < start + count; ++i) {\r\n        point = data[i];\r\n        x = (point.x - xMin) / dx * availableWidth;\r\n        y = point.y;\r\n        const truncX = x | 0;\r\n        if (truncX === prevX) {\r\n          if (y < minY) {\r\n            minY = y;\r\n            minIndex = i;\r\n          } else if (y > maxY) {\r\n            maxY = y;\r\n            maxIndex = i;\r\n          }\r\n          avgX = (countX * avgX + point.x) / ++countX;\r\n        } else {\r\n          const lastIndex = i - 1;\r\n          if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\r\n            const intermediateIndex1 = Math.min(minIndex, maxIndex);\r\n            const intermediateIndex2 = Math.max(minIndex, maxIndex);\r\n            if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\r\n              decimated.push({\r\n                ...data[intermediateIndex1],\r\n                x: avgX,\r\n              });\r\n            }\r\n            if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\r\n              decimated.push({\r\n                ...data[intermediateIndex2],\r\n                x: avgX\r\n              });\r\n            }\r\n          }\r\n          if (i > 0 && lastIndex !== startIndex) {\r\n            decimated.push(data[lastIndex]);\r\n          }\r\n          decimated.push(point);\r\n          prevX = truncX;\r\n          countX = 0;\r\n          minY = maxY = y;\r\n          minIndex = maxIndex = startIndex = i;\r\n        }\r\n      }\r\n      return decimated;\r\n    }\r\n    function cleanDecimatedDataset(dataset) {\r\n      if (dataset._decimated) {\r\n        const data = dataset._data;\r\n        delete dataset._decimated;\r\n        delete dataset._data;\r\n        Object.defineProperty(dataset, 'data', {value: data});\r\n      }\r\n    }\r\n    function cleanDecimatedData(chart) {\r\n      chart.data.datasets.forEach((dataset) => {\r\n        cleanDecimatedDataset(dataset);\r\n      });\r\n    }\r\n    function getStartAndCountOfVisiblePointsSimplified(meta, points) {\r\n      const pointCount = points.length;\r\n      let start = 0;\r\n      let count;\r\n      const {iScale} = meta;\r\n      const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n      if (minDefined) {\r\n        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\r\n      }\r\n      if (maxDefined) {\r\n        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\r\n      } else {\r\n        count = pointCount - start;\r\n      }\r\n      return {start, count};\r\n    }\r\n    var plugin_decimation = {\r\n      id: 'decimation',\r\n      defaults: {\r\n        algorithm: 'min-max',\r\n        enabled: false,\r\n      },\r\n      beforeElementsUpdate: (chart, args, options) => {\r\n        if (!options.enabled) {\r\n          cleanDecimatedData(chart);\r\n          return;\r\n        }\r\n        const availableWidth = chart.width;\r\n        chart.data.datasets.forEach((dataset, datasetIndex) => {\r\n          const {_data, indexAxis} = dataset;\r\n          const meta = chart.getDatasetMeta(datasetIndex);\r\n          const data = _data || dataset.data;\r\n          if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\r\n            return;\r\n          }\r\n          if (meta.type !== 'line') {\r\n            return;\r\n          }\r\n          const xAxis = chart.scales[meta.xAxisID];\r\n          if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\r\n            return;\r\n          }\r\n          if (chart.options.parsing) {\r\n            return;\r\n          }\r\n          let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\r\n          if (count <= 4 * availableWidth) {\r\n            cleanDecimatedDataset(dataset);\r\n            return;\r\n          }\r\n          if (isNullOrUndef(_data)) {\r\n            dataset._data = data;\r\n            delete dataset.data;\r\n            Object.defineProperty(dataset, 'data', {\r\n              configurable: true,\r\n              enumerable: true,\r\n              get: function() {\r\n                return this._decimated;\r\n              },\r\n              set: function(d) {\r\n                this._data = d;\r\n              }\r\n            });\r\n          }\r\n          let decimated;\r\n          switch (options.algorithm) {\r\n          case 'lttb':\r\n            decimated = lttbDecimation(data, start, count, availableWidth, options);\r\n            break;\r\n          case 'min-max':\r\n            decimated = minMaxDecimation(data, start, count, availableWidth);\r\n            break;\r\n          default:\r\n            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\r\n          }\r\n          dataset._decimated = decimated;\r\n        });\r\n      },\r\n      destroy(chart) {\r\n        cleanDecimatedData(chart);\r\n      }\r\n    };\r\n    \r\n    function getLineByIndex(chart, index) {\r\n      const meta = chart.getDatasetMeta(index);\r\n      const visible = meta && chart.isDatasetVisible(index);\r\n      return visible ? meta.dataset : null;\r\n    }\r\n    function parseFillOption(line) {\r\n      const options = line.options;\r\n      const fillOption = options.fill;\r\n      let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\r\n      if (fill === undefined) {\r\n        fill = !!options.backgroundColor;\r\n      }\r\n      if (fill === false || fill === null) {\r\n        return false;\r\n      }\r\n      if (fill === true) {\r\n        return 'origin';\r\n      }\r\n      return fill;\r\n    }\r\n    function decodeFill(line, index, count) {\r\n      const fill = parseFillOption(line);\r\n      if (isObject(fill)) {\r\n        return isNaN(fill.value) ? false : fill;\r\n      }\r\n      let target = parseFloat(fill);\r\n      if (isNumberFinite(target) && Math.floor(target) === target) {\r\n        if (fill[0] === '-' || fill[0] === '+') {\r\n          target = index + target;\r\n        }\r\n        if (target === index || target < 0 || target >= count) {\r\n          return false;\r\n        }\r\n        return target;\r\n      }\r\n      return ['origin', 'start', 'end', 'stack'].indexOf(fill) >= 0 && fill;\r\n    }\r\n    function computeLinearBoundary(source) {\r\n      const {scale = {}, fill} = source;\r\n      let target = null;\r\n      let horizontal;\r\n      if (fill === 'start') {\r\n        target = scale.bottom;\r\n      } else if (fill === 'end') {\r\n        target = scale.top;\r\n      } else if (isObject(fill)) {\r\n        target = scale.getPixelForValue(fill.value);\r\n      } else if (scale.getBasePixel) {\r\n        target = scale.getBasePixel();\r\n      }\r\n      if (isNumberFinite(target)) {\r\n        horizontal = scale.isHorizontal();\r\n        return {\r\n          x: horizontal ? target : null,\r\n          y: horizontal ? null : target\r\n        };\r\n      }\r\n      return null;\r\n    }\r\n    class simpleArc {\r\n      constructor(opts) {\r\n        this.x = opts.x;\r\n        this.y = opts.y;\r\n        this.radius = opts.radius;\r\n      }\r\n      pathSegment(ctx, bounds, opts) {\r\n        const {x, y, radius} = this;\r\n        bounds = bounds || {start: 0, end: TAU};\r\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\r\n        return !opts.bounds;\r\n      }\r\n      interpolate(point) {\r\n        const {x, y, radius} = this;\r\n        const angle = point.angle;\r\n        return {\r\n          x: x + Math.cos(angle) * radius,\r\n          y: y + Math.sin(angle) * radius,\r\n          angle\r\n        };\r\n      }\r\n    }\r\n    function computeCircularBoundary(source) {\r\n      const {scale, fill} = source;\r\n      const options = scale.options;\r\n      const length = scale.getLabels().length;\r\n      const target = [];\r\n      const start = options.reverse ? scale.max : scale.min;\r\n      const end = options.reverse ? scale.min : scale.max;\r\n      let i, center, value;\r\n      if (fill === 'start') {\r\n        value = start;\r\n      } else if (fill === 'end') {\r\n        value = end;\r\n      } else if (isObject(fill)) {\r\n        value = fill.value;\r\n      } else {\r\n        value = scale.getBaseValue();\r\n      }\r\n      if (options.grid.circular) {\r\n        center = scale.getPointPositionForValue(0, start);\r\n        return new simpleArc({\r\n          x: center.x,\r\n          y: center.y,\r\n          radius: scale.getDistanceFromCenterForValue(value)\r\n        });\r\n      }\r\n      for (i = 0; i < length; ++i) {\r\n        target.push(scale.getPointPositionForValue(i, value));\r\n      }\r\n      return target;\r\n    }\r\n    function computeBoundary(source) {\r\n      const scale = source.scale || {};\r\n      if (scale.getPointPositionForValue) {\r\n        return computeCircularBoundary(source);\r\n      }\r\n      return computeLinearBoundary(source);\r\n    }\r\n    function pointsFromSegments(boundary, line) {\r\n      const {x = null, y = null} = boundary || {};\r\n      const linePoints = line.points;\r\n      const points = [];\r\n      line.segments.forEach((segment) => {\r\n        const first = linePoints[segment.start];\r\n        const last = linePoints[segment.end];\r\n        if (y !== null) {\r\n          points.push({x: first.x, y});\r\n          points.push({x: last.x, y});\r\n        } else if (x !== null) {\r\n          points.push({x, y: first.y});\r\n          points.push({x, y: last.y});\r\n        }\r\n      });\r\n      return points;\r\n    }\r\n    function buildStackLine(source) {\r\n      const {chart, scale, index, line} = source;\r\n      const points = [];\r\n      const segments = line.segments;\r\n      const sourcePoints = line.points;\r\n      const linesBelow = getLinesBelow(chart, index);\r\n      linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));\r\n      for (let i = 0; i < segments.length; i++) {\r\n        const segment = segments[i];\r\n        for (let j = segment.start; j <= segment.end; j++) {\r\n          addPointsBelow(points, sourcePoints[j], linesBelow);\r\n        }\r\n      }\r\n      return new LineElement({points, options: {}});\r\n    }\r\n    const isLineAndNotInHideAnimation = (meta) => meta.type === 'line' && !meta.hidden;\r\n    function getLinesBelow(chart, index) {\r\n      const below = [];\r\n      const metas = chart.getSortedVisibleDatasetMetas();\r\n      for (let i = 0; i < metas.length; i++) {\r\n        const meta = metas[i];\r\n        if (meta.index === index) {\r\n          break;\r\n        }\r\n        if (isLineAndNotInHideAnimation(meta)) {\r\n          below.unshift(meta.dataset);\r\n        }\r\n      }\r\n      return below;\r\n    }\r\n    function addPointsBelow(points, sourcePoint, linesBelow) {\r\n      const postponed = [];\r\n      for (let j = 0; j < linesBelow.length; j++) {\r\n        const line = linesBelow[j];\r\n        const {first, last, point} = findPoint(line, sourcePoint, 'x');\r\n        if (!point || (first && last)) {\r\n          continue;\r\n        }\r\n        if (first) {\r\n          postponed.unshift(point);\r\n        } else {\r\n          points.push(point);\r\n          if (!last) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      points.push(...postponed);\r\n    }\r\n    function findPoint(line, sourcePoint, property) {\r\n      const point = line.interpolate(sourcePoint, property);\r\n      if (!point) {\r\n        return {};\r\n      }\r\n      const pointValue = point[property];\r\n      const segments = line.segments;\r\n      const linePoints = line.points;\r\n      let first = false;\r\n      let last = false;\r\n      for (let i = 0; i < segments.length; i++) {\r\n        const segment = segments[i];\r\n        const firstValue = linePoints[segment.start][property];\r\n        const lastValue = linePoints[segment.end][property];\r\n        if (pointValue >= firstValue && pointValue <= lastValue) {\r\n          first = pointValue === firstValue;\r\n          last = pointValue === lastValue;\r\n          break;\r\n        }\r\n      }\r\n      return {first, last, point};\r\n    }\r\n    function getTarget(source) {\r\n      const {chart, fill, line} = source;\r\n      if (isNumberFinite(fill)) {\r\n        return getLineByIndex(chart, fill);\r\n      }\r\n      if (fill === 'stack') {\r\n        return buildStackLine(source);\r\n      }\r\n      const boundary = computeBoundary(source);\r\n      if (boundary instanceof simpleArc) {\r\n        return boundary;\r\n      }\r\n      return createBoundaryLine(boundary, line);\r\n    }\r\n    function createBoundaryLine(boundary, line) {\r\n      let points = [];\r\n      let _loop = false;\r\n      if (isArray(boundary)) {\r\n        _loop = true;\r\n        points = boundary;\r\n      } else {\r\n        points = pointsFromSegments(boundary, line);\r\n      }\r\n      return points.length ? new LineElement({\r\n        points,\r\n        options: {tension: 0},\r\n        _loop,\r\n        _fullLoop: _loop\r\n      }) : null;\r\n    }\r\n    function resolveTarget(sources, index, propagate) {\r\n      const source = sources[index];\r\n      let fill = source.fill;\r\n      const visited = [index];\r\n      let target;\r\n      if (!propagate) {\r\n        return fill;\r\n      }\r\n      while (fill !== false && visited.indexOf(fill) === -1) {\r\n        if (!isNumberFinite(fill)) {\r\n          return fill;\r\n        }\r\n        target = sources[fill];\r\n        if (!target) {\r\n          return false;\r\n        }\r\n        if (target.visible) {\r\n          return fill;\r\n        }\r\n        visited.push(fill);\r\n        fill = target.fill;\r\n      }\r\n      return false;\r\n    }\r\n    function _clip(ctx, target, clipY) {\r\n      ctx.beginPath();\r\n      target.path(ctx);\r\n      ctx.lineTo(target.last().x, clipY);\r\n      ctx.lineTo(target.first().x, clipY);\r\n      ctx.closePath();\r\n      ctx.clip();\r\n    }\r\n    function getBounds(property, first, last, loop) {\r\n      if (loop) {\r\n        return;\r\n      }\r\n      let start = first[property];\r\n      let end = last[property];\r\n      if (property === 'angle') {\r\n        start = _normalizeAngle(start);\r\n        end = _normalizeAngle(end);\r\n      }\r\n      return {property, start, end};\r\n    }\r\n    function _getEdge(a, b, prop, fn) {\r\n      if (a && b) {\r\n        return fn(a[prop], b[prop]);\r\n      }\r\n      return a ? a[prop] : b ? b[prop] : 0;\r\n    }\r\n    function _segments(line, target, property) {\r\n      const segments = line.segments;\r\n      const points = line.points;\r\n      const tpoints = target.points;\r\n      const parts = [];\r\n      for (const segment of segments) {\r\n        const bounds = getBounds(property, points[segment.start], points[segment.end], segment.loop);\r\n        if (!target.segments) {\r\n          parts.push({\r\n            source: segment,\r\n            target: bounds,\r\n            start: points[segment.start],\r\n            end: points[segment.end]\r\n          });\r\n          continue;\r\n        }\r\n        const targetSegments = _boundSegments(target, bounds);\r\n        for (const tgt of targetSegments) {\r\n          const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\r\n          const fillSources = _boundSegment(segment, points, subBounds);\r\n          for (const fillSource of fillSources) {\r\n            parts.push({\r\n              source: fillSource,\r\n              target: tgt,\r\n              start: {\r\n                [property]: _getEdge(bounds, subBounds, 'start', Math.max)\r\n              },\r\n              end: {\r\n                [property]: _getEdge(bounds, subBounds, 'end', Math.min)\r\n              }\r\n            });\r\n          }\r\n        }\r\n      }\r\n      return parts;\r\n    }\r\n    function clipBounds(ctx, scale, bounds) {\r\n      const {top, bottom} = scale.chart.chartArea;\r\n      const {property, start, end} = bounds || {};\r\n      if (property === 'x') {\r\n        ctx.beginPath();\r\n        ctx.rect(start, top, end - start, bottom - top);\r\n        ctx.clip();\r\n      }\r\n    }\r\n    function interpolatedLineTo(ctx, target, point, property) {\r\n      const interpolatedPoint = target.interpolate(point, property);\r\n      if (interpolatedPoint) {\r\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\r\n      }\r\n    }\r\n    function _fill(ctx, cfg) {\r\n      const {line, target, property, color, scale} = cfg;\r\n      const segments = _segments(line, target, property);\r\n      for (const {source: src, target: tgt, start, end} of segments) {\r\n        const {style: {backgroundColor = color} = {}} = src;\r\n        ctx.save();\r\n        ctx.fillStyle = backgroundColor;\r\n        clipBounds(ctx, scale, getBounds(property, start, end));\r\n        ctx.beginPath();\r\n        const lineLoop = !!line.pathSegment(ctx, src);\r\n        if (lineLoop) {\r\n          ctx.closePath();\r\n        } else {\r\n          interpolatedLineTo(ctx, target, end, property);\r\n        }\r\n        const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\r\n        const loop = lineLoop && targetLoop;\r\n        if (!loop) {\r\n          interpolatedLineTo(ctx, target, start, property);\r\n        }\r\n        ctx.closePath();\r\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\r\n        ctx.restore();\r\n      }\r\n    }\r\n    function doFill(ctx, cfg) {\r\n      const {line, target, above, below, area, scale} = cfg;\r\n      const property = line._loop ? 'angle' : cfg.axis;\r\n      ctx.save();\r\n      if (property === 'x' && below !== above) {\r\n        _clip(ctx, target, area.top);\r\n        _fill(ctx, {line, target, color: above, scale, property});\r\n        ctx.restore();\r\n        ctx.save();\r\n        _clip(ctx, target, area.bottom);\r\n      }\r\n      _fill(ctx, {line, target, color: below, scale, property});\r\n      ctx.restore();\r\n    }\r\n    function drawfill(ctx, source, area) {\r\n      const target = getTarget(source);\r\n      const {line, scale, axis} = source;\r\n      const lineOpts = line.options;\r\n      const fillOption = lineOpts.fill;\r\n      const color = lineOpts.backgroundColor;\r\n      const {above = color, below = color} = fillOption || {};\r\n      if (target && line.points.length) {\r\n        clipArea(ctx, area);\r\n        doFill(ctx, {line, target, above, below, area, scale, axis});\r\n        unclipArea(ctx);\r\n      }\r\n    }\r\n    var plugin_filler = {\r\n      id: 'filler',\r\n      afterDatasetsUpdate(chart, _args, options) {\r\n        const count = (chart.data.datasets || []).length;\r\n        const sources = [];\r\n        let meta, i, line, source;\r\n        for (i = 0; i < count; ++i) {\r\n          meta = chart.getDatasetMeta(i);\r\n          line = meta.dataset;\r\n          source = null;\r\n          if (line && line.options && line instanceof LineElement) {\r\n            source = {\r\n              visible: chart.isDatasetVisible(i),\r\n              index: i,\r\n              fill: decodeFill(line, i, count),\r\n              chart,\r\n              axis: meta.controller.options.indexAxis,\r\n              scale: meta.vScale,\r\n              line,\r\n            };\r\n          }\r\n          meta.$filler = source;\r\n          sources.push(source);\r\n        }\r\n        for (i = 0; i < count; ++i) {\r\n          source = sources[i];\r\n          if (!source || source.fill === false) {\r\n            continue;\r\n          }\r\n          source.fill = resolveTarget(sources, i, options.propagate);\r\n        }\r\n      },\r\n      beforeDraw(chart, _args, options) {\r\n        const draw = options.drawTime === 'beforeDraw';\r\n        const metasets = chart.getSortedVisibleDatasetMetas();\r\n        const area = chart.chartArea;\r\n        for (let i = metasets.length - 1; i >= 0; --i) {\r\n          const source = metasets[i].$filler;\r\n          if (!source) {\r\n            continue;\r\n          }\r\n          source.line.updateControlPoints(area, source.axis);\r\n          if (draw) {\r\n            drawfill(chart.ctx, source, area);\r\n          }\r\n        }\r\n      },\r\n      beforeDatasetsDraw(chart, _args, options) {\r\n        if (options.drawTime !== 'beforeDatasetsDraw') {\r\n          return;\r\n        }\r\n        const metasets = chart.getSortedVisibleDatasetMetas();\r\n        for (let i = metasets.length - 1; i >= 0; --i) {\r\n          const source = metasets[i].$filler;\r\n          if (source) {\r\n            drawfill(chart.ctx, source, chart.chartArea);\r\n          }\r\n        }\r\n      },\r\n      beforeDatasetDraw(chart, args, options) {\r\n        const source = args.meta.$filler;\r\n        if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {\r\n          return;\r\n        }\r\n        drawfill(chart.ctx, source, chart.chartArea);\r\n      },\r\n      defaults: {\r\n        propagate: true,\r\n        drawTime: 'beforeDatasetDraw'\r\n      }\r\n    };\r\n    \r\n    const getBoxSize = (labelOpts, fontSize) => {\r\n      let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\r\n      if (labelOpts.usePointStyle) {\r\n        boxHeight = Math.min(boxHeight, fontSize);\r\n        boxWidth = Math.min(boxWidth, fontSize);\r\n      }\r\n      return {\r\n        boxWidth,\r\n        boxHeight,\r\n        itemHeight: Math.max(fontSize, boxHeight)\r\n      };\r\n    };\r\n    const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\r\n    class Legend extends Element {\r\n      constructor(config) {\r\n        super();\r\n        this._added = false;\r\n        this.legendHitBoxes = [];\r\n        this._hoveredItem = null;\r\n        this.doughnutMode = false;\r\n        this.chart = config.chart;\r\n        this.options = config.options;\r\n        this.ctx = config.ctx;\r\n        this.legendItems = undefined;\r\n        this.columnSizes = undefined;\r\n        this.lineWidths = undefined;\r\n        this.maxHeight = undefined;\r\n        this.maxWidth = undefined;\r\n        this.top = undefined;\r\n        this.bottom = undefined;\r\n        this.left = undefined;\r\n        this.right = undefined;\r\n        this.height = undefined;\r\n        this.width = undefined;\r\n        this._margins = undefined;\r\n        this.position = undefined;\r\n        this.weight = undefined;\r\n        this.fullSize = undefined;\r\n      }\r\n      update(maxWidth, maxHeight, margins) {\r\n        const me = this;\r\n        me.maxWidth = maxWidth;\r\n        me.maxHeight = maxHeight;\r\n        me._margins = margins;\r\n        me.setDimensions();\r\n        me.buildLabels();\r\n        me.fit();\r\n      }\r\n      setDimensions() {\r\n        const me = this;\r\n        if (me.isHorizontal()) {\r\n          me.width = me.maxWidth;\r\n          me.left = 0;\r\n          me.right = me.width;\r\n        } else {\r\n          me.height = me.maxHeight;\r\n          me.top = 0;\r\n          me.bottom = me.height;\r\n        }\r\n      }\r\n      buildLabels() {\r\n        const me = this;\r\n        const labelOpts = me.options.labels || {};\r\n        let legendItems = callback(labelOpts.generateLabels, [me.chart], me) || [];\r\n        if (labelOpts.filter) {\r\n          legendItems = legendItems.filter((item) => labelOpts.filter(item, me.chart.data));\r\n        }\r\n        if (labelOpts.sort) {\r\n          legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, me.chart.data));\r\n        }\r\n        if (me.options.reverse) {\r\n          legendItems.reverse();\r\n        }\r\n        me.legendItems = legendItems;\r\n      }\r\n      fit() {\r\n        const me = this;\r\n        const {options, ctx} = me;\r\n        if (!options.display) {\r\n          me.width = me.height = 0;\r\n          return;\r\n        }\r\n        const labelOpts = options.labels;\r\n        const labelFont = toFont(labelOpts.font);\r\n        const fontSize = labelFont.size;\r\n        const titleHeight = me._computeTitleHeight();\r\n        const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n        let width, height;\r\n        ctx.font = labelFont.string;\r\n        if (me.isHorizontal()) {\r\n          width = me.maxWidth;\r\n          height = me._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n        } else {\r\n          height = me.maxHeight;\r\n          width = me._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n        }\r\n        me.width = Math.min(width, options.maxWidth || me.maxWidth);\r\n        me.height = Math.min(height, options.maxHeight || me.maxHeight);\r\n      }\r\n      _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\r\n        const me = this;\r\n        const {ctx, maxWidth, options: {labels: {padding}}} = me;\r\n        const hitboxes = me.legendHitBoxes = [];\r\n        const lineWidths = me.lineWidths = [0];\r\n        const lineHeight = itemHeight + padding;\r\n        let totalHeight = titleHeight;\r\n        ctx.textAlign = 'left';\r\n        ctx.textBaseline = 'middle';\r\n        let row = -1;\r\n        let top = -lineHeight;\r\n        me.legendItems.forEach((legendItem, i) => {\r\n          const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n          if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\r\n            totalHeight += lineHeight;\r\n            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n            top += lineHeight;\r\n            row++;\r\n          }\r\n          hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\r\n          lineWidths[lineWidths.length - 1] += itemWidth + padding;\r\n        });\r\n        return totalHeight;\r\n      }\r\n      _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\r\n        const me = this;\r\n        const {ctx, maxHeight, options: {labels: {padding}}} = me;\r\n        const hitboxes = me.legendHitBoxes = [];\r\n        const columnSizes = me.columnSizes = [];\r\n        const heightLimit = maxHeight - titleHeight;\r\n        let totalWidth = padding;\r\n        let currentColWidth = 0;\r\n        let currentColHeight = 0;\r\n        let left = 0;\r\n        let top = 0;\r\n        let col = 0;\r\n        me.legendItems.forEach((legendItem, i) => {\r\n          const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n          if (i > 0 && currentColHeight + fontSize + 2 * padding > heightLimit) {\r\n            totalWidth += currentColWidth + padding;\r\n            columnSizes.push({width: currentColWidth, height: currentColHeight});\r\n            left += currentColWidth + padding;\r\n            col++;\r\n            top = 0;\r\n            currentColWidth = currentColHeight = 0;\r\n          }\r\n          currentColWidth = Math.max(currentColWidth, itemWidth);\r\n          currentColHeight += fontSize + padding;\r\n          hitboxes[i] = {left, top, col, width: itemWidth, height: itemHeight};\r\n          top += itemHeight + padding;\r\n        });\r\n        totalWidth += currentColWidth;\r\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\r\n        return totalWidth;\r\n      }\r\n      adjustHitBoxes() {\r\n        const me = this;\r\n        if (!me.options.display) {\r\n          return;\r\n        }\r\n        const titleHeight = me._computeTitleHeight();\r\n        const {legendHitBoxes: hitboxes, options: {align, labels: {padding}}} = me;\r\n        if (this.isHorizontal()) {\r\n          let row = 0;\r\n          let left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\r\n          for (const hitbox of hitboxes) {\r\n            if (row !== hitbox.row) {\r\n              row = hitbox.row;\r\n              left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);\r\n            }\r\n            hitbox.top += me.top + titleHeight + padding;\r\n            hitbox.left = left;\r\n            left += hitbox.width + padding;\r\n          }\r\n        } else {\r\n          let col = 0;\r\n          let top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\r\n          for (const hitbox of hitboxes) {\r\n            if (hitbox.col !== col) {\r\n              col = hitbox.col;\r\n              top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);\r\n            }\r\n            hitbox.top = top;\r\n            hitbox.left += me.left + padding;\r\n            top += hitbox.height + padding;\r\n          }\r\n        }\r\n      }\r\n      isHorizontal() {\r\n        return this.options.position === 'top' || this.options.position === 'bottom';\r\n      }\r\n      draw() {\r\n        const me = this;\r\n        if (me.options.display) {\r\n          const ctx = me.ctx;\r\n          clipArea(ctx, me);\r\n          me._draw();\r\n          unclipArea(ctx);\r\n        }\r\n      }\r\n      _draw() {\r\n        const me = this;\r\n        const {options: opts, columnSizes, lineWidths, ctx} = me;\r\n        const {align, labels: labelOpts} = opts;\r\n        const defaultColor = defaults.color;\r\n        const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\r\n        const labelFont = toFont(labelOpts.font);\r\n        const {color: fontColor, padding} = labelOpts;\r\n        const fontSize = labelFont.size;\r\n        const halfFontSize = fontSize / 2;\r\n        let cursor;\r\n        me.drawTitle();\r\n        ctx.textAlign = rtlHelper.textAlign('left');\r\n        ctx.textBaseline = 'middle';\r\n        ctx.lineWidth = 0.5;\r\n        ctx.font = labelFont.string;\r\n        const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n        const drawLegendBox = function(x, y, legendItem) {\r\n          if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\r\n            return;\r\n          }\r\n          ctx.save();\r\n          const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\r\n          ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n          ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\r\n          ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\r\n          ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\r\n          ctx.lineWidth = lineWidth;\r\n          ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n          ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\r\n          if (labelOpts.usePointStyle) {\r\n            const drawOptions = {\r\n              radius: boxWidth * Math.SQRT2 / 2,\r\n              pointStyle: legendItem.pointStyle,\r\n              rotation: legendItem.rotation,\r\n              borderWidth: lineWidth\r\n            };\r\n            const centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n            const centerY = y + halfFontSize;\r\n            drawPoint(ctx, drawOptions, centerX, centerY);\r\n          } else {\r\n            const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\r\n            const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\r\n            const borderRadius = toTRBLCorners(legendItem.borderRadius);\r\n            ctx.beginPath();\r\n            if (Object.values(borderRadius).some(v => v !== 0)) {\r\n              addRoundedRectPath(ctx, {\r\n                x: xBoxLeft,\r\n                y: yBoxTop,\r\n                w: boxWidth,\r\n                h: boxHeight,\r\n                radius: borderRadius,\r\n              });\r\n            } else {\r\n              ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\r\n            }\r\n            ctx.fill();\r\n            if (lineWidth !== 0) {\r\n              ctx.stroke();\r\n            }\r\n          }\r\n          ctx.restore();\r\n        };\r\n        const fillText = function(x, y, legendItem) {\r\n          renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\r\n            strikethrough: legendItem.hidden,\r\n            textAlign: legendItem.textAlign\r\n          });\r\n        };\r\n        const isHorizontal = me.isHorizontal();\r\n        const titleHeight = this._computeTitleHeight();\r\n        if (isHorizontal) {\r\n          cursor = {\r\n            x: _alignStartEnd(align, me.left + padding, me.right - lineWidths[0]),\r\n            y: me.top + padding + titleHeight,\r\n            line: 0\r\n          };\r\n        } else {\r\n          cursor = {\r\n            x: me.left + padding,\r\n            y: _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[0].height),\r\n            line: 0\r\n          };\r\n        }\r\n        overrideTextDirection(me.ctx, opts.textDirection);\r\n        const lineHeight = itemHeight + padding;\r\n        me.legendItems.forEach((legendItem, i) => {\r\n          ctx.strokeStyle = legendItem.fontColor || fontColor;\r\n          ctx.fillStyle = legendItem.fontColor || fontColor;\r\n          const textWidth = ctx.measureText(legendItem.text).width;\r\n          const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\r\n          const width = boxWidth + (fontSize / 2) + textWidth;\r\n          let x = cursor.x;\r\n          let y = cursor.y;\r\n          rtlHelper.setWidth(me.width);\r\n          if (isHorizontal) {\r\n            if (i > 0 && x + width + padding > me.right) {\r\n              y = cursor.y += lineHeight;\r\n              cursor.line++;\r\n              x = cursor.x = _alignStartEnd(align, me.left + padding, me.right - lineWidths[cursor.line]);\r\n            }\r\n          } else if (i > 0 && y + lineHeight > me.bottom) {\r\n            x = cursor.x = x + columnSizes[cursor.line].width + padding;\r\n            cursor.line++;\r\n            y = cursor.y = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[cursor.line].height);\r\n          }\r\n          const realX = rtlHelper.x(x);\r\n          drawLegendBox(realX, y, legendItem);\r\n          x = _textX(textAlign, x + boxWidth + halfFontSize, me.right);\r\n          fillText(rtlHelper.x(x), y, legendItem);\r\n          if (isHorizontal) {\r\n            cursor.x += width + padding;\r\n          } else {\r\n            cursor.y += lineHeight;\r\n          }\r\n        });\r\n        restoreTextDirection(me.ctx, opts.textDirection);\r\n      }\r\n      drawTitle() {\r\n        const me = this;\r\n        const opts = me.options;\r\n        const titleOpts = opts.title;\r\n        const titleFont = toFont(titleOpts.font);\r\n        const titlePadding = toPadding(titleOpts.padding);\r\n        if (!titleOpts.display) {\r\n          return;\r\n        }\r\n        const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);\r\n        const ctx = me.ctx;\r\n        const position = titleOpts.position;\r\n        const halfFontSize = titleFont.size / 2;\r\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\r\n        let y;\r\n        let left = me.left;\r\n        let maxWidth = me.width;\r\n        if (this.isHorizontal()) {\r\n          maxWidth = Math.max(...me.lineWidths);\r\n          y = me.top + topPaddingPlusHalfFontSize;\r\n          left = _alignStartEnd(opts.align, left, me.right - maxWidth);\r\n        } else {\r\n          const maxHeight = me.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\r\n          y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, me.top, me.bottom - maxHeight - opts.labels.padding - me._computeTitleHeight());\r\n        }\r\n        const x = _alignStartEnd(position, left, left + maxWidth);\r\n        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\r\n        ctx.textBaseline = 'middle';\r\n        ctx.strokeStyle = titleOpts.color;\r\n        ctx.fillStyle = titleOpts.color;\r\n        ctx.font = titleFont.string;\r\n        renderText(ctx, titleOpts.text, x, y, titleFont);\r\n      }\r\n      _computeTitleHeight() {\r\n        const titleOpts = this.options.title;\r\n        const titleFont = toFont(titleOpts.font);\r\n        const titlePadding = toPadding(titleOpts.padding);\r\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\r\n      }\r\n      _getLegendItemAt(x, y) {\r\n        const me = this;\r\n        let i, hitBox, lh;\r\n        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\r\n          lh = me.legendHitBoxes;\r\n          for (i = 0; i < lh.length; ++i) {\r\n            hitBox = lh[i];\r\n            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\r\n              return me.legendItems[i];\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n      handleEvent(e) {\r\n        const me = this;\r\n        const opts = me.options;\r\n        if (!isListened(e.type, opts)) {\r\n          return;\r\n        }\r\n        const hoveredItem = me._getLegendItemAt(e.x, e.y);\r\n        if (e.type === 'mousemove') {\r\n          const previous = me._hoveredItem;\r\n          const sameItem = itemsEqual(previous, hoveredItem);\r\n          if (previous && !sameItem) {\r\n            callback(opts.onLeave, [e, previous, me], me);\r\n          }\r\n          me._hoveredItem = hoveredItem;\r\n          if (hoveredItem && !sameItem) {\r\n            callback(opts.onHover, [e, hoveredItem, me], me);\r\n          }\r\n        } else if (hoveredItem) {\r\n          callback(opts.onClick, [e, hoveredItem, me], me);\r\n        }\r\n      }\r\n    }\r\n    function isListened(type, opts) {\r\n      if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {\r\n        return true;\r\n      }\r\n      if (opts.onClick && (type === 'click' || type === 'mouseup')) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    var plugin_legend = {\r\n      id: 'legend',\r\n      _element: Legend,\r\n      start(chart, _args, options) {\r\n        const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\r\n        layouts.configure(chart, legend, options);\r\n        layouts.addBox(chart, legend);\r\n      },\r\n      stop(chart) {\r\n        layouts.removeBox(chart, chart.legend);\r\n        delete chart.legend;\r\n      },\r\n      beforeUpdate(chart, _args, options) {\r\n        const legend = chart.legend;\r\n        layouts.configure(chart, legend, options);\r\n        legend.options = options;\r\n      },\r\n      afterUpdate(chart) {\r\n        const legend = chart.legend;\r\n        legend.buildLabels();\r\n        legend.adjustHitBoxes();\r\n      },\r\n      afterEvent(chart, args) {\r\n        if (!args.replay) {\r\n          chart.legend.handleEvent(args.event);\r\n        }\r\n      },\r\n      defaults: {\r\n        display: true,\r\n        position: 'top',\r\n        align: 'center',\r\n        fullSize: true,\r\n        reverse: false,\r\n        weight: 1000,\r\n        onClick(e, legendItem, legend) {\r\n          const index = legendItem.datasetIndex;\r\n          const ci = legend.chart;\r\n          if (ci.isDatasetVisible(index)) {\r\n            ci.hide(index);\r\n            legendItem.hidden = true;\r\n          } else {\r\n            ci.show(index);\r\n            legendItem.hidden = false;\r\n          }\r\n        },\r\n        onHover: null,\r\n        onLeave: null,\r\n        labels: {\r\n          color: (ctx) => ctx.chart.options.color,\r\n          boxWidth: 40,\r\n          padding: 10,\r\n          generateLabels(chart) {\r\n            const datasets = chart.data.datasets;\r\n            const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\r\n            return chart._getSortedDatasetMetas().map((meta) => {\r\n              const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n              const borderWidth = toPadding(style.borderWidth);\r\n              return {\r\n                text: datasets[meta.index].label,\r\n                fillStyle: style.backgroundColor,\r\n                fontColor: color,\r\n                hidden: !meta.visible,\r\n                lineCap: style.borderCapStyle,\r\n                lineDash: style.borderDash,\r\n                lineDashOffset: style.borderDashOffset,\r\n                lineJoin: style.borderJoinStyle,\r\n                lineWidth: (borderWidth.width + borderWidth.height) / 4,\r\n                strokeStyle: style.borderColor,\r\n                pointStyle: pointStyle || style.pointStyle,\r\n                rotation: style.rotation,\r\n                textAlign: textAlign || style.textAlign,\r\n                borderRadius: 0,\r\n                datasetIndex: meta.index\r\n              };\r\n            }, this);\r\n          }\r\n        },\r\n        title: {\r\n          color: (ctx) => ctx.chart.options.color,\r\n          display: false,\r\n          position: 'center',\r\n          text: '',\r\n        }\r\n      },\r\n      descriptors: {\r\n        _scriptable: (name) => !name.startsWith('on'),\r\n        labels: {\r\n          _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\r\n        }\r\n      },\r\n    };\r\n    \r\n    class Title extends Element {\r\n      constructor(config) {\r\n        super();\r\n        this.chart = config.chart;\r\n        this.options = config.options;\r\n        this.ctx = config.ctx;\r\n        this._padding = undefined;\r\n        this.top = undefined;\r\n        this.bottom = undefined;\r\n        this.left = undefined;\r\n        this.right = undefined;\r\n        this.width = undefined;\r\n        this.height = undefined;\r\n        this.position = undefined;\r\n        this.weight = undefined;\r\n        this.fullSize = undefined;\r\n      }\r\n      update(maxWidth, maxHeight) {\r\n        const me = this;\r\n        const opts = me.options;\r\n        me.left = 0;\r\n        me.top = 0;\r\n        if (!opts.display) {\r\n          me.width = me.height = me.right = me.bottom = 0;\r\n          return;\r\n        }\r\n        me.width = me.right = maxWidth;\r\n        me.height = me.bottom = maxHeight;\r\n        const lineCount = isArray(opts.text) ? opts.text.length : 1;\r\n        me._padding = toPadding(opts.padding);\r\n        const textSize = lineCount * toFont(opts.font).lineHeight + me._padding.height;\r\n        if (me.isHorizontal()) {\r\n          me.height = textSize;\r\n        } else {\r\n          me.width = textSize;\r\n        }\r\n      }\r\n      isHorizontal() {\r\n        const pos = this.options.position;\r\n        return pos === 'top' || pos === 'bottom';\r\n      }\r\n      _drawArgs(offset) {\r\n        const {top, left, bottom, right, options} = this;\r\n        const align = options.align;\r\n        let rotation = 0;\r\n        let maxWidth, titleX, titleY;\r\n        if (this.isHorizontal()) {\r\n          titleX = _alignStartEnd(align, left, right);\r\n          titleY = top + offset;\r\n          maxWidth = right - left;\r\n        } else {\r\n          if (options.position === 'left') {\r\n            titleX = left + offset;\r\n            titleY = _alignStartEnd(align, bottom, top);\r\n            rotation = PI * -0.5;\r\n          } else {\r\n            titleX = right - offset;\r\n            titleY = _alignStartEnd(align, top, bottom);\r\n            rotation = PI * 0.5;\r\n          }\r\n          maxWidth = bottom - top;\r\n        }\r\n        return {titleX, titleY, maxWidth, rotation};\r\n      }\r\n      draw() {\r\n        const me = this;\r\n        const ctx = me.ctx;\r\n        const opts = me.options;\r\n        if (!opts.display) {\r\n          return;\r\n        }\r\n        const fontOpts = toFont(opts.font);\r\n        const lineHeight = fontOpts.lineHeight;\r\n        const offset = lineHeight / 2 + me._padding.top;\r\n        const {titleX, titleY, maxWidth, rotation} = me._drawArgs(offset);\r\n        renderText(ctx, opts.text, 0, 0, fontOpts, {\r\n          color: opts.color,\r\n          maxWidth,\r\n          rotation,\r\n          textAlign: _toLeftRightCenter(opts.align),\r\n          textBaseline: 'middle',\r\n          translation: [titleX, titleY],\r\n        });\r\n      }\r\n    }\r\n    function createTitle(chart, titleOpts) {\r\n      const title = new Title({\r\n        ctx: chart.ctx,\r\n        options: titleOpts,\r\n        chart\r\n      });\r\n      layouts.configure(chart, title, titleOpts);\r\n      layouts.addBox(chart, title);\r\n      chart.titleBlock = title;\r\n    }\r\n    var plugin_title = {\r\n      id: 'title',\r\n      _element: Title,\r\n      start(chart, _args, options) {\r\n        createTitle(chart, options);\r\n      },\r\n      stop(chart) {\r\n        const titleBlock = chart.titleBlock;\r\n        layouts.removeBox(chart, titleBlock);\r\n        delete chart.titleBlock;\r\n      },\r\n      beforeUpdate(chart, _args, options) {\r\n        const title = chart.titleBlock;\r\n        layouts.configure(chart, title, options);\r\n        title.options = options;\r\n      },\r\n      defaults: {\r\n        align: 'center',\r\n        display: false,\r\n        font: {\r\n          weight: 'bold',\r\n        },\r\n        fullSize: true,\r\n        padding: 10,\r\n        position: 'top',\r\n        text: '',\r\n        weight: 2000\r\n      },\r\n      defaultRoutes: {\r\n        color: 'color'\r\n      },\r\n      descriptors: {\r\n        _scriptable: true,\r\n        _indexable: false,\r\n      },\r\n    };\r\n    \r\n    const positioners = {\r\n      average(items) {\r\n        if (!items.length) {\r\n          return false;\r\n        }\r\n        let i, len;\r\n        let x = 0;\r\n        let y = 0;\r\n        let count = 0;\r\n        for (i = 0, len = items.length; i < len; ++i) {\r\n          const el = items[i].element;\r\n          if (el && el.hasValue()) {\r\n            const pos = el.tooltipPosition();\r\n            x += pos.x;\r\n            y += pos.y;\r\n            ++count;\r\n          }\r\n        }\r\n        return {\r\n          x: x / count,\r\n          y: y / count\r\n        };\r\n      },\r\n      nearest(items, eventPosition) {\r\n        if (!items.length) {\r\n          return false;\r\n        }\r\n        let x = eventPosition.x;\r\n        let y = eventPosition.y;\r\n        let minDistance = Number.POSITIVE_INFINITY;\r\n        let i, len, nearestElement;\r\n        for (i = 0, len = items.length; i < len; ++i) {\r\n          const el = items[i].element;\r\n          if (el && el.hasValue()) {\r\n            const center = el.getCenterPoint();\r\n            const d = distanceBetweenPoints(eventPosition, center);\r\n            if (d < minDistance) {\r\n              minDistance = d;\r\n              nearestElement = el;\r\n            }\r\n          }\r\n        }\r\n        if (nearestElement) {\r\n          const tp = nearestElement.tooltipPosition();\r\n          x = tp.x;\r\n          y = tp.y;\r\n        }\r\n        return {\r\n          x,\r\n          y\r\n        };\r\n      }\r\n    };\r\n    function pushOrConcat(base, toPush) {\r\n      if (toPush) {\r\n        if (isArray(toPush)) {\r\n          Array.prototype.push.apply(base, toPush);\r\n        } else {\r\n          base.push(toPush);\r\n        }\r\n      }\r\n      return base;\r\n    }\r\n    function splitNewlines(str) {\r\n      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\r\n        return str.split('\\n');\r\n      }\r\n      return str;\r\n    }\r\n    function createTooltipItem(chart, item) {\r\n      const {element, datasetIndex, index} = item;\r\n      const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n      const {label, value} = controller.getLabelAndValue(index);\r\n      return {\r\n        chart,\r\n        label,\r\n        parsed: controller.getParsed(index),\r\n        raw: chart.data.datasets[datasetIndex].data[index],\r\n        formattedValue: value,\r\n        dataset: controller.getDataset(),\r\n        dataIndex: index,\r\n        datasetIndex,\r\n        element\r\n      };\r\n    }\r\n    function getTooltipSize(tooltip, options) {\r\n      const ctx = tooltip._chart.ctx;\r\n      const {body, footer, title} = tooltip;\r\n      const {boxWidth, boxHeight} = options;\r\n      const bodyFont = toFont(options.bodyFont);\r\n      const titleFont = toFont(options.titleFont);\r\n      const footerFont = toFont(options.footerFont);\r\n      const titleLineCount = title.length;\r\n      const footerLineCount = footer.length;\r\n      const bodyLineItemCount = body.length;\r\n      const padding = toPadding(options.padding);\r\n      let height = padding.height;\r\n      let width = 0;\r\n      let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\r\n      combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\r\n      if (titleLineCount) {\r\n        height += titleLineCount * titleFont.lineHeight\r\n                + (titleLineCount - 1) * options.titleSpacing\r\n                + options.titleMarginBottom;\r\n      }\r\n      if (combinedBodyLength) {\r\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\r\n        height += bodyLineItemCount * bodyLineHeight\r\n                + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\r\n                + (combinedBodyLength - 1) * options.bodySpacing;\r\n      }\r\n      if (footerLineCount) {\r\n        height += options.footerMarginTop\r\n                + footerLineCount * footerFont.lineHeight\r\n                + (footerLineCount - 1) * options.footerSpacing;\r\n      }\r\n      let widthPadding = 0;\r\n      const maxLineWidth = function(line) {\r\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n      };\r\n      ctx.save();\r\n      ctx.font = titleFont.string;\r\n      each(tooltip.title, maxLineWidth);\r\n      ctx.font = bodyFont.string;\r\n      each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\r\n      widthPadding = options.displayColors ? (boxWidth + 2) : 0;\r\n      each(body, (bodyItem) => {\r\n        each(bodyItem.before, maxLineWidth);\r\n        each(bodyItem.lines, maxLineWidth);\r\n        each(bodyItem.after, maxLineWidth);\r\n      });\r\n      widthPadding = 0;\r\n      ctx.font = footerFont.string;\r\n      each(tooltip.footer, maxLineWidth);\r\n      ctx.restore();\r\n      width += padding.width;\r\n      return {width, height};\r\n    }\r\n    function determineYAlign(chart, size) {\r\n      const {y, height} = size;\r\n      if (y < height / 2) {\r\n        return 'top';\r\n      } else if (y > (chart.height - height / 2)) {\r\n        return 'bottom';\r\n      }\r\n      return 'center';\r\n    }\r\n    function doesNotFitWithAlign(xAlign, chart, options, size) {\r\n      const {x, width} = size;\r\n      const caret = options.caretSize + options.caretPadding;\r\n      if (xAlign === 'left' && x + width + caret > chart.width) {\r\n        return true;\r\n      }\r\n      if (xAlign === 'right' && x - width - caret < 0) {\r\n        return true;\r\n      }\r\n    }\r\n    function determineXAlign(chart, options, size, yAlign) {\r\n      const {x, width} = size;\r\n      const {width: chartWidth, chartArea: {left, right}} = chart;\r\n      let xAlign = 'center';\r\n      if (yAlign === 'center') {\r\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\r\n      } else if (x <= width / 2) {\r\n        xAlign = 'left';\r\n      } else if (x >= chartWidth - width / 2) {\r\n        xAlign = 'right';\r\n      }\r\n      if (doesNotFitWithAlign(xAlign, chart, options, size)) {\r\n        xAlign = 'center';\r\n      }\r\n      return xAlign;\r\n    }\r\n    function determineAlignment(chart, options, size) {\r\n      const yAlign = options.yAlign || determineYAlign(chart, size);\r\n      return {\r\n        xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),\r\n        yAlign\r\n      };\r\n    }\r\n    function alignX(size, xAlign) {\r\n      let {x, width} = size;\r\n      if (xAlign === 'right') {\r\n        x -= width;\r\n      } else if (xAlign === 'center') {\r\n        x -= (width / 2);\r\n      }\r\n      return x;\r\n    }\r\n    function alignY(size, yAlign, paddingAndSize) {\r\n      let {y, height} = size;\r\n      if (yAlign === 'top') {\r\n        y += paddingAndSize;\r\n      } else if (yAlign === 'bottom') {\r\n        y -= height + paddingAndSize;\r\n      } else {\r\n        y -= (height / 2);\r\n      }\r\n      return y;\r\n    }\r\n    function getBackgroundPoint(options, size, alignment, chart) {\r\n      const {caretSize, caretPadding, cornerRadius} = options;\r\n      const {xAlign, yAlign} = alignment;\r\n      const paddingAndSize = caretSize + caretPadding;\r\n      const radiusAndPadding = cornerRadius + caretPadding;\r\n      let x = alignX(size, xAlign);\r\n      const y = alignY(size, yAlign, paddingAndSize);\r\n      if (yAlign === 'center') {\r\n        if (xAlign === 'left') {\r\n          x += paddingAndSize;\r\n        } else if (xAlign === 'right') {\r\n          x -= paddingAndSize;\r\n        }\r\n      } else if (xAlign === 'left') {\r\n        x -= radiusAndPadding;\r\n      } else if (xAlign === 'right') {\r\n        x += radiusAndPadding;\r\n      }\r\n      return {\r\n        x: _limitValue(x, 0, chart.width - size.width),\r\n        y: _limitValue(y, 0, chart.height - size.height)\r\n      };\r\n    }\r\n    function getAlignedX(tooltip, align, options) {\r\n      const padding = toPadding(options.padding);\r\n      return align === 'center'\r\n        ? tooltip.x + tooltip.width / 2\r\n        : align === 'right'\r\n          ? tooltip.x + tooltip.width - padding.right\r\n          : tooltip.x + padding.left;\r\n    }\r\n    function getBeforeAfterBodyLines(callback) {\r\n      return pushOrConcat([], splitNewlines(callback));\r\n    }\r\n    function createTooltipContext(parent, tooltip, tooltipItems) {\r\n      return Object.assign(Object.create(parent), {\r\n        tooltip,\r\n        tooltipItems,\r\n        type: 'tooltip'\r\n      });\r\n    }\r\n    function overrideCallbacks(callbacks, context) {\r\n      const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\r\n      return override ? callbacks.override(override) : callbacks;\r\n    }\r\n    class Tooltip extends Element {\r\n      constructor(config) {\r\n        super();\r\n        this.opacity = 0;\r\n        this._active = [];\r\n        this._chart = config._chart;\r\n        this._eventPosition = undefined;\r\n        this._size = undefined;\r\n        this._cachedAnimations = undefined;\r\n        this._tooltipItems = [];\r\n        this.$animations = undefined;\r\n        this.$context = undefined;\r\n        this.options = config.options;\r\n        this.dataPoints = undefined;\r\n        this.title = undefined;\r\n        this.beforeBody = undefined;\r\n        this.body = undefined;\r\n        this.afterBody = undefined;\r\n        this.footer = undefined;\r\n        this.xAlign = undefined;\r\n        this.yAlign = undefined;\r\n        this.x = undefined;\r\n        this.y = undefined;\r\n        this.height = undefined;\r\n        this.width = undefined;\r\n        this.caretX = undefined;\r\n        this.caretY = undefined;\r\n        this.labelColors = undefined;\r\n        this.labelPointStyles = undefined;\r\n        this.labelTextColors = undefined;\r\n      }\r\n      initialize(options) {\r\n        this.options = options;\r\n        this._cachedAnimations = undefined;\r\n        this.$context = undefined;\r\n      }\r\n      _resolveAnimations() {\r\n        const me = this;\r\n        const cached = me._cachedAnimations;\r\n        if (cached) {\r\n          return cached;\r\n        }\r\n        const chart = me._chart;\r\n        const options = me.options.setContext(me.getContext());\r\n        const opts = options.enabled && chart.options.animation && options.animations;\r\n        const animations = new Animations(me._chart, opts);\r\n        if (opts._cacheable) {\r\n          me._cachedAnimations = Object.freeze(animations);\r\n        }\r\n        return animations;\r\n      }\r\n      getContext() {\r\n        const me = this;\r\n        return me.$context ||\r\n                (me.$context = createTooltipContext(me._chart.getContext(), me, me._tooltipItems));\r\n      }\r\n      getTitle(context, options) {\r\n        const me = this;\r\n        const {callbacks} = options;\r\n        const beforeTitle = callbacks.beforeTitle.apply(me, [context]);\r\n        const title = callbacks.title.apply(me, [context]);\r\n        const afterTitle = callbacks.afterTitle.apply(me, [context]);\r\n        let lines = [];\r\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n        lines = pushOrConcat(lines, splitNewlines(title));\r\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n        return lines;\r\n      }\r\n      getBeforeBody(tooltipItems, options) {\r\n        return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\r\n      }\r\n      getBody(tooltipItems, options) {\r\n        const me = this;\r\n        const {callbacks} = options;\r\n        const bodyItems = [];\r\n        each(tooltipItems, (context) => {\r\n          const bodyItem = {\r\n            before: [],\r\n            lines: [],\r\n            after: []\r\n          };\r\n          const scoped = overrideCallbacks(callbacks, context);\r\n          pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(me, context)));\r\n          pushOrConcat(bodyItem.lines, scoped.label.call(me, context));\r\n          pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(me, context)));\r\n          bodyItems.push(bodyItem);\r\n        });\r\n        return bodyItems;\r\n      }\r\n      getAfterBody(tooltipItems, options) {\r\n        return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\r\n      }\r\n      getFooter(tooltipItems, options) {\r\n        const me = this;\r\n        const {callbacks} = options;\r\n        const beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);\r\n        const footer = callbacks.footer.apply(me, [tooltipItems]);\r\n        const afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);\r\n        let lines = [];\r\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n        lines = pushOrConcat(lines, splitNewlines(footer));\r\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n        return lines;\r\n      }\r\n      _createItems(options) {\r\n        const me = this;\r\n        const active = me._active;\r\n        const data = me._chart.data;\r\n        const labelColors = [];\r\n        const labelPointStyles = [];\r\n        const labelTextColors = [];\r\n        let tooltipItems = [];\r\n        let i, len;\r\n        for (i = 0, len = active.length; i < len; ++i) {\r\n          tooltipItems.push(createTooltipItem(me._chart, active[i]));\r\n        }\r\n        if (options.filter) {\r\n          tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\r\n        }\r\n        if (options.itemSort) {\r\n          tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\r\n        }\r\n        each(tooltipItems, (context) => {\r\n          const scoped = overrideCallbacks(options.callbacks, context);\r\n          labelColors.push(scoped.labelColor.call(me, context));\r\n          labelPointStyles.push(scoped.labelPointStyle.call(me, context));\r\n          labelTextColors.push(scoped.labelTextColor.call(me, context));\r\n        });\r\n        me.labelColors = labelColors;\r\n        me.labelPointStyles = labelPointStyles;\r\n        me.labelTextColors = labelTextColors;\r\n        me.dataPoints = tooltipItems;\r\n        return tooltipItems;\r\n      }\r\n      update(changed, replay) {\r\n        const me = this;\r\n        const options = me.options.setContext(me.getContext());\r\n        const active = me._active;\r\n        let properties;\r\n        let tooltipItems = [];\r\n        if (!active.length) {\r\n          if (me.opacity !== 0) {\r\n            properties = {\r\n              opacity: 0\r\n            };\r\n          }\r\n        } else {\r\n          const position = positioners[options.position].call(me, active, me._eventPosition);\r\n          tooltipItems = me._createItems(options);\r\n          me.title = me.getTitle(tooltipItems, options);\r\n          me.beforeBody = me.getBeforeBody(tooltipItems, options);\r\n          me.body = me.getBody(tooltipItems, options);\r\n          me.afterBody = me.getAfterBody(tooltipItems, options);\r\n          me.footer = me.getFooter(tooltipItems, options);\r\n          const size = me._size = getTooltipSize(me, options);\r\n          const positionAndSize = Object.assign({}, position, size);\r\n          const alignment = determineAlignment(me._chart, options, positionAndSize);\r\n          const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, me._chart);\r\n          me.xAlign = alignment.xAlign;\r\n          me.yAlign = alignment.yAlign;\r\n          properties = {\r\n            opacity: 1,\r\n            x: backgroundPoint.x,\r\n            y: backgroundPoint.y,\r\n            width: size.width,\r\n            height: size.height,\r\n            caretX: position.x,\r\n            caretY: position.y\r\n          };\r\n        }\r\n        me._tooltipItems = tooltipItems;\r\n        me.$context = undefined;\r\n        if (properties) {\r\n          me._resolveAnimations().update(me, properties);\r\n        }\r\n        if (changed && options.external) {\r\n          options.external.call(me, {chart: me._chart, tooltip: me, replay});\r\n        }\r\n      }\r\n      drawCaret(tooltipPoint, ctx, size, options) {\r\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\r\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\r\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\r\n      }\r\n      getCaretPosition(tooltipPoint, size, options) {\r\n        const {xAlign, yAlign} = this;\r\n        const {cornerRadius, caretSize} = options;\r\n        const {x: ptX, y: ptY} = tooltipPoint;\r\n        const {width, height} = size;\r\n        let x1, x2, x3, y1, y2, y3;\r\n        if (yAlign === 'center') {\r\n          y2 = ptY + (height / 2);\r\n          if (xAlign === 'left') {\r\n            x1 = ptX;\r\n            x2 = x1 - caretSize;\r\n            y1 = y2 + caretSize;\r\n            y3 = y2 - caretSize;\r\n          } else {\r\n            x1 = ptX + width;\r\n            x2 = x1 + caretSize;\r\n            y1 = y2 - caretSize;\r\n            y3 = y2 + caretSize;\r\n          }\r\n          x3 = x1;\r\n        } else {\r\n          if (xAlign === 'left') {\r\n            x2 = ptX + cornerRadius + (caretSize);\r\n          } else if (xAlign === 'right') {\r\n            x2 = ptX + width - cornerRadius - caretSize;\r\n          } else {\r\n            x2 = this.caretX;\r\n          }\r\n          if (yAlign === 'top') {\r\n            y1 = ptY;\r\n            y2 = y1 - caretSize;\r\n            x1 = x2 - caretSize;\r\n            x3 = x2 + caretSize;\r\n          } else {\r\n            y1 = ptY + height;\r\n            y2 = y1 + caretSize;\r\n            x1 = x2 + caretSize;\r\n            x3 = x2 - caretSize;\r\n          }\r\n          y3 = y1;\r\n        }\r\n        return {x1, x2, x3, y1, y2, y3};\r\n      }\r\n      drawTitle(pt, ctx, options) {\r\n        const me = this;\r\n        const title = me.title;\r\n        const length = title.length;\r\n        let titleFont, titleSpacing, i;\r\n        if (length) {\r\n          const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\r\n          pt.x = getAlignedX(me, options.titleAlign, options);\r\n          ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\r\n          ctx.textBaseline = 'middle';\r\n          titleFont = toFont(options.titleFont);\r\n          titleSpacing = options.titleSpacing;\r\n          ctx.fillStyle = options.titleColor;\r\n          ctx.font = titleFont.string;\r\n          for (i = 0; i < length; ++i) {\r\n            ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\r\n            pt.y += titleFont.lineHeight + titleSpacing;\r\n            if (i + 1 === length) {\r\n              pt.y += options.titleMarginBottom - titleSpacing;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      _drawColorBox(ctx, pt, i, rtlHelper, options) {\r\n        const me = this;\r\n        const labelColors = me.labelColors[i];\r\n        const labelPointStyle = me.labelPointStyles[i];\r\n        const {boxHeight, boxWidth} = options;\r\n        const bodyFont = toFont(options.bodyFont);\r\n        const colorX = getAlignedX(me, 'left', options);\r\n        const rtlColorX = rtlHelper.x(colorX);\r\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\r\n        const colorY = pt.y + yOffSet;\r\n        if (options.usePointStyle) {\r\n          const drawOptions = {\r\n            radius: Math.min(boxWidth, boxHeight) / 2,\r\n            pointStyle: labelPointStyle.pointStyle,\r\n            rotation: labelPointStyle.rotation,\r\n            borderWidth: 1\r\n          };\r\n          const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\r\n          const centerY = colorY + boxHeight / 2;\r\n          ctx.strokeStyle = options.multiKeyBackground;\r\n          ctx.fillStyle = options.multiKeyBackground;\r\n          drawPoint(ctx, drawOptions, centerX, centerY);\r\n          ctx.strokeStyle = labelColors.borderColor;\r\n          ctx.fillStyle = labelColors.backgroundColor;\r\n          drawPoint(ctx, drawOptions, centerX, centerY);\r\n        } else {\r\n          ctx.lineWidth = labelColors.borderWidth || 1;\r\n          ctx.strokeStyle = labelColors.borderColor;\r\n          ctx.setLineDash(labelColors.borderDash || []);\r\n          ctx.lineDashOffset = labelColors.borderDashOffset || 0;\r\n          const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\r\n          const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\r\n          const borderRadius = toTRBLCorners(labelColors.borderRadius);\r\n          if (Object.values(borderRadius).some(v => v !== 0)) {\r\n            ctx.beginPath();\r\n            ctx.fillStyle = options.multiKeyBackground;\r\n            addRoundedRectPath(ctx, {\r\n              x: outerX,\r\n              y: colorY,\r\n              w: boxWidth,\r\n              h: boxHeight,\r\n              radius: borderRadius,\r\n            });\r\n            ctx.fill();\r\n            ctx.stroke();\r\n            ctx.fillStyle = labelColors.backgroundColor;\r\n            ctx.beginPath();\r\n            addRoundedRectPath(ctx, {\r\n              x: innerX,\r\n              y: colorY + 1,\r\n              w: boxWidth - 2,\r\n              h: boxHeight - 2,\r\n              radius: borderRadius,\r\n            });\r\n            ctx.fill();\r\n          } else {\r\n            ctx.fillStyle = options.multiKeyBackground;\r\n            ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\r\n            ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\r\n            ctx.fillStyle = labelColors.backgroundColor;\r\n            ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\r\n          }\r\n        }\r\n        ctx.fillStyle = me.labelTextColors[i];\r\n      }\r\n      drawBody(pt, ctx, options) {\r\n        const me = this;\r\n        const {body} = me;\r\n        const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth} = options;\r\n        const bodyFont = toFont(options.bodyFont);\r\n        let bodyLineHeight = bodyFont.lineHeight;\r\n        let xLinePadding = 0;\r\n        const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\r\n        const fillLineOfText = function(line) {\r\n          ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\r\n          pt.y += bodyLineHeight + bodySpacing;\r\n        };\r\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\r\n        ctx.textAlign = bodyAlign;\r\n        ctx.textBaseline = 'middle';\r\n        ctx.font = bodyFont.string;\r\n        pt.x = getAlignedX(me, bodyAlignForCalculation, options);\r\n        ctx.fillStyle = options.bodyColor;\r\n        each(me.beforeBody, fillLineOfText);\r\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\r\n          ? bodyAlign === 'center' ? (boxWidth / 2 + 1) : (boxWidth + 2)\r\n          : 0;\r\n        for (i = 0, ilen = body.length; i < ilen; ++i) {\r\n          bodyItem = body[i];\r\n          textColor = me.labelTextColors[i];\r\n          ctx.fillStyle = textColor;\r\n          each(bodyItem.before, fillLineOfText);\r\n          lines = bodyItem.lines;\r\n          if (displayColors && lines.length) {\r\n            me._drawColorBox(ctx, pt, i, rtlHelper, options);\r\n            bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\r\n          }\r\n          for (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n            fillLineOfText(lines[j]);\r\n            bodyLineHeight = bodyFont.lineHeight;\r\n          }\r\n          each(bodyItem.after, fillLineOfText);\r\n        }\r\n        xLinePadding = 0;\r\n        bodyLineHeight = bodyFont.lineHeight;\r\n        each(me.afterBody, fillLineOfText);\r\n        pt.y -= bodySpacing;\r\n      }\r\n      drawFooter(pt, ctx, options) {\r\n        const me = this;\r\n        const footer = me.footer;\r\n        const length = footer.length;\r\n        let footerFont, i;\r\n        if (length) {\r\n          const rtlHelper = getRtlAdapter(options.rtl, me.x, me.width);\r\n          pt.x = getAlignedX(me, options.footerAlign, options);\r\n          pt.y += options.footerMarginTop;\r\n          ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\r\n          ctx.textBaseline = 'middle';\r\n          footerFont = toFont(options.footerFont);\r\n          ctx.fillStyle = options.footerColor;\r\n          ctx.font = footerFont.string;\r\n          for (i = 0; i < length; ++i) {\r\n            ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\r\n            pt.y += footerFont.lineHeight + options.footerSpacing;\r\n          }\r\n        }\r\n      }\r\n      drawBackground(pt, ctx, tooltipSize, options) {\r\n        const {xAlign, yAlign} = this;\r\n        const {x, y} = pt;\r\n        const {width, height} = tooltipSize;\r\n        const radius = options.cornerRadius;\r\n        ctx.fillStyle = options.backgroundColor;\r\n        ctx.strokeStyle = options.borderColor;\r\n        ctx.lineWidth = options.borderWidth;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + radius, y);\r\n        if (yAlign === 'top') {\r\n          this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x + width - radius, y);\r\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n        if (yAlign === 'center' && xAlign === 'right') {\r\n          this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x + width, y + height - radius);\r\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n        if (yAlign === 'bottom') {\r\n          this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x + radius, y + height);\r\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n        if (yAlign === 'center' && xAlign === 'left') {\r\n          this.drawCaret(pt, ctx, tooltipSize, options);\r\n        }\r\n        ctx.lineTo(x, y + radius);\r\n        ctx.quadraticCurveTo(x, y, x + radius, y);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        if (options.borderWidth > 0) {\r\n          ctx.stroke();\r\n        }\r\n      }\r\n      _updateAnimationTarget(options) {\r\n        const me = this;\r\n        const chart = me._chart;\r\n        const anims = me.$animations;\r\n        const animX = anims && anims.x;\r\n        const animY = anims && anims.y;\r\n        if (animX || animY) {\r\n          const position = positioners[options.position].call(me, me._active, me._eventPosition);\r\n          if (!position) {\r\n            return;\r\n          }\r\n          const size = me._size = getTooltipSize(me, options);\r\n          const positionAndSize = Object.assign({}, position, me._size);\r\n          const alignment = determineAlignment(chart, options, positionAndSize);\r\n          const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\r\n          if (animX._to !== point.x || animY._to !== point.y) {\r\n            me.xAlign = alignment.xAlign;\r\n            me.yAlign = alignment.yAlign;\r\n            me.width = size.width;\r\n            me.height = size.height;\r\n            me.caretX = position.x;\r\n            me.caretY = position.y;\r\n            me._resolveAnimations().update(me, point);\r\n          }\r\n        }\r\n      }\r\n      draw(ctx) {\r\n        const me = this;\r\n        const options = me.options.setContext(me.getContext());\r\n        let opacity = me.opacity;\r\n        if (!opacity) {\r\n          return;\r\n        }\r\n        me._updateAnimationTarget(options);\r\n        const tooltipSize = {\r\n          width: me.width,\r\n          height: me.height\r\n        };\r\n        const pt = {\r\n          x: me.x,\r\n          y: me.y\r\n        };\r\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\r\n        const padding = toPadding(options.padding);\r\n        const hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;\r\n        if (options.enabled && hasTooltipContent) {\r\n          ctx.save();\r\n          ctx.globalAlpha = opacity;\r\n          me.drawBackground(pt, ctx, tooltipSize, options);\r\n          overrideTextDirection(ctx, options.textDirection);\r\n          pt.y += padding.top;\r\n          me.drawTitle(pt, ctx, options);\r\n          me.drawBody(pt, ctx, options);\r\n          me.drawFooter(pt, ctx, options);\r\n          restoreTextDirection(ctx, options.textDirection);\r\n          ctx.restore();\r\n        }\r\n      }\r\n      getActiveElements() {\r\n        return this._active || [];\r\n      }\r\n      setActiveElements(activeElements, eventPosition) {\r\n        const me = this;\r\n        const lastActive = me._active;\r\n        const active = activeElements.map(({datasetIndex, index}) => {\r\n          const meta = me._chart.getDatasetMeta(datasetIndex);\r\n          if (!meta) {\r\n            throw new Error('Cannot find a dataset at index ' + datasetIndex);\r\n          }\r\n          return {\r\n            datasetIndex,\r\n            element: meta.data[index],\r\n            index,\r\n          };\r\n        });\r\n        const changed = !_elementsEqual(lastActive, active);\r\n        const positionChanged = me._positionChanged(active, eventPosition);\r\n        if (changed || positionChanged) {\r\n          me._active = active;\r\n          me._eventPosition = eventPosition;\r\n          me.update(true);\r\n        }\r\n      }\r\n      handleEvent(e, replay) {\r\n        const me = this;\r\n        const options = me.options;\r\n        const lastActive = me._active || [];\r\n        let changed = false;\r\n        let active = [];\r\n        if (e.type !== 'mouseout') {\r\n          active = me._chart.getElementsAtEventForMode(e, options.mode, options, replay);\r\n          if (options.reverse) {\r\n            active.reverse();\r\n          }\r\n        }\r\n        const positionChanged = me._positionChanged(active, e);\r\n        changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\r\n        if (changed) {\r\n          me._active = active;\r\n          if (options.enabled || options.external) {\r\n            me._eventPosition = {\r\n              x: e.x,\r\n              y: e.y\r\n            };\r\n            me.update(true, replay);\r\n          }\r\n        }\r\n        return changed;\r\n      }\r\n      _positionChanged(active, e) {\r\n        const {caretX, caretY, options} = this;\r\n        const position = positioners[options.position].call(this, active, e);\r\n        return position !== false && (caretX !== position.x || caretY !== position.y);\r\n      }\r\n    }\r\n    Tooltip.positioners = positioners;\r\n    var plugin_tooltip = {\r\n      id: 'tooltip',\r\n      _element: Tooltip,\r\n      positioners,\r\n      afterInit(chart, _args, options) {\r\n        if (options) {\r\n          chart.tooltip = new Tooltip({_chart: chart, options});\r\n        }\r\n      },\r\n      beforeUpdate(chart, _args, options) {\r\n        if (chart.tooltip) {\r\n          chart.tooltip.initialize(options);\r\n        }\r\n      },\r\n      reset(chart, _args, options) {\r\n        if (chart.tooltip) {\r\n          chart.tooltip.initialize(options);\r\n        }\r\n      },\r\n      afterDraw(chart) {\r\n        const tooltip = chart.tooltip;\r\n        const args = {\r\n          tooltip\r\n        };\r\n        if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\r\n          return;\r\n        }\r\n        if (tooltip) {\r\n          tooltip.draw(chart.ctx);\r\n        }\r\n        chart.notifyPlugins('afterTooltipDraw', args);\r\n      },\r\n      afterEvent(chart, args) {\r\n        if (chart.tooltip) {\r\n          const useFinalPosition = args.replay;\r\n          if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {\r\n            args.changed = true;\r\n          }\r\n        }\r\n      },\r\n      defaults: {\r\n        enabled: true,\r\n        external: null,\r\n        position: 'average',\r\n        backgroundColor: 'rgba(0,0,0,0.8)',\r\n        titleColor: '#fff',\r\n        titleFont: {\r\n          weight: 'bold',\r\n        },\r\n        titleSpacing: 2,\r\n        titleMarginBottom: 6,\r\n        titleAlign: 'left',\r\n        bodyColor: '#fff',\r\n        bodySpacing: 2,\r\n        bodyFont: {\r\n        },\r\n        bodyAlign: 'left',\r\n        footerColor: '#fff',\r\n        footerSpacing: 2,\r\n        footerMarginTop: 6,\r\n        footerFont: {\r\n          weight: 'bold',\r\n        },\r\n        footerAlign: 'left',\r\n        padding: 6,\r\n        caretPadding: 2,\r\n        caretSize: 5,\r\n        cornerRadius: 6,\r\n        boxHeight: (ctx, opts) => opts.bodyFont.size,\r\n        boxWidth: (ctx, opts) => opts.bodyFont.size,\r\n        multiKeyBackground: '#fff',\r\n        displayColors: true,\r\n        borderColor: 'rgba(0,0,0,0)',\r\n        borderWidth: 0,\r\n        animation: {\r\n          duration: 400,\r\n          easing: 'easeOutQuart',\r\n        },\r\n        animations: {\r\n          numbers: {\r\n            type: 'number',\r\n            properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\r\n          },\r\n          opacity: {\r\n            easing: 'linear',\r\n            duration: 200\r\n          }\r\n        },\r\n        callbacks: {\r\n          beforeTitle: noop,\r\n          title(tooltipItems) {\r\n            if (tooltipItems.length > 0) {\r\n              const item = tooltipItems[0];\r\n              const labels = item.chart.data.labels;\r\n              const labelCount = labels ? labels.length : 0;\r\n              if (this && this.options && this.options.mode === 'dataset') {\r\n                return item.dataset.label || '';\r\n              } else if (item.label) {\r\n                return item.label;\r\n              } else if (labelCount > 0 && item.dataIndex < labelCount) {\r\n                return labels[item.dataIndex];\r\n              }\r\n            }\r\n            return '';\r\n          },\r\n          afterTitle: noop,\r\n          beforeBody: noop,\r\n          beforeLabel: noop,\r\n          label(tooltipItem) {\r\n            if (this && this.options && this.options.mode === 'dataset') {\r\n              return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\r\n            }\r\n            let label = tooltipItem.dataset.label || '';\r\n            if (label) {\r\n              label += ': ';\r\n            }\r\n            const value = tooltipItem.formattedValue;\r\n            if (!isNullOrUndef(value)) {\r\n              label += value;\r\n            }\r\n            return label;\r\n          },\r\n          labelColor(tooltipItem) {\r\n            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n            const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n            return {\r\n              borderColor: options.borderColor,\r\n              backgroundColor: options.backgroundColor,\r\n              borderWidth: options.borderWidth,\r\n              borderDash: options.borderDash,\r\n              borderDashOffset: options.borderDashOffset,\r\n              borderRadius: 0,\r\n            };\r\n          },\r\n          labelTextColor() {\r\n            return this.options.bodyColor;\r\n          },\r\n          labelPointStyle(tooltipItem) {\r\n            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n            const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n            return {\r\n              pointStyle: options.pointStyle,\r\n              rotation: options.rotation,\r\n            };\r\n          },\r\n          afterLabel: noop,\r\n          afterBody: noop,\r\n          beforeFooter: noop,\r\n          footer: noop,\r\n          afterFooter: noop\r\n        }\r\n      },\r\n      defaultRoutes: {\r\n        bodyFont: 'font',\r\n        footerFont: 'font',\r\n        titleFont: 'font'\r\n      },\r\n      descriptors: {\r\n        _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\r\n        _indexable: false,\r\n        callbacks: {\r\n          _scriptable: false,\r\n          _indexable: false,\r\n        },\r\n        animation: {\r\n          _fallback: false\r\n        },\r\n        animations: {\r\n          _fallback: 'animation'\r\n        }\r\n      },\r\n      additionalOptionScopes: ['interaction']\r\n    };\r\n    \r\n    var plugins = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    Decimation: plugin_decimation,\r\n    Filler: plugin_filler,\r\n    Legend: plugin_legend,\r\n    Title: plugin_title,\r\n    Tooltip: plugin_tooltip\r\n    });\r\n    \r\n    const addIfString = (labels, raw, index) => typeof raw === 'string'\r\n      ? labels.push(raw) - 1\r\n      : isNaN(raw) ? null : index;\r\n    function findOrAddLabel(labels, raw, index) {\r\n      const first = labels.indexOf(raw);\r\n      if (first === -1) {\r\n        return addIfString(labels, raw, index);\r\n      }\r\n      const last = labels.lastIndexOf(raw);\r\n      return first !== last ? index : first;\r\n    }\r\n    const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\r\n    class CategoryScale extends Scale {\r\n      constructor(cfg) {\r\n        super(cfg);\r\n        this._startValue = undefined;\r\n        this._valueRange = 0;\r\n      }\r\n      parse(raw, index) {\r\n        if (isNullOrUndef(raw)) {\r\n          return null;\r\n        }\r\n        const labels = this.getLabels();\r\n        index = isFinite(index) && labels[index] === raw ? index\r\n          : findOrAddLabel(labels, raw, valueOrDefault(index, raw));\r\n        return validIndex(index, labels.length - 1);\r\n      }\r\n      determineDataLimits() {\r\n        const me = this;\r\n        const {minDefined, maxDefined} = me.getUserBounds();\r\n        let {min, max} = me.getMinMax(true);\r\n        if (me.options.bounds === 'ticks') {\r\n          if (!minDefined) {\r\n            min = 0;\r\n          }\r\n          if (!maxDefined) {\r\n            max = me.getLabels().length - 1;\r\n          }\r\n        }\r\n        me.min = min;\r\n        me.max = max;\r\n      }\r\n      buildTicks() {\r\n        const me = this;\r\n        const min = me.min;\r\n        const max = me.max;\r\n        const offset = me.options.offset;\r\n        const ticks = [];\r\n        let labels = me.getLabels();\r\n        labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\r\n        me._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\r\n        me._startValue = me.min - (offset ? 0.5 : 0);\r\n        for (let value = min; value <= max; value++) {\r\n          ticks.push({value});\r\n        }\r\n        return ticks;\r\n      }\r\n      getLabelForValue(value) {\r\n        const me = this;\r\n        const labels = me.getLabels();\r\n        if (value >= 0 && value < labels.length) {\r\n          return labels[value];\r\n        }\r\n        return value;\r\n      }\r\n      configure() {\r\n        const me = this;\r\n        super.configure();\r\n        if (!me.isHorizontal()) {\r\n          me._reversePixels = !me._reversePixels;\r\n        }\r\n      }\r\n      getPixelForValue(value) {\r\n        const me = this;\r\n        if (typeof value !== 'number') {\r\n          value = me.parse(value);\r\n        }\r\n        return value === null ? NaN : me.getPixelForDecimal((value - me._startValue) / me._valueRange);\r\n      }\r\n      getPixelForTick(index) {\r\n        const me = this;\r\n        const ticks = me.ticks;\r\n        if (index < 0 || index > ticks.length - 1) {\r\n          return null;\r\n        }\r\n        return me.getPixelForValue(ticks[index].value);\r\n      }\r\n      getValueForPixel(pixel) {\r\n        const me = this;\r\n        return Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);\r\n      }\r\n      getBasePixel() {\r\n        return this.bottom;\r\n      }\r\n    }\r\n    CategoryScale.id = 'category';\r\n    CategoryScale.defaults = {\r\n      ticks: {\r\n        callback: CategoryScale.prototype.getLabelForValue\r\n      }\r\n    };\r\n    \r\n    function generateTicks$1(generationOptions, dataRange) {\r\n      const ticks = [];\r\n      const MIN_SPACING = 1e-14;\r\n      const {step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\r\n      const unit = step || 1;\r\n      const maxSpaces = maxTicks - 1;\r\n      const {min: rmin, max: rmax} = dataRange;\r\n      const minDefined = !isNullOrUndef(min);\r\n      const maxDefined = !isNullOrUndef(max);\r\n      const countDefined = !isNullOrUndef(count);\r\n      const minSpacing = (rmax - rmin) / (maxDigits + 1);\r\n      let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\r\n      let factor, niceMin, niceMax, numSpaces;\r\n      if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\r\n        return [{value: rmin}, {value: rmax}];\r\n      }\r\n      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n      if (numSpaces > maxSpaces) {\r\n        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\r\n      }\r\n      if (!isNullOrUndef(precision)) {\r\n        factor = Math.pow(10, precision);\r\n        spacing = Math.ceil(spacing * factor) / factor;\r\n      }\r\n      niceMin = Math.floor(rmin / spacing) * spacing;\r\n      niceMax = Math.ceil(rmax / spacing) * spacing;\r\n      if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\r\n        numSpaces = Math.min((max - min) / spacing, maxTicks);\r\n        spacing = (max - min) / numSpaces;\r\n        niceMin = min;\r\n        niceMax = max;\r\n      } else if (countDefined) {\r\n        niceMin = minDefined ? min : niceMin;\r\n        niceMax = maxDefined ? max : niceMax;\r\n        numSpaces = count - 1;\r\n        spacing = (niceMax - niceMin) / numSpaces;\r\n      } else {\r\n        numSpaces = (niceMax - niceMin) / spacing;\r\n        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n          numSpaces = Math.round(numSpaces);\r\n        } else {\r\n          numSpaces = Math.ceil(numSpaces);\r\n        }\r\n      }\r\n      const decimalPlaces = Math.max(\r\n        _decimalPlaces(spacing),\r\n        _decimalPlaces(niceMin),\r\n      );\r\n      factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\r\n      niceMin = Math.round(niceMin * factor) / factor;\r\n      niceMax = Math.round(niceMax * factor) / factor;\r\n      let j = 0;\r\n      if (minDefined) {\r\n        if (includeBounds && niceMin !== min) {\r\n          ticks.push({value: min});\r\n          if (niceMin < min) {\r\n            j++;\r\n          }\r\n          if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\r\n            j++;\r\n          }\r\n        } else if (niceMin < min) {\r\n          j++;\r\n        }\r\n      }\r\n      for (; j < numSpaces; ++j) {\r\n        ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\r\n      }\r\n      if (maxDefined && includeBounds && niceMax !== max) {\r\n        if (almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\r\n          ticks[ticks.length - 1].value = max;\r\n        } else {\r\n          ticks.push({value: max});\r\n        }\r\n      } else if (!maxDefined || niceMax === max) {\r\n        ticks.push({value: niceMax});\r\n      }\r\n      return ticks;\r\n    }\r\n    function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\r\n      const rad = toRadians(minRotation);\r\n      const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\r\n      const length = 0.75 * minSpacing * ('' + value).length;\r\n      return Math.min(minSpacing / ratio, length);\r\n    }\r\n    class LinearScaleBase extends Scale {\r\n      constructor(cfg) {\r\n        super(cfg);\r\n        this.start = undefined;\r\n        this.end = undefined;\r\n        this._startValue = undefined;\r\n        this._endValue = undefined;\r\n        this._valueRange = 0;\r\n      }\r\n      parse(raw, index) {\r\n        if (isNullOrUndef(raw)) {\r\n          return null;\r\n        }\r\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\r\n          return null;\r\n        }\r\n        return +raw;\r\n      }\r\n      handleTickRangeOptions() {\r\n        const me = this;\r\n        const {beginAtZero} = me.options;\r\n        const {minDefined, maxDefined} = me.getUserBounds();\r\n        let {min, max} = me;\r\n        const setMin = v => (min = minDefined ? min : v);\r\n        const setMax = v => (max = maxDefined ? max : v);\r\n        if (beginAtZero) {\r\n          const minSign = sign(min);\r\n          const maxSign = sign(max);\r\n          if (minSign < 0 && maxSign < 0) {\r\n            setMax(0);\r\n          } else if (minSign > 0 && maxSign > 0) {\r\n            setMin(0);\r\n          }\r\n        }\r\n        if (min === max) {\r\n          setMax(max + 1);\r\n          if (!beginAtZero) {\r\n            setMin(min - 1);\r\n          }\r\n        }\r\n        me.min = min;\r\n        me.max = max;\r\n      }\r\n      getTickLimit() {\r\n        const me = this;\r\n        const tickOpts = me.options.ticks;\r\n        let {maxTicksLimit, stepSize} = tickOpts;\r\n        let maxTicks;\r\n        if (stepSize) {\r\n          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\r\n        } else {\r\n          maxTicks = me.computeTickLimit();\r\n          maxTicksLimit = maxTicksLimit || 11;\r\n        }\r\n        if (maxTicksLimit) {\r\n          maxTicks = Math.min(maxTicksLimit, maxTicks);\r\n        }\r\n        return maxTicks;\r\n      }\r\n      computeTickLimit() {\r\n        return Number.POSITIVE_INFINITY;\r\n      }\r\n      buildTicks() {\r\n        const me = this;\r\n        const opts = me.options;\r\n        const tickOpts = opts.ticks;\r\n        let maxTicks = me.getTickLimit();\r\n        maxTicks = Math.max(2, maxTicks);\r\n        const numericGeneratorOptions = {\r\n          maxTicks,\r\n          min: opts.min,\r\n          max: opts.max,\r\n          precision: tickOpts.precision,\r\n          step: tickOpts.stepSize,\r\n          count: tickOpts.count,\r\n          maxDigits: me._maxDigits(),\r\n          horizontal: me.isHorizontal(),\r\n          minRotation: tickOpts.minRotation || 0,\r\n          includeBounds: tickOpts.includeBounds !== false\r\n        };\r\n        const dataRange = me._range || me;\r\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\r\n        if (opts.bounds === 'ticks') {\r\n          _setMinAndMaxByKey(ticks, me, 'value');\r\n        }\r\n        if (opts.reverse) {\r\n          ticks.reverse();\r\n          me.start = me.max;\r\n          me.end = me.min;\r\n        } else {\r\n          me.start = me.min;\r\n          me.end = me.max;\r\n        }\r\n        return ticks;\r\n      }\r\n      configure() {\r\n        const me = this;\r\n        const ticks = me.ticks;\r\n        let start = me.min;\r\n        let end = me.max;\r\n        super.configure();\r\n        if (me.options.offset && ticks.length) {\r\n          const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\r\n          start -= offset;\r\n          end += offset;\r\n        }\r\n        me._startValue = start;\r\n        me._endValue = end;\r\n        me._valueRange = end - start;\r\n      }\r\n      getLabelForValue(value) {\r\n        return formatNumber(value, this.chart.options.locale);\r\n      }\r\n    }\r\n    \r\n    class LinearScale extends LinearScaleBase {\r\n      determineDataLimits() {\r\n        const me = this;\r\n        const {min, max} = me.getMinMax(true);\r\n        me.min = isNumberFinite(min) ? min : 0;\r\n        me.max = isNumberFinite(max) ? max : 1;\r\n        me.handleTickRangeOptions();\r\n      }\r\n      computeTickLimit() {\r\n        const me = this;\r\n        const horizontal = me.isHorizontal();\r\n        const length = horizontal ? me.width : me.height;\r\n        const minRotation = toRadians(me.options.ticks.minRotation);\r\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\r\n        const tickFont = me._resolveTickFontOptions(0);\r\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\r\n      }\r\n      getPixelForValue(value) {\r\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n      }\r\n      getValueForPixel(pixel) {\r\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\r\n      }\r\n    }\r\n    LinearScale.id = 'linear';\r\n    LinearScale.defaults = {\r\n      ticks: {\r\n        callback: Ticks.formatters.numeric\r\n      }\r\n    };\r\n    \r\n    function isMajor(tickVal) {\r\n      const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\r\n      return remain === 1;\r\n    }\r\n    function generateTicks(generationOptions, dataRange) {\r\n      const endExp = Math.floor(log10(dataRange.max));\r\n      const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\r\n      const ticks = [];\r\n      let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\r\n      let exp = Math.floor(log10(tickVal));\r\n      let significand = Math.floor(tickVal / Math.pow(10, exp));\r\n      let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\r\n      do {\r\n        ticks.push({value: tickVal, major: isMajor(tickVal)});\r\n        ++significand;\r\n        if (significand === 10) {\r\n          significand = 1;\r\n          ++exp;\r\n          precision = exp >= 0 ? 1 : precision;\r\n        }\r\n        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\r\n      } while (exp < endExp || (exp === endExp && significand < endSignificand));\r\n      const lastTick = finiteOrDefault(generationOptions.max, tickVal);\r\n      ticks.push({value: lastTick, major: isMajor(tickVal)});\r\n      return ticks;\r\n    }\r\n    class LogarithmicScale extends Scale {\r\n      constructor(cfg) {\r\n        super(cfg);\r\n        this.start = undefined;\r\n        this.end = undefined;\r\n        this._startValue = undefined;\r\n        this._valueRange = 0;\r\n      }\r\n      parse(raw, index) {\r\n        const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\r\n        if (value === 0) {\r\n          this._zero = true;\r\n          return undefined;\r\n        }\r\n        return isNumberFinite(value) && value > 0 ? value : null;\r\n      }\r\n      determineDataLimits() {\r\n        const me = this;\r\n        const {min, max} = me.getMinMax(true);\r\n        me.min = isNumberFinite(min) ? Math.max(0, min) : null;\r\n        me.max = isNumberFinite(max) ? Math.max(0, max) : null;\r\n        if (me.options.beginAtZero) {\r\n          me._zero = true;\r\n        }\r\n        me.handleTickRangeOptions();\r\n      }\r\n      handleTickRangeOptions() {\r\n        const me = this;\r\n        const {minDefined, maxDefined} = me.getUserBounds();\r\n        let min = me.min;\r\n        let max = me.max;\r\n        const setMin = v => (min = minDefined ? min : v);\r\n        const setMax = v => (max = maxDefined ? max : v);\r\n        const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\r\n        if (min === max) {\r\n          if (min <= 0) {\r\n            setMin(1);\r\n            setMax(10);\r\n          } else {\r\n            setMin(exp(min, -1));\r\n            setMax(exp(max, +1));\r\n          }\r\n        }\r\n        if (min <= 0) {\r\n          setMin(exp(max, -1));\r\n        }\r\n        if (max <= 0) {\r\n          setMax(exp(min, +1));\r\n        }\r\n        if (me._zero && me.min !== me._suggestedMin && min === exp(me.min, 0)) {\r\n          setMin(exp(min, -1));\r\n        }\r\n        me.min = min;\r\n        me.max = max;\r\n      }\r\n      buildTicks() {\r\n        const me = this;\r\n        const opts = me.options;\r\n        const generationOptions = {\r\n          min: me._userMin,\r\n          max: me._userMax\r\n        };\r\n        const ticks = generateTicks(generationOptions, me);\r\n        if (opts.bounds === 'ticks') {\r\n          _setMinAndMaxByKey(ticks, me, 'value');\r\n        }\r\n        if (opts.reverse) {\r\n          ticks.reverse();\r\n          me.start = me.max;\r\n          me.end = me.min;\r\n        } else {\r\n          me.start = me.min;\r\n          me.end = me.max;\r\n        }\r\n        return ticks;\r\n      }\r\n      getLabelForValue(value) {\r\n        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale);\r\n      }\r\n      configure() {\r\n        const me = this;\r\n        const start = me.min;\r\n        super.configure();\r\n        me._startValue = log10(start);\r\n        me._valueRange = log10(me.max) - log10(start);\r\n      }\r\n      getPixelForValue(value) {\r\n        const me = this;\r\n        if (value === undefined || value === 0) {\r\n          value = me.min;\r\n        }\r\n        if (value === null || isNaN(value)) {\r\n          return NaN;\r\n        }\r\n        return me.getPixelForDecimal(value === me.min\r\n          ? 0\r\n          : (log10(value) - me._startValue) / me._valueRange);\r\n      }\r\n      getValueForPixel(pixel) {\r\n        const me = this;\r\n        const decimal = me.getDecimalForPixel(pixel);\r\n        return Math.pow(10, me._startValue + decimal * me._valueRange);\r\n      }\r\n    }\r\n    LogarithmicScale.id = 'logarithmic';\r\n    LogarithmicScale.defaults = {\r\n      ticks: {\r\n        callback: Ticks.formatters.logarithmic,\r\n        major: {\r\n          enabled: true\r\n        }\r\n      }\r\n    };\r\n    \r\n    function getTickBackdropHeight(opts) {\r\n      const tickOpts = opts.ticks;\r\n      if (tickOpts.display && opts.display) {\r\n        const padding = toPadding(tickOpts.backdropPadding);\r\n        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\r\n      }\r\n      return 0;\r\n    }\r\n    function measureLabelSize(ctx, lineHeight, label) {\r\n      if (isArray(label)) {\r\n        return {\r\n          w: _longestText(ctx, ctx.font, label),\r\n          h: label.length * lineHeight\r\n        };\r\n      }\r\n      return {\r\n        w: ctx.measureText(label).width,\r\n        h: lineHeight\r\n      };\r\n    }\r\n    function determineLimits(angle, pos, size, min, max) {\r\n      if (angle === min || angle === max) {\r\n        return {\r\n          start: pos - (size / 2),\r\n          end: pos + (size / 2)\r\n        };\r\n      } else if (angle < min || angle > max) {\r\n        return {\r\n          start: pos - size,\r\n          end: pos\r\n        };\r\n      }\r\n      return {\r\n        start: pos,\r\n        end: pos + size\r\n      };\r\n    }\r\n    function fitWithPointLabels(scale) {\r\n      const furthestLimits = {\r\n        l: 0,\r\n        r: scale.width,\r\n        t: 0,\r\n        b: scale.height - scale.paddingTop\r\n      };\r\n      const furthestAngles = {};\r\n      let i, textSize, pointPosition;\r\n      const labelSizes = [];\r\n      const padding = [];\r\n      const valueCount = scale.getLabels().length;\r\n      for (i = 0; i < valueCount; i++) {\r\n        const opts = scale.options.pointLabels.setContext(scale.getContext(i));\r\n        padding[i] = opts.padding;\r\n        pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);\r\n        const plFont = toFont(opts.font);\r\n        scale.ctx.font = plFont.string;\r\n        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale._pointLabels[i]);\r\n        labelSizes[i] = textSize;\r\n        const angleRadians = scale.getIndexAngle(i);\r\n        const angle = toDegrees(angleRadians);\r\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n        if (hLimits.start < furthestLimits.l) {\r\n          furthestLimits.l = hLimits.start;\r\n          furthestAngles.l = angleRadians;\r\n        }\r\n        if (hLimits.end > furthestLimits.r) {\r\n          furthestLimits.r = hLimits.end;\r\n          furthestAngles.r = angleRadians;\r\n        }\r\n        if (vLimits.start < furthestLimits.t) {\r\n          furthestLimits.t = vLimits.start;\r\n          furthestAngles.t = angleRadians;\r\n        }\r\n        if (vLimits.end > furthestLimits.b) {\r\n          furthestLimits.b = vLimits.end;\r\n          furthestAngles.b = angleRadians;\r\n        }\r\n      }\r\n      scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);\r\n      scale._pointLabelItems = [];\r\n      const opts = scale.options;\r\n      const tickBackdropHeight = getTickBackdropHeight(opts);\r\n      const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n      for (i = 0; i < valueCount; i++) {\r\n        const extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);\r\n        const angle = toDegrees(scale.getIndexAngle(i));\r\n        const size = labelSizes[i];\r\n        adjustPointPositionForLabelHeight(angle, size, pointLabelPosition);\r\n        const textAlign = getTextAlignForAngle(angle);\r\n        let left;\r\n        if (textAlign === 'left') {\r\n          left = pointLabelPosition.x;\r\n        } else if (textAlign === 'center') {\r\n          left = pointLabelPosition.x - (size.w / 2);\r\n        } else {\r\n          left = pointLabelPosition.x - size.w;\r\n        }\r\n        const right = left + size.w;\r\n        scale._pointLabelItems[i] = {\r\n          x: pointLabelPosition.x,\r\n          y: pointLabelPosition.y,\r\n          textAlign,\r\n          left,\r\n          top: pointLabelPosition.y,\r\n          right,\r\n          bottom: pointLabelPosition.y + size.h,\r\n        };\r\n      }\r\n    }\r\n    function getTextAlignForAngle(angle) {\r\n      if (angle === 0 || angle === 180) {\r\n        return 'center';\r\n      } else if (angle < 180) {\r\n        return 'left';\r\n      }\r\n      return 'right';\r\n    }\r\n    function adjustPointPositionForLabelHeight(angle, textSize, position) {\r\n      if (angle === 90 || angle === 270) {\r\n        position.y -= (textSize.h / 2);\r\n      } else if (angle > 270 || angle < 90) {\r\n        position.y -= textSize.h;\r\n      }\r\n    }\r\n    function drawPointLabels(scale, labelCount) {\r\n      const {ctx, options: {pointLabels}} = scale;\r\n      for (let i = labelCount - 1; i >= 0; i--) {\r\n        const optsAtIndex = pointLabels.setContext(scale.getContext(i));\r\n        const plFont = toFont(optsAtIndex.font);\r\n        const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\r\n        const {backdropColor} = optsAtIndex;\r\n        if (!isNullOrUndef(backdropColor)) {\r\n          const padding = toPadding(optsAtIndex.backdropPadding);\r\n          ctx.fillStyle = backdropColor;\r\n          ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);\r\n        }\r\n        renderText(\r\n          ctx,\r\n          scale._pointLabels[i],\r\n          x,\r\n          y + (plFont.lineHeight / 2),\r\n          plFont,\r\n          {\r\n            color: optsAtIndex.color,\r\n            textAlign: textAlign,\r\n            textBaseline: 'middle'\r\n          }\r\n        );\r\n      }\r\n    }\r\n    function pathRadiusLine(scale, radius, circular, labelCount) {\r\n      const {ctx} = scale;\r\n      if (circular) {\r\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\r\n      } else {\r\n        let pointPosition = scale.getPointPosition(0, radius);\r\n        ctx.moveTo(pointPosition.x, pointPosition.y);\r\n        for (let i = 1; i < labelCount; i++) {\r\n          pointPosition = scale.getPointPosition(i, radius);\r\n          ctx.lineTo(pointPosition.x, pointPosition.y);\r\n        }\r\n      }\r\n    }\r\n    function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\r\n      const ctx = scale.ctx;\r\n      const circular = gridLineOpts.circular;\r\n      const {color, lineWidth} = gridLineOpts;\r\n      if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\r\n        return;\r\n      }\r\n      ctx.save();\r\n      ctx.strokeStyle = color;\r\n      ctx.lineWidth = lineWidth;\r\n      ctx.setLineDash(gridLineOpts.borderDash);\r\n      ctx.lineDashOffset = gridLineOpts.borderDashOffset;\r\n      ctx.beginPath();\r\n      pathRadiusLine(scale, radius, circular, labelCount);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n      ctx.restore();\r\n    }\r\n    function numberOrZero(param) {\r\n      return isNumber(param) ? param : 0;\r\n    }\r\n    class RadialLinearScale extends LinearScaleBase {\r\n      constructor(cfg) {\r\n        super(cfg);\r\n        this.xCenter = undefined;\r\n        this.yCenter = undefined;\r\n        this.drawingArea = undefined;\r\n        this._pointLabels = [];\r\n        this._pointLabelItems = [];\r\n      }\r\n      setDimensions() {\r\n        const me = this;\r\n        me.width = me.maxWidth;\r\n        me.height = me.maxHeight;\r\n        me.paddingTop = getTickBackdropHeight(me.options) / 2;\r\n        me.xCenter = Math.floor(me.width / 2);\r\n        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);\r\n        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\r\n      }\r\n      determineDataLimits() {\r\n        const me = this;\r\n        const {min, max} = me.getMinMax(false);\r\n        me.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\r\n        me.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\r\n        me.handleTickRangeOptions();\r\n      }\r\n      computeTickLimit() {\r\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n      }\r\n      generateTickLabels(ticks) {\r\n        const me = this;\r\n        LinearScaleBase.prototype.generateTickLabels.call(me, ticks);\r\n        me._pointLabels = me.getLabels().map((value, index) => {\r\n          const label = callback(me.options.pointLabels.callback, [value, index], me);\r\n          return label || label === 0 ? label : '';\r\n        });\r\n      }\r\n      fit() {\r\n        const me = this;\r\n        const opts = me.options;\r\n        if (opts.display && opts.pointLabels.display) {\r\n          fitWithPointLabels(me);\r\n        } else {\r\n          me.setCenterPoint(0, 0, 0, 0);\r\n        }\r\n      }\r\n      _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {\r\n        const me = this;\r\n        let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n        let radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n        let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n        let radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\r\n        radiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n        radiusReductionRight = numberOrZero(radiusReductionRight);\r\n        radiusReductionTop = numberOrZero(radiusReductionTop);\r\n        radiusReductionBottom = numberOrZero(radiusReductionBottom);\r\n        me.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(\r\n          Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\r\n          Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));\r\n        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n      }\r\n      setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n        const me = this;\r\n        const maxRight = me.width - rightMovement - me.drawingArea;\r\n        const maxLeft = leftMovement + me.drawingArea;\r\n        const maxTop = topMovement + me.drawingArea;\r\n        const maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\r\n        me.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);\r\n        me.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);\r\n      }\r\n      getIndexAngle(index) {\r\n        const angleMultiplier = TAU / this.getLabels().length;\r\n        const startAngle = this.options.startAngle || 0;\r\n        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\r\n      }\r\n      getDistanceFromCenterForValue(value) {\r\n        const me = this;\r\n        if (isNullOrUndef(value)) {\r\n          return NaN;\r\n        }\r\n        const scalingFactor = me.drawingArea / (me.max - me.min);\r\n        if (me.options.reverse) {\r\n          return (me.max - value) * scalingFactor;\r\n        }\r\n        return (value - me.min) * scalingFactor;\r\n      }\r\n      getValueForDistanceFromCenter(distance) {\r\n        if (isNullOrUndef(distance)) {\r\n          return NaN;\r\n        }\r\n        const me = this;\r\n        const scaledDistance = distance / (me.drawingArea / (me.max - me.min));\r\n        return me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;\r\n      }\r\n      getPointPosition(index, distanceFromCenter) {\r\n        const me = this;\r\n        const angle = me.getIndexAngle(index) - HALF_PI;\r\n        return {\r\n          x: Math.cos(angle) * distanceFromCenter + me.xCenter,\r\n          y: Math.sin(angle) * distanceFromCenter + me.yCenter,\r\n          angle\r\n        };\r\n      }\r\n      getPointPositionForValue(index, value) {\r\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n      }\r\n      getBasePosition(index) {\r\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\r\n      }\r\n      getPointLabelPosition(index) {\r\n        const {left, top, right, bottom} = this._pointLabelItems[index];\r\n        return {\r\n          left,\r\n          top,\r\n          right,\r\n          bottom,\r\n        };\r\n      }\r\n      drawBackground() {\r\n        const me = this;\r\n        const {backgroundColor, grid: {circular}} = me.options;\r\n        if (backgroundColor) {\r\n          const ctx = me.ctx;\r\n          ctx.save();\r\n          ctx.beginPath();\r\n          pathRadiusLine(me, me.getDistanceFromCenterForValue(me._endValue), circular, me.getLabels().length);\r\n          ctx.closePath();\r\n          ctx.fillStyle = backgroundColor;\r\n          ctx.fill();\r\n          ctx.restore();\r\n        }\r\n      }\r\n      drawGrid() {\r\n        const me = this;\r\n        const ctx = me.ctx;\r\n        const opts = me.options;\r\n        const {angleLines, grid} = opts;\r\n        const labelCount = me.getLabels().length;\r\n        let i, offset, position;\r\n        if (opts.pointLabels.display) {\r\n          drawPointLabels(me, labelCount);\r\n        }\r\n        if (grid.display) {\r\n          me.ticks.forEach((tick, index) => {\r\n            if (index !== 0) {\r\n              offset = me.getDistanceFromCenterForValue(tick.value);\r\n              const optsAtIndex = grid.setContext(me.getContext(index - 1));\r\n              drawRadiusLine(me, optsAtIndex, offset, labelCount);\r\n            }\r\n          });\r\n        }\r\n        if (angleLines.display) {\r\n          ctx.save();\r\n          for (i = me.getLabels().length - 1; i >= 0; i--) {\r\n            const optsAtIndex = angleLines.setContext(me.getContext(i));\r\n            const {color, lineWidth} = optsAtIndex;\r\n            if (!lineWidth || !color) {\r\n              continue;\r\n            }\r\n            ctx.lineWidth = lineWidth;\r\n            ctx.strokeStyle = color;\r\n            ctx.setLineDash(optsAtIndex.borderDash);\r\n            ctx.lineDashOffset = optsAtIndex.borderDashOffset;\r\n            offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);\r\n            position = me.getPointPosition(i, offset);\r\n            ctx.beginPath();\r\n            ctx.moveTo(me.xCenter, me.yCenter);\r\n            ctx.lineTo(position.x, position.y);\r\n            ctx.stroke();\r\n          }\r\n          ctx.restore();\r\n        }\r\n      }\r\n      drawBorder() {}\r\n      drawLabels() {\r\n        const me = this;\r\n        const ctx = me.ctx;\r\n        const opts = me.options;\r\n        const tickOpts = opts.ticks;\r\n        if (!tickOpts.display) {\r\n          return;\r\n        }\r\n        const startAngle = me.getIndexAngle(0);\r\n        let offset, width;\r\n        ctx.save();\r\n        ctx.translate(me.xCenter, me.yCenter);\r\n        ctx.rotate(startAngle);\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        me.ticks.forEach((tick, index) => {\r\n          if (index === 0 && !opts.reverse) {\r\n            return;\r\n          }\r\n          const optsAtIndex = tickOpts.setContext(me.getContext(index));\r\n          const tickFont = toFont(optsAtIndex.font);\r\n          offset = me.getDistanceFromCenterForValue(me.ticks[index].value);\r\n          if (optsAtIndex.showLabelBackdrop) {\r\n            width = ctx.measureText(tick.label).width;\r\n            ctx.fillStyle = optsAtIndex.backdropColor;\r\n            const padding = toPadding(optsAtIndex.backdropPadding);\r\n            ctx.fillRect(\r\n              -width / 2 - padding.left,\r\n              -offset - tickFont.size / 2 - padding.top,\r\n              width + padding.width,\r\n              tickFont.size + padding.height\r\n            );\r\n          }\r\n          renderText(ctx, tick.label, 0, -offset, tickFont, {\r\n            color: optsAtIndex.color,\r\n          });\r\n        });\r\n        ctx.restore();\r\n      }\r\n      drawTitle() {}\r\n    }\r\n    RadialLinearScale.id = 'radialLinear';\r\n    RadialLinearScale.defaults = {\r\n      display: true,\r\n      animate: true,\r\n      position: 'chartArea',\r\n      angleLines: {\r\n        display: true,\r\n        lineWidth: 1,\r\n        borderDash: [],\r\n        borderDashOffset: 0.0\r\n      },\r\n      grid: {\r\n        circular: false\r\n      },\r\n      startAngle: 0,\r\n      ticks: {\r\n        showLabelBackdrop: true,\r\n        callback: Ticks.formatters.numeric\r\n      },\r\n      pointLabels: {\r\n        backdropColor: undefined,\r\n        backdropPadding: 2,\r\n        display: true,\r\n        font: {\r\n          size: 10\r\n        },\r\n        callback(label) {\r\n          return label;\r\n        },\r\n        padding: 5\r\n      }\r\n    };\r\n    RadialLinearScale.defaultRoutes = {\r\n      'angleLines.color': 'borderColor',\r\n      'pointLabels.color': 'color',\r\n      'ticks.color': 'color'\r\n    };\r\n    RadialLinearScale.descriptors = {\r\n      angleLines: {\r\n        _fallback: 'grid'\r\n      }\r\n    };\r\n    \r\n    const INTERVALS = {\r\n      millisecond: {common: true, size: 1, steps: 1000},\r\n      second: {common: true, size: 1000, steps: 60},\r\n      minute: {common: true, size: 60000, steps: 60},\r\n      hour: {common: true, size: 3600000, steps: 24},\r\n      day: {common: true, size: 86400000, steps: 30},\r\n      week: {common: false, size: 604800000, steps: 4},\r\n      month: {common: true, size: 2.628e9, steps: 12},\r\n      quarter: {common: false, size: 7.884e9, steps: 4},\r\n      year: {common: true, size: 3.154e10}\r\n    };\r\n    const UNITS = (Object.keys(INTERVALS));\r\n    function sorter(a, b) {\r\n      return a - b;\r\n    }\r\n    function parse(scale, input) {\r\n      if (isNullOrUndef(input)) {\r\n        return null;\r\n      }\r\n      const adapter = scale._adapter;\r\n      const {parser, round, isoWeekday} = scale._parseOpts;\r\n      let value = input;\r\n      if (typeof parser === 'function') {\r\n        value = parser(value);\r\n      }\r\n      if (!isNumberFinite(value)) {\r\n        value = typeof parser === 'string'\r\n          ? adapter.parse(value, parser)\r\n          : adapter.parse(value);\r\n      }\r\n      if (value === null) {\r\n        return null;\r\n      }\r\n      if (round) {\r\n        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\r\n          ? adapter.startOf(value, 'isoWeek', isoWeekday)\r\n          : adapter.startOf(value, round);\r\n      }\r\n      return +value;\r\n    }\r\n    function determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n      const ilen = UNITS.length;\r\n      for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\r\n        const interval = INTERVALS[UNITS[i]];\r\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\r\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\r\n          return UNITS[i];\r\n        }\r\n      }\r\n      return UNITS[ilen - 1];\r\n    }\r\n    function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\r\n      for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\r\n        const unit = UNITS[i];\r\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\r\n          return unit;\r\n        }\r\n      }\r\n      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n    }\r\n    function determineMajorUnit(unit) {\r\n      for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\r\n        if (INTERVALS[UNITS[i]].common) {\r\n          return UNITS[i];\r\n        }\r\n      }\r\n    }\r\n    function addTick(ticks, time, timestamps) {\r\n      if (!timestamps) {\r\n        ticks[time] = true;\r\n      } else if (timestamps.length) {\r\n        const {lo, hi} = _lookup(timestamps, time);\r\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\r\n        ticks[timestamp] = true;\r\n      }\r\n    }\r\n    function setMajorTicks(scale, ticks, map, majorUnit) {\r\n      const adapter = scale._adapter;\r\n      const first = +adapter.startOf(ticks[0].value, majorUnit);\r\n      const last = ticks[ticks.length - 1].value;\r\n      let major, index;\r\n      for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n        index = map[major];\r\n        if (index >= 0) {\r\n          ticks[index].major = true;\r\n        }\r\n      }\r\n      return ticks;\r\n    }\r\n    function ticksFromTimestamps(scale, values, majorUnit) {\r\n      const ticks = [];\r\n      const map = {};\r\n      const ilen = values.length;\r\n      let i, value;\r\n      for (i = 0; i < ilen; ++i) {\r\n        value = values[i];\r\n        map[value] = i;\r\n        ticks.push({\r\n          value,\r\n          major: false\r\n        });\r\n      }\r\n      return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n    }\r\n    class TimeScale extends Scale {\r\n      constructor(props) {\r\n        super(props);\r\n        this._cache = {\r\n          data: [],\r\n          labels: [],\r\n          all: []\r\n        };\r\n        this._unit = 'day';\r\n        this._majorUnit = undefined;\r\n        this._offsets = {};\r\n        this._normalized = false;\r\n        this._parseOpts = undefined;\r\n      }\r\n      init(scaleOpts, opts) {\r\n        const time = scaleOpts.time || (scaleOpts.time = {});\r\n        const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);\r\n        mergeIf(time.displayFormats, adapter.formats());\r\n        this._parseOpts = {\r\n          parser: time.parser,\r\n          round: time.round,\r\n          isoWeekday: time.isoWeekday\r\n        };\r\n        super.init(scaleOpts);\r\n        this._normalized = opts.normalized;\r\n      }\r\n      parse(raw, index) {\r\n        if (raw === undefined) {\r\n          return null;\r\n        }\r\n        return parse(this, raw);\r\n      }\r\n      beforeLayout() {\r\n        super.beforeLayout();\r\n        this._cache = {\r\n          data: [],\r\n          labels: [],\r\n          all: []\r\n        };\r\n      }\r\n      determineDataLimits() {\r\n        const me = this;\r\n        const options = me.options;\r\n        const adapter = me._adapter;\r\n        const unit = options.time.unit || 'day';\r\n        let {min, max, minDefined, maxDefined} = me.getUserBounds();\r\n        function _applyBounds(bounds) {\r\n          if (!minDefined && !isNaN(bounds.min)) {\r\n            min = Math.min(min, bounds.min);\r\n          }\r\n          if (!maxDefined && !isNaN(bounds.max)) {\r\n            max = Math.max(max, bounds.max);\r\n          }\r\n        }\r\n        if (!minDefined || !maxDefined) {\r\n          _applyBounds(me._getLabelBounds());\r\n          if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\r\n            _applyBounds(me.getMinMax(false));\r\n          }\r\n        }\r\n        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\r\n        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\r\n        me.min = Math.min(min, max - 1);\r\n        me.max = Math.max(min + 1, max);\r\n      }\r\n      _getLabelBounds() {\r\n        const arr = this.getLabelTimestamps();\r\n        let min = Number.POSITIVE_INFINITY;\r\n        let max = Number.NEGATIVE_INFINITY;\r\n        if (arr.length) {\r\n          min = arr[0];\r\n          max = arr[arr.length - 1];\r\n        }\r\n        return {min, max};\r\n      }\r\n      buildTicks() {\r\n        const me = this;\r\n        const options = me.options;\r\n        const timeOpts = options.time;\r\n        const tickOpts = options.ticks;\r\n        const timestamps = tickOpts.source === 'labels' ? me.getLabelTimestamps() : me._generate();\r\n        if (options.bounds === 'ticks' && timestamps.length) {\r\n          me.min = me._userMin || timestamps[0];\r\n          me.max = me._userMax || timestamps[timestamps.length - 1];\r\n        }\r\n        const min = me.min;\r\n        const max = me.max;\r\n        const ticks = _filterBetween(timestamps, min, max);\r\n        me._unit = timeOpts.unit || (tickOpts.autoSkip\r\n          ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min))\r\n          : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));\r\n        me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined\r\n          : determineMajorUnit(me._unit);\r\n        me.initOffsets(timestamps);\r\n        if (options.reverse) {\r\n          ticks.reverse();\r\n        }\r\n        return ticksFromTimestamps(me, ticks, me._majorUnit);\r\n      }\r\n      initOffsets(timestamps) {\r\n        const me = this;\r\n        let start = 0;\r\n        let end = 0;\r\n        let first, last;\r\n        if (me.options.offset && timestamps.length) {\r\n          first = me.getDecimalForValue(timestamps[0]);\r\n          if (timestamps.length === 1) {\r\n            start = 1 - first;\r\n          } else {\r\n            start = (me.getDecimalForValue(timestamps[1]) - first) / 2;\r\n          }\r\n          last = me.getDecimalForValue(timestamps[timestamps.length - 1]);\r\n          if (timestamps.length === 1) {\r\n            end = last;\r\n          } else {\r\n            end = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\r\n          }\r\n        }\r\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\r\n        start = _limitValue(start, 0, limit);\r\n        end = _limitValue(end, 0, limit);\r\n        me._offsets = {start, end, factor: 1 / (start + 1 + end)};\r\n      }\r\n      _generate() {\r\n        const me = this;\r\n        const adapter = me._adapter;\r\n        const min = me.min;\r\n        const max = me.max;\r\n        const options = me.options;\r\n        const timeOpts = options.time;\r\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));\r\n        const stepSize = valueOrDefault(timeOpts.stepSize, 1);\r\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n        const hasWeekday = isNumber(weekday) || weekday === true;\r\n        const ticks = {};\r\n        let first = min;\r\n        let time, count;\r\n        if (hasWeekday) {\r\n          first = +adapter.startOf(first, 'isoWeek', weekday);\r\n        }\r\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\r\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\r\n          throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\r\n        }\r\n        const timestamps = options.ticks.source === 'data' && me.getDataTimestamps();\r\n        for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\r\n          addTick(ticks, time, timestamps);\r\n        }\r\n        if (time === max || options.bounds === 'ticks' || count === 1) {\r\n          addTick(ticks, time, timestamps);\r\n        }\r\n        return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\r\n      }\r\n      getLabelForValue(value) {\r\n        const me = this;\r\n        const adapter = me._adapter;\r\n        const timeOpts = me.options.time;\r\n        if (timeOpts.tooltipFormat) {\r\n          return adapter.format(value, timeOpts.tooltipFormat);\r\n        }\r\n        return adapter.format(value, timeOpts.displayFormats.datetime);\r\n      }\r\n      _tickFormatFunction(time, index, ticks, format) {\r\n        const me = this;\r\n        const options = me.options;\r\n        const formats = options.time.displayFormats;\r\n        const unit = me._unit;\r\n        const majorUnit = me._majorUnit;\r\n        const minorFormat = unit && formats[unit];\r\n        const majorFormat = majorUnit && formats[majorUnit];\r\n        const tick = ticks[index];\r\n        const major = majorUnit && majorFormat && tick && tick.major;\r\n        const label = me._adapter.format(time, format || (major ? majorFormat : minorFormat));\r\n        const formatter = options.ticks.callback;\r\n        return formatter ? callback(formatter, [label, index, ticks], me) : label;\r\n      }\r\n      generateTickLabels(ticks) {\r\n        let i, ilen, tick;\r\n        for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n          tick = ticks[i];\r\n          tick.label = this._tickFormatFunction(tick.value, i, ticks);\r\n        }\r\n      }\r\n      getDecimalForValue(value) {\r\n        const me = this;\r\n        return value === null ? NaN : (value - me.min) / (me.max - me.min);\r\n      }\r\n      getPixelForValue(value) {\r\n        const me = this;\r\n        const offsets = me._offsets;\r\n        const pos = me.getDecimalForValue(value);\r\n        return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n      }\r\n      getValueForPixel(pixel) {\r\n        const me = this;\r\n        const offsets = me._offsets;\r\n        const pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n        return me.min + pos * (me.max - me.min);\r\n      }\r\n      _getLabelSize(label) {\r\n        const me = this;\r\n        const ticksOpts = me.options.ticks;\r\n        const tickLabelWidth = me.ctx.measureText(label).width;\r\n        const angle = toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n        const cosRotation = Math.cos(angle);\r\n        const sinRotation = Math.sin(angle);\r\n        const tickFontSize = me._resolveTickFontOptions(0).size;\r\n        return {\r\n          w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\r\n          h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\r\n        };\r\n      }\r\n      _getLabelCapacity(exampleTime) {\r\n        const me = this;\r\n        const timeOpts = me.options.time;\r\n        const displayFormats = timeOpts.displayFormats;\r\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n        const exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);\r\n        const size = me._getLabelSize(exampleLabel);\r\n        const capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;\r\n        return capacity > 0 ? capacity : 1;\r\n      }\r\n      getDataTimestamps() {\r\n        const me = this;\r\n        let timestamps = me._cache.data || [];\r\n        let i, ilen;\r\n        if (timestamps.length) {\r\n          return timestamps;\r\n        }\r\n        const metas = me.getMatchingVisibleMetas();\r\n        if (me._normalized && metas.length) {\r\n          return (me._cache.data = metas[0].controller.getAllParsedValues(me));\r\n        }\r\n        for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n          timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));\r\n        }\r\n        return (me._cache.data = me.normalize(timestamps));\r\n      }\r\n      getLabelTimestamps() {\r\n        const me = this;\r\n        const timestamps = me._cache.labels || [];\r\n        let i, ilen;\r\n        if (timestamps.length) {\r\n          return timestamps;\r\n        }\r\n        const labels = me.getLabels();\r\n        for (i = 0, ilen = labels.length; i < ilen; ++i) {\r\n          timestamps.push(parse(me, labels[i]));\r\n        }\r\n        return (me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps));\r\n      }\r\n      normalize(values) {\r\n        return _arrayUnique(values.sort(sorter));\r\n      }\r\n    }\r\n    TimeScale.id = 'time';\r\n    TimeScale.defaults = {\r\n      bounds: 'data',\r\n      adapters: {},\r\n      time: {\r\n        parser: false,\r\n        unit: false,\r\n        round: false,\r\n        isoWeekday: false,\r\n        minUnit: 'millisecond',\r\n        displayFormats: {}\r\n      },\r\n      ticks: {\r\n        source: 'auto',\r\n        major: {\r\n          enabled: false\r\n        }\r\n      }\r\n    };\r\n    \r\n    function interpolate(table, val, reverse) {\r\n      let prevSource, nextSource, prevTarget, nextTarget;\r\n      if (reverse) {\r\n        prevSource = Math.floor(val);\r\n        nextSource = Math.ceil(val);\r\n        prevTarget = table[prevSource];\r\n        nextTarget = table[nextSource];\r\n      } else {\r\n        const result = _lookup(table, val);\r\n        prevTarget = result.lo;\r\n        nextTarget = result.hi;\r\n        prevSource = table[prevTarget];\r\n        nextSource = table[nextTarget];\r\n      }\r\n      const span = nextSource - prevSource;\r\n      return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\r\n    }\r\n    class TimeSeriesScale extends TimeScale {\r\n      constructor(props) {\r\n        super(props);\r\n        this._table = [];\r\n        this._maxIndex = undefined;\r\n      }\r\n      initOffsets() {\r\n        const me = this;\r\n        const timestamps = me._getTimestampsForTable();\r\n        me._table = me.buildLookupTable(timestamps);\r\n        me._maxIndex = me._table.length - 1;\r\n        super.initOffsets(timestamps);\r\n      }\r\n      buildLookupTable(timestamps) {\r\n        const me = this;\r\n        const {min, max} = me;\r\n        if (!timestamps.length) {\r\n          return [\r\n            {time: min, pos: 0},\r\n            {time: max, pos: 1}\r\n          ];\r\n        }\r\n        const items = [min];\r\n        let i, ilen, curr;\r\n        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n          curr = timestamps[i];\r\n          if (curr > min && curr < max) {\r\n            items.push(curr);\r\n          }\r\n        }\r\n        items.push(max);\r\n        return items;\r\n      }\r\n      _getTimestampsForTable() {\r\n        const me = this;\r\n        let timestamps = me._cache.all || [];\r\n        if (timestamps.length) {\r\n          return timestamps;\r\n        }\r\n        const data = me.getDataTimestamps();\r\n        const label = me.getLabelTimestamps();\r\n        if (data.length && label.length) {\r\n          timestamps = me.normalize(data.concat(label));\r\n        } else {\r\n          timestamps = data.length ? data : label;\r\n        }\r\n        timestamps = me._cache.all = timestamps;\r\n        return timestamps;\r\n      }\r\n      getPixelForValue(value, index) {\r\n        const me = this;\r\n        const offsets = me._offsets;\r\n        const pos = me._normalized && me._maxIndex > 0 && !isNullOrUndef(index)\r\n          ? index / me._maxIndex : me.getDecimalForValue(value);\r\n        return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n      }\r\n      getDecimalForValue(value) {\r\n        return interpolate(this._table, value) / this._maxIndex;\r\n      }\r\n      getValueForPixel(pixel) {\r\n        const me = this;\r\n        const offsets = me._offsets;\r\n        const decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n        return interpolate(me._table, decimal * this._maxIndex, true);\r\n      }\r\n    }\r\n    TimeSeriesScale.id = 'timeseries';\r\n    TimeSeriesScale.defaults = TimeScale.defaults;\r\n    \r\n    var scales = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    CategoryScale: CategoryScale,\r\n    LinearScale: LinearScale,\r\n    LogarithmicScale: LogarithmicScale,\r\n    RadialLinearScale: RadialLinearScale,\r\n    TimeScale: TimeScale,\r\n    TimeSeriesScale: TimeSeriesScale\r\n    });\r\n    \r\n    Chart.register(controllers, scales, elements, plugins);\r\n    Chart.helpers = {...helpers};\r\n    Chart._adapters = _adapters;\r\n    Chart.Animation = Animation;\r\n    Chart.Animations = Animations;\r\n    Chart.animator = animator;\r\n    Chart.controllers = registry.controllers.items;\r\n    Chart.DatasetController = DatasetController;\r\n    Chart.Element = Element;\r\n    Chart.elements = elements;\r\n    Chart.Interaction = Interaction;\r\n    Chart.layouts = layouts;\r\n    Chart.platforms = platforms;\r\n    Chart.Scale = Scale;\r\n    Chart.Ticks = Ticks;\r\n    Object.assign(Chart, controllers, scales, elements, plugins, platforms);\r\n    Chart.Chart = Chart;\r\n    if (typeof window !== 'undefined') {\r\n      window.Chart = Chart;\r\n    }\r\n    \r\n    return Chart;\r\n    \r\n    })));"],"names":[],"sourceRoot":"webpack:///"}